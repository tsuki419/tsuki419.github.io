<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单调栈]]></title>
    <url>%2F%E5%8D%95%E8%B0%83%E6%A0%88.html</url>
    <content type="text"><![CDATA[单调栈。 单调栈判别是否需要使用单调栈，如果需要找到左边或者右边第一个比当前位置的数大或者小，则可以考虑使用单调栈；单调栈的题目如矩形米面积等等 来源739官解评论区 739. 每日温度 stack存数组的下标。 1Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;(); 思路是while（栈不空&amp;&amp;当前温度大于栈顶温度），计算ans[]，栈顶出栈。 1234567891011int length = temperatures.length;Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();int[] ans = new int[length];for(int i = 0; i &lt; length; i++)&#123; int temperature = temperatures[i]; while(!stack.isEmpty() &amp;&amp; temperature &gt; temperatures[stack.peek()])&#123; int preIndex = stack.pop(); ans[preIndex] = i - preIndex; &#125; stack.push(i);&#125; 496. 下一个更大元素 I 单调栈+哈希 503. 下一个更大元素 II 单调栈+循环数组 42. 接雨水 84. 柱状图中最大的矩形]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[贪心专题。 贪心算法通过局部最优解得到全局最优解 leetcode 334 递增的三元子序列 注意递增的子序列可以是不连续的。first， second，third，只要维护这三个数。先确定first和second。 55. 跳跃游戏 明明用了贪心为什么待在动态规划列表里。时隔四个月重新做，思路都忘了。此处的贪心是记录最远的位置。 45. 跳跃游戏 II 贪心，还是这个思路写的清楚，每次在上次跳到的最大范围内选择跳的最远的。有点像最短/长路径问题。 基本思路就是设置最大位置，在遍历的过程中更新最大的位置。 12345678910int n = nums.length;int maxP = 0, step = 0, end = 0;for(int i = 0; i &lt; n - 1; i++)&#123; maxP = Math.max(maxP, nums[i] + i); if(i == end)&#123; end = maxP; step++; &#125;&#125; leetcode 122 买卖股票的最佳时机II 买股票系列 leetcode 334 递增的三元子序列，最长连续子序列。 455. 分发饼干 思路是先排序，然后挨个匹配。和官解思路是一致的。 376. 摆动序列 123456789int prediff = nums[1] - nums[0];int len = prediff != 0 ? 2:1;for(int i = 2; i &lt; n; i++)&#123; int diff = nums[i] - nums[i - 1]; if((diff &gt; 0 &amp;&amp; prediff &lt;= 0) || (diff &lt; 0 &amp;&amp; prediff &gt;= 0))&#123; len++; prediff = diff; &#125;&#125; 53. 最大子数组和 思路是动态规划。关键在于状态转移方程。 1005. K 次取反后最大化的数组和 思路是排序，把负数取反。这里有个巧妙地点是在负数取反以后再进行一次排序。 12345678910111213Arrays.sort(nums);int sum = 0;for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] &lt; 0 &amp;&amp; k &gt; 0)&#123; nums[i] = -nums[i]; k--; &#125; sum+=nums[i];&#125;Arrays.sort(nums);if(k % 2 != 0)&#123; sum -= 2 * nums[0];&#125; 134. 加油站 一次遍历。有点像加了cost的跳跃游戏。看了题解有点不理解为什么贴贪心标签。 补充一个推理： 如果x到不了y+1（但能到y），那么从x到y的任一点出发都不可能到达y+1。因为从其中任一点出发的话，相当于从0开始加油，而如果从x出发到该点则不一定是从0开始加油，可能还有剩余的油。既然不从0开始都到不了y+1，那么从0开始就更不可能到达y+1了… 来源：官解评论区 1234567891011121314151617181920int n = gas.length;int i = 0;while(i &lt; n)&#123; int gasSum = 0, costSum = 0, count = 0;//走过的站点个数 //找到第一个不能通过的站点 while(count &lt; n)&#123; int curr = (i + count) % n;//环形路 gasSum += gas[curr]; costSum += cost[curr]; if(gasSum &lt; costSum)&#123; break; &#125; count++; &#125; if(count == n)&#123; return i; &#125;else&#123; i = i + count + 1; &#125;&#125; 135. 分发糖果 两次遍历。 123456789101112131415161718int n = ratings.length;int[] left = new int[n];//先看左边的情况for(int i = 0; i &lt; n; i++)&#123; if(i &gt; 0 &amp;&amp; ratings[i] &gt; ratings[i - 1])&#123; left[i] = left[i - 1] + 1; &#125;else&#123; left[i] = 1; &#125;&#125;int right = 0, ans = 0;//right节省空间for(int i = n - 1; i &gt;=0; i--)&#123; if(i &lt; n - 1 &amp;&amp; ratings[i] &gt; ratings[i + 1])&#123; right++; &#125;else&#123; right = 1; &#125; ans += Math.max(right, left[i]);&#125; 860. 柠檬水找零 面值有三种，采用计数的方法，分情况讨论。 1234567891011121314151617181920212223int five = 0, ten = 0;//张数for(int bill : bills)&#123; if(bill == 5)&#123; five++; &#125;else if(bill == 10)&#123; if(five &gt; 0)&#123; five--; ten++; &#125;else&#123; return false; &#125; &#125;else&#123; if(ten &gt; 0 &amp;&amp; five &gt; 0)&#123; ten--; five--; &#125;else if(five &gt;= 3)&#123; five -= 3; &#125;else&#123; return false; &#125; &#125;&#125; 406. 根据身高重建队列 思路从高到低对身高排序，然后依次插入。遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。 回顾一下，重写compare和Arraylist用法 arraylist.add（int index，E element） 12345678910111213Arrays.sort(people, new Comparator&lt;int[]&gt;()&#123; public int compare(int[] p1, int[] p2)&#123; if(p1[0] != p2[0])&#123; return p2[0] - p1[0]; &#125;else&#123; return p1[1] - p2[1]; &#125; &#125;&#125;);List&lt;int[]&gt; ans = new ArrayList&lt;&gt;();for(int[] person : people)&#123; ans.add(person[1], person);&#125; 区间问题435. 无重叠区间 解法以右端点排序。为什么要选择从左到右遍历，其实没看懂，给右侧区间留空间？官方解答也很迷。 当确定了首个区间之后，所有与首个区间不重合的区间就组成了一个规模更小的子问题。由于我们已经在初始时将所有区间按照右端点排好序了，因此对于这个子问题，我们无需再次进行排序，只要找出其中与首个区间不重合并且右端点最小的区间即可。 123456789101112131415Arrays.sort(intervals, new Comparator&lt;int[]&gt;()&#123; public int compare(int[] o1, int[] o2)&#123; return o1[1] - o2[1]; &#125;&#125;);int n = intervals.length;int right = intervals[0][1];int ans = 1;for(int i = 1; i &lt; n; i++)&#123; if(intervals[i][0] &gt;= right)&#123; right = intervals[i][1]; ans++; &#125;&#125; 452. 用最少数量的箭引爆气球 虽然题目饶了一点，但也是区间问题。两个维度。 贪心体现在：当两个区间不相交时，必然需要一直箭去引爆其中一个区间(换句话说，两个区间不可能被同时引爆)，我们在射出这只箭的同时引爆所有可能被引爆的区间(即做出局部最优选择)。 所以换句话说，这个题是不是还是在求不重叠区间。 这里遇到了一个测试用例问题。[ [-2147483646,-2147483645],[2147483646,2147483647] ]，相减的写法多半的越界了。 在排序时改变书写方式。 1Arrays.sort(points, (p1, p2) -&gt; p1[1] &lt; p2[1] ? -1 : 1); 763. 划分字母区间 字符串，贪心。 12345678910111213141516int n = s.length();int[] last = new int[26];for(int i = 0; i &lt; n; i++)&#123; //字母最后出现的位置 last[s.charAt(i) - 'a'] = i;&#125;int start = 0, end = 0;List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();for(int i = 0; i &lt; n; i++)&#123; end = Math.max(end, last[s.charAt(i) - 'a']); if(end == i)&#123; ans.add(end - start + 1); start = end + 1; &#125;&#125; 56. 合并区间 以左端点排序，合并的区间是连续的。尝试了Arrays.sort()的ES6写法但是执行出错，不知道原因。 12345678910111213141516171819public int[][] merge(int[][] intervals) &#123; int n = intervals.length; Arrays.sort(intervals, new Comparator&lt;int[]&gt;()&#123; public int compare(int[] p1, int[] p2)&#123; return p1[0] - p2[0]; &#125; &#125;); List&lt;int[]&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; n; i++)&#123; int L = intervals[i][0], R = intervals[i][1]; if(ans.size() == 0 || ans.get(ans.size() - 1)[1] &lt; L)&#123; ans.add(new int[]&#123;L, R&#125;); &#125;else&#123; ans.get(ans.size() - 1)[1] = Math.max(R, ans.get(ans.size() - 1)[1]); &#125; &#125; return ans.toArray(new int[ans.size()][]);&#125; 738. 单调递增的数字 没看懂官解，但是评论区的思路很清楚。 【思路】从左往右遍历各位数字，找到第一个开始下降的数字[i]，将[i]减1，然后将[i+1 …]各位数字全部置为9即可 123456789101112131415161718char[] strN = Integer.toString(n).toCharArray();int i = 1;while(i &lt; strN.length &amp;&amp; strN[i] &gt;= strN[i - 1])&#123; i++;&#125;if(i &lt; strN.length)&#123; while(i &gt; 0 &amp;&amp; strN[i] &lt; strN[i - 1])&#123; strN[i - 1]--; i--; &#125; for(i++; i &lt; strN.length; i++)&#123; strN[i] = '9'; &#125;&#125;return Integer.parseInt(new String(strN)); 队列leetcode 1606 处理请求最多的服务器]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security + JWT权限管理]]></title>
    <url>%2FSpringSecurity-JWT.html</url>
    <content type="text"><![CDATA[Spring Security框架确实好用，在简单的集成使用之后，还是决定写一下原理的总结，从源头理解框架的实现。有些内容摘自前人博客。权限认证是几乎每个系统都会用到的技术，特别总结。在项目中的实现参考了mall项目。 SpringSecurity先贴参考： Spring Security 核心类简介 认证简介 核心类Authentication 是一个接口，用来表示用户认证信息的。在用户登录认证之前相关信息会封装为一个 Authentication 具体实现类的对象，在登录认证成功之后又会生成一个信息更全面，包含用户权限等信息的 Authentication 对象，然后把它保存在 SecurityContextHolder 所持有的 SecurityContext 中，供后续的程序进行调用，如访问权限的鉴定等。 SecurityContextHolder 是用来保存 SecurityContext 的。SecurityContext 中含有当前正在访问系统的用户的详细信息和代表当前用户相关信息的 Authentication 的引用。默认情况下，SecurityContextHolder 将使用 ThreadLocal 来保存 SecurityContext。 AuthenticationManager 是一个用来处理认证（Authentication）请求的接口，它的默认实现是 ProviderManager。通过 Authentication.getPrincipal() 可以获取到代表当前用户的信息，这个对象通常是 UserDetails 的实例。UserDetails 是 Spring Security 中一个核心的接口。其中定义了一些可以获取用户名、密码、权限等与认证相关的信息的方法。UserDetails 是通过 UserDetailsService 的 loadUserByUsername() 方法进行加载的。 Authentication 的 getAuthorities() 可以返回当前 Authentication 对象拥有的权限，即当前用户拥有的权限。其返回值是一个 GrantedAuthority 类型的数组，每一个 GrantedAuthority 对象代表赋予给当前用户的一种权限。GrantedAuthority 是一个接口，其通常是通过 UserDetailsService 进行加载，然后赋予给 UserDetails 的。 看完是不是一堆名词云里雾里，没关系，多看几次就理顺了。 核心流程用户输入用户名和密码登录，SpringSecurity将获取到的用户名和密码封装成一个实现了Authentication接口的UsernamePasswordAuthenticationToken，将上述产生的token传递给AuthenticationManager进行登录验证，验证成功后会返回一个封装了用户权限信息的Authentication对象，通过调用SecurityContextHolder.getContext().setAuthentication()将Authentication对象赋予当前的SecurityContext. UserDetailsService我们可以通过自己实现UserDetails来定义自己获取用户其他信息的方法。也可以实现UserDetailsService来加载自定义的UserDetails信息。 UserDetails用户详情： 123456789public interface UserDetails extends Serializable &#123; Collection&lt;? extends GrantedAuthority&gt; getAuthorities();//权限 String getPassword(); //密码 String getUsername(); //用户名 boolean isAccountNonExpired(); //账号是否未过期 boolean isAccountNonLocked(); //账号是否未锁定 boolean isCredentialsNonExpired();//密码是否未过期 boolean isEnabled(); //是否激活&#125; BCryptPasswordEncoder是Spring Security官方推荐的密码解析器，平时多使用这个解析器。BCryptPasswordEncoder是对bcrypt强散列方法的具体实现。是基于Hash算法实现的单向加密。可以通过strength控制加密强度，默认10. Spring Security-安全管理框架配合源码给出了自定义登录逻辑修改实例。 其他参考： Spring Security 使用、实现权限访问控制 Spring Security的GrantedAuthority（已授予的权限） 加入JWT验证在配置类中加入自定义拦截器 12// 添加JWT filterhttpSecurity.addFilterBefore(jwtAuthenticationTokenFilter(), UsernamePasswordAuthenticationFilter.class); 传统的Session认证方式http协议本身是一种无状态的协议，也就是每发起一次请求就要进行一次用户密码验证。因此我们在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送应用，应用就能识别请求来自哪个用户了，这就是传统的基于session认证。 总的来说登录验证就一下几步： 获取用户信息 调用service查询user 判断用户是否存在：有（存到Session，并跳转首页） 否（跳转到登录页面） 123456789101112131415161718192021222324//吐槽一下老旧的代码，甚至逻辑也不太清晰protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); //从请求中获取用户名和密码 String name=request.getParameter("username"); String password=request.getParameter("password"); //设置session信息 session.setAttribute("name", name); //获取用户 UserDao ud=DaoFactory.getInstance().getUserDao(); JSONObject jsondata = new JSONObject(); //获取用户等级---查询user jsondata=ud.getGrade(name, password); //判断用户是否存在 if(jsondata.getString("grade") !="0")&#123; out.write(jsondata.toString()); &#125;else&#123; request.setAttribute("msg", "您的用户名和密码不正确"); request.getRequestDispatcher("/login.html").forward(request,response); &#125; out.write(jsondata.toString());&#125; 通常认证的记录被保存在内存中，传统的方式存在服务器开销大，扩展性差等问题。 基于token控制也是无状态的，但是它不需要在服务端去保留用户的认证信息或者会话信息。流程上是这样的： 用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据 这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。 以上分析参考自文章什么是JWT JWT构成第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature). jwt的头部承载两部分信息： 声明类型，这里是jwt 声明加密的算法 通常直接使用 HMAC SHA256 payload就是存放有效信息的地方，标注中注册的声明，公有的声明和私有的声明。 signature这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。 Spring Security权限控制 + JWT Token认证中token验证和权限控制阶段流程也可以参考，收藏一下。 动态权限控制最后回忆一下mall项目的权限控制。最初采用了@PerAuthorize注解定义好需要的权限，将该权限存入权限表，当用户登录时将所有的权限查询出来。然后Spring Security将用户所有的权限值和接口注解定义的权限值进行比对。这样做无法批量控制接口的权限。 在后来的版本中使用Spring Security实现基于路径的动态权限。 在配置类中加入DynamicSecurityFilter 1234//有动态权限配置时添加动态权限校验过滤器if(dynamicSecurityService!=null)&#123; registry.and().addFilterBefore(dynamicSecurityFilter(), FilterSecurityInterceptor.class);&#125; 动态权限调用过程： 在DynamicSecurityFilter中调用super.beforeInvocation(fi)方法时会调用AccessDecisionManager中的decide方法用于鉴权操作，而decide中的configAttributes参数会通过SecurityMetadataSource中的getAttributes方法来获取。 后台资源规则被缓存在了一个Map对象中，当后台资源发生变化时，我们需要清空缓存的数据，然后在下次查询的时候重新加载进来。Mall项目中修改UmsResourceController类，当修改后台资源的时候，需要调用clearDataSource来清空缓存的数据。 参考自mall项目升级动态权限控制 获取权限列表过程： UserDetailsService====&gt;调用LoadUserByUsername(String username)====&gt;调用getResourceList(id)====&gt;adminCacheService.getResourceList(id)=====&gt;adminRoleRelationDao.getResourceList(id);获取到权限列表和UserInfo]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Security</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Blog项目学习]]></title>
    <url>%2FMy-Blog%E8%BF%90%E8%A1%8C%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[My Blog学习记录 项目地址： My blog，属于是入门的SpringBoot项目吧。 启动分析 新建数据库时，提供的sql语句：Invalid default value for &#39;create_time&#39;，作者给出的参考 虽然github附了开发文档，点进去发现是付费的，用技术吃饭也无可厚非。不过有源码，自己啃就好了。 后台管理部分主要是操作了session和request的参数，评论分类标签友链博客管理都是差不多的，没什么参考的。感兴趣的是发布博客页面和博客的数据库设计。 博客内容的存储格式：mediumtext 发布博客涉及的操作 transferTo：零拷贝 富文本和文件上传参考视频 nextTik 懒加载 git为什么要用版本控制 没有版本控制系统的话，代码可能被别人或自己不小心覆盖或遗失、也不知道是谁因为什么原因改了这段代码、也没办法可以复原回前几天的修改。有了版本控制系统，开发人员只要将每次开发的变更都纪录（Commit）起来，并且透过版本控制系统中进行更新。 虽然在上传博客的时候都会用到git但是并没有研究过版本控制。 git与svn的区别 thymeleaf读音/taimlif/ 参考博客 Thymeleaf是用来开发Web和独立环境项目的服务器端的Java模版引擎 Spring官方支持的服务的渲染模板中，并不包含jsp。而是Thymeleaf和Freemarker等，而Thymeleaf与SpringMVC的视图技术，及SpringBoot的自动化配置集成非常完美，几乎没有任何成本，你只用关注Thymeleaf的语法即可。 但是这样用的话前后端耦合严重，如果是自己开发项目还好，团队合作就会增加很多的交流问题。前后端分离真香。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>git</tag>
        <tag>thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue学习]]></title>
    <url>%2Fvue.html</url>
    <content type="text"><![CDATA[vue的简单学习，面向项目学习。包括了一些名词的解释学习和两个前端项目的学习。 vue入门vue.js 的API文档 下载vue.min.js，使用script标签引入。 Vue 构造器中有一个el 参数，它是 DOM 元素中的 id。data 用于定义属性，methods 用于定义的函数，可以通过 return 来返回函数值。双花括号用于输出对象属性和函数返回值 使用 v-html 指令用于输出 html 代码 HTML 属性中的值应使用 v-bind 指令。 指令是带有 v- 前缀的特殊属性。指令用于在表达式的值改变时，将某些行为应用到 DOM 上 在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定 按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。 组件（Component）是 Vue.js 最强大的功能之一。 安装cnpm install -g @vue/cli node@10.15.3版本太低，不匹配vue@3.x的版本 升级node， 通过n模块 npm install -g n报错，改为 npm i -g n --force，安装成功了，但是n命令不能使用。 通过nvm 下载nvm，github太不稳定了，下载不了，感谢博主的百度云链接，然后参照文章进行安装，几个注意点：文件夹名不要出现 中文 和 空格；在运行nvm install 的时候，有可能会出现无权限安装的问题，如果遇到此问题，请 以管理员身份运行 cmd。 node安装成功但是npm不能安装。有坑 nvm安装后node生效但是npm不生效 在nvm安装目录，找到 setting.txt用记事本打开添加如下两行： 12node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 手动去安装，下载地址， 自己下载node对应的npm版本 解压后将文件夹重命名为npm并复制到node_modules目录下 最后将npm中bin目录下的npm以及npm.cmd复制到与node_modules目录同级目录下 完美解决。 如何从Windows中删除Node.js： ​ C:\Program Files (x86)\Nodejs ​ C:\Program Files\Nodejs​ C:\Users{User}\AppData\Roaming\npm（或%appdata%\npm） ​ C:\Users{User}\AppData\Roaming\npm-cache（或%appdata%\npm-cache） 123456789nvm install 14.5.0 // 安装14.5.0版本node nvm install latest // 安装最新版本node nvm list // 显示已安装的版本（同 nvm list installed） nvm list installed // 显示已安装的版本nvm list available // 显示所有可以下载的版本 nvm use 14.5.0 // 使用14.5.0版本node nvm uninstall 14.5.0 // 卸载14.5.0版本node 通过gnvm，方法二成功了，未尝试方法三 nvm知识补充 idea创建vue项目（参考视频，参考博客 npm@v8.3.1好像有bug，创建项目出错，npm ERR! Unexpected token &#39;.&#39; 更换版本，node@v14.16.0，npm@v6.14.1，成功创建 正式进入开发 开发下载了一个开源模板，RuoYI-Vue，对应的说明文档手摸手，带你用vue撸后台，选择了基础模板==&gt;vueAdmin-template（对应文档）。本篇前端用了element-ui 后续进行主页面定位的开发，参考开源的代码，博客GPS定位系统(四)——Vue前端，本篇前端用了ivew-admin，后台github地址GpsServer 项目1目录结构router路径映射，通过地址可以访问界面。 components+views一些代码通过组件的方式打包，在别的界面进行引入。 搭建页面：使用element组件，参考mall项目，先搭后台管理页面。 在研读vue-admin-template项目代码前，有必要搞清楚vue项目结构关系。 而index.html中 1&lt;div id="app"&gt;来自index.html正文中的内容&lt;/div&gt; 上面有一个id为app的挂载点，之后我们的Vue根实例就会挂载到该挂载点上； main.js作为项目的入口文件，在main.js中，新建了一个Vue实例，在Vue实例中，通过 告诉该实例要挂载的地方；（即实例装载到index.html中的位置） 参考文章1，文章2 项目2建立数据库和修改连接池配置，虽然出了点小问题，但是意外的很快跑起来了。完美~接下来进行项目的学习，该项目很像我正在做的项目。 目录结构观察路由表，地图相关的有：now-gps; gps-history可以参考。 store文件夹中user.js, 对user信息的增删改查，处理登录信息，处理轨迹信息。调用了util.js实现对user信息的操控。 瞎折腾项目gps添加swagger-ui莫名其妙的出问题， 先是添加版本号解决了插件找不到问题， swagger报错No handler found for GET /swagger-ui.html 按照博客的方法，添加映射之后，仍然有问题：com.jafir.springboot.exception.TokenException: null，懒得继续搞了，无意义。 element-ui参考文档，适配vue2 element-plus参考文档，适配vue3 vuex参考文档 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 Axios参考文档 Axios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。 mock测试用，数据模拟生成器 webpack本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 vue程序的调试 MARKpro1 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大—–异步请求？ JavaScript.trim() 方法用于删除字符串的头尾空白符. 在接收服务器数据时一般是字符串。我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。 富文本 pro2 vm.$emit( event, arg ) //触发当前实例上的事件，api文档 .env.development（开发环境）、.env.prodction（正式环境）、自定义环境，参考博客，vue-cli官方文档 前端开发：npm run serve 和 npm run dev 的区别 package.json文件中的’scripts’字段定义了怎么启动项目。 登录token处理参考博客 通过设置 ajax 拦截器，将 token 放在header 中，使每次请求带上 token，在每次发送请求时，让后台先判断 token 是否合法，再进行下一步操作。 此处将token临时存储到cookie中。 登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个token，拿到token之后（我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会根据token再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。 权限验证：通过token获取用户对应的 role，动态根据用户的 role 算出其对应有权限的路由，通过 router.addRoutes 动态挂载这些路由。链接：https://juejin.cn/post/6844903478880370701 js-cookie因为HTTP协议是无状态协议，一旦本次会话结束，客户端与服务器的连接就会关闭，下次需要重新建立连接，服务器就无法跟踪上次会话了。为了跟踪会话，需要使用Cookie 参考文档 ES6无论是前端还是后台项目的编写都用到了ES6语法。参考文章 ES6是JavaScript语言的新一代标准，加入了一些新的功能和语法。 ES6中可以使用 =&gt; 作为函数表达形式，极简风格，参数＋ =&gt; ＋函数体。 ES6 推荐在函数中使用 let 定义变量 const 用来声明一个常量，但也并非一成不变的 let 和 const 只在最近的一个块中（花括号中）有效 ES6 中可以通过 Symbol.iterator 给对象设置默认的遍历器，直到状态为true退出。 ES6还是有很多棒棒的语法，有利于精简代码，高效开发；只不过一些低级别浏览器不支持，可以用Babel等工具把ES6转化成ES5，但是有些语法还是不够完善 @TableId(value=”id”, type=IdType.AUTO) 设置id自增 mixin类似面向对象的继承机制，定义一个基类，继承自基类，可以复用代码，参考文档]]></content>
      <categories>
        <category>技术</category>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mall学习记录]]></title>
    <url>%2Fmall%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[不算是学习的第一个开源项目，但是是第一个运行起来的开源项目。作者的说明文档真的写的太棒了，手把手教学。 在自己准备定位系统项目的过程中碰壁好多，突发奇想，现在的水平自己造轮子很烂，老师给的项目也比较老旧，没有参考价值，没有进展，转换思维，不如先找个开源的优秀项目学习一下。 (这篇文章是去年存货了，最近整理一下都存在博客里，在这个项目中真的学到了很多，在学习mall之前还是个启动开源项目都会出好多bug的小白，现在进步了一点点) 启动记录首先github地址贴上 前端 后端 前端： Error: sass-loader requires node-sass ＞=4. Please install a compatible version. 输入下面代码，参考博客 npm install sass-loader node-sass -D 后端的架构和技术选型文档，有教程文档太贴心了。 首先当然是，git clone 地址.git，连接不上github直接采用了下载zip，效果是一样的。 准备环境。 Redis—-下载地址 v3.2.100 Elasticsearch–下载地址 v7.6.2 搜索功能优化 Kibana–下载 v7.6.2 作为访问Elastisearch的客户端 Logstash–下载 v7.6.2 用于收集日志 建立数据库—下载地址 查看数据库存储的位置 导入数据库脚本，要先创建mall数据库 数据库表前缀说明 cms_*：内容管理模块相关表 oms_*：订单管理模块相关表 pms_*：商品模块相关表 sms_*：营销模块相关表 ums_*：会员模块相关表 启动redis 进入安装位置，输入 redis-server.exe redis.windows.conf 启动后端程序，启动前端界面 登录出错 java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter 原因是jdk版本过高，可以手动导入或者降低jdk版本 参考了博客 12345678910111213141516171819202122232425&lt;!-- 导入4个jar包，解决jdk9缺失jar包引起的报错--&gt;&lt;!-- java.lang.NoClassDefFoundError: javax/xml/bind/DatatypeConverter--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt; &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 啊，至此admin启动成功，感动哭。 基础技术补充配套mall学习代码git地址 搭建基本骨架LombokLombok表达式—面向函数编程 参考1 2 MyBatisGeneratorMyBatis的代码生成器，可以根据数据库生成model、mapper.xml、mapper接口和Example，通常情况下的单表查询不用再手写mapper。 Swagger-UI实现在线API文档Security+JWT 认证和授权mall-tiny-04 报错：javax.xml.bind.DatatypeConverter 同样是jdk版本太高了，参考了博客 莫名其妙的swagger接口测试失败，所以删除了项目重新解压载入，解决上述报错后测试成功。估计上次错误也是这个原因，但是不提示报错信息，就束手无策了。 知道了，这时候的解决方法是打断点，进入debug。 12 String token = adminService.login(umsAdminLoginParam.getUsername(), umsAdminLoginParam.getPassword());============&gt; Elasticsearch实现商品搜索报错： None of the configured nodes are available: 通常是clustername设置有问题，但在本项目中是因为版本不匹配，下载了v7.6.2，yml的配置已经修改。 Spring Data Elasticsearch，一种以Spring Data风格来操作数据存储的方式。 添加依赖修改配置文件。 新建商品文档对象：EsProduct，接口EsProductDao实现与数据库交互，导入数据到ES文档 不需要中文分词的字段设置成@Field(type = FieldType.Keyword)类型，需要中文分词的设置成@Field(analyzer = “ik_max_word”,type = FieldType.Text)类型。 EsProductRepository extends ElasticsearchRepository：这样就拥有了一些基本的 Elasticsearch 数据操作方法，同时定义了一个衍生查询方法。 EsProductService-EsProductServiceImpl： 123456789101112131415161718192021222324252627public interface EsProductService &#123; /** * 从数据库中导入所有商品到ES */ int importAll(); /** * 根据id删除商品 */ void delete(Long id); /** * 根据id创建商品 */ EsProduct create(Long id); /** * 批量删除商品 */ void delete(List&lt;Long&gt; ids); /** * 根据关键字搜索名称或者副标题 */ Page&lt;EsProduct&gt; search(String keyword, Integer pageNum, Integer pageSize);&#125; EsProductController：聚合EsProductService，调用Service方法完成搜索。映射搜索请求路径。 创建索引，获取索引，jsoup解析网页 简单查询 在 SpringBoot 中，使用 Elasticsearch Repositories 的衍生物查询来实现；查询结果的原理原理就是将规则方法名称的方法名称转换为 E 的查询 DSL 语句 复杂查询Mongodb实现文档操作使用场景： 各种应用服务的日志存储，敏捷开发，地理位置信息存储，json存储。 示例添加会员浏览记录 非关系型数据库，和elasticsearch的操作非常像，都是Spring Data类型的数据操作 添加依赖，修改配置 建立文档 继承MongoRepository，这样就有了一些基本的操作Mongodb数据操作方法。 两者都可使用衍生查询 在接口中直接指定查询方法名称便可查询，无需进行实现 安装过程中的踩坑： 按照教程步骤进行但是连接失败。 安装路径中不要包含空格， NO Program Files！留下血泪。保姆级教程 mongod..cfg重要配置详解 仍然有问题，删除data目录下的文件又重新建了文件夹。参考博客 管理员身份运行，问题解决 mongod --config &quot;E:\Programs\MongoDB\Server\3.2\mongod.cfg&quot; --install --serviceName &quot;MongoDB&quot; net start MongoDB Redistiny-03 可用于数据缓存，主要用于处理大量数据的高访问负载。 整合redis的过程以短信验证码为例。 application.yml添加redis的配置，添加自定义key的设置 添加RedisService接口用于定义常用Redis操作。 实现RedisService接口（注入StringRedisTemplate（继承自RedisTemplate）） 添加根据电话号码获取验证码接口 Controller 添加需要的功能服务接口和实现类 StringBuilder教学示例中获取动态验证码通过StringBuilder来产生。 摘自官方文档 StringBuilder ，它是一个可变字符串类。 可变性是指在创建类的实例后，可以通过追加、移除、替换或插入字符来修改它。StringBuilder对象维护缓冲区以容纳对字符串的扩展。 使用场景： 如果希望代码在设计时对字符串进行未知数量的更改 (例如，当你使用循环来连接包含用户输入) 的随机数量的字符串时。 希望代码对字符串进行大量更改时。 RabbitMQ 实现延迟消息安装： Erlang下载，记得安装完成配置环境变量，安装教程 Rabbitmq下载路径 http://localhost:15672/ OSS 实现文件上传业务熟悉：数据库设计整个看了一遍。还是挺复杂的。 商品模块：主页面的商品分类，商品品牌（店铺），商品属性选择（属性和描述参数）；编辑商品（商品基本信息，促销信息，属性信息，关联），库存表，打折表（满减方式，打折方式，会员积分抵扣方式），商品评价和回复，商品操作记录; 订单模块：不同状态下的订单，订单表，订单商品表（一个订单包含不同的商品），订单操作记录表；从下单到选地址，计算优惠，到形成订单预览，选择支付方式，订单处理，售后服务（订单退货，退货原因管理，退货地址管理）。 营销模块：限时购主题设置，限时购商品选择（秒杀活动）；优惠券表；首页品牌推荐表，新品推荐，人气推荐，首页专题推荐，首页轮播广告。 源码解析mall-common, mall-mbg, mall-security都是被调用的模块。 mall-portable调用了mall-mbg和mall-security. 权限控制角色管理 本项目的角色分为商品管理员，订单管理员，超级管理员，普通用户。 角色——资源和菜单的分配，资源指的是对接口的访问。 返回树形结构的数据，stream流可以很好解决嵌套问题。 目录权限，菜单权限，按钮权限 关于权限控制的内容写了一个总结，可以跳转，SpringSecurity-JWT 商品模块参考我们使用某宝的习惯，打开软件是首页推荐，可以分类分级选择商品分类，点击查看店铺详情，选择商品打开商品详情页，显示商品基本信息，促销信息，属性信息，关联推荐，已买用户评价。 该模块实现了部分上述功能，商品分类属性，商品库存，店铺管理。 可扩展的，还可以增加提问与回答模块，店铺自己的联想推荐，新增评价（评价管理），。 在自己写代码的过程中总结的写业务流程大概是，先了解业务相关的名词，然后理清逻辑设计数据库，写出伪代码/流程图，最后实践写代码。 参考这一流程浅析一下作者的实现。 这一模块中最复杂的service应该是PmsProductService，也是最核心的服务之一，每次下单的操作都是对商品的操作。如何计算商品优惠后的价格，下单后对库存进行操作在mall-portal中实现。 订单模块订单模块包括下单到选地址，计算优惠，到形成订单预览，选择支付方式，订单处理，售后服务。 OmsOrderService订单管理启用了Spring事务，在上一个模块中也有新建和删除操作采用了事务管理，批量发货，批量关闭订单，修改订单收货人信息，修改订单费用信息，修改订单备注这几个方法都加了@Transactional的注解，每个操作中注意更新订单操作历史。 OmsOrderSettingService可以设置订单超时时间。 已经实现的功能偏向于店铺管理人员操作，批量处理订单，处理退货申请，查看订单详情。 可选的，新增订单，提交退货申请，用户的商品浏览历史，从使用者的角度增加业务功能。 营销模块首页专题推荐，首页新/商品推荐，首页品牌推荐，首页广告。促销活动场次添加，商品添加。优惠券管理。 这里的推荐算法是简单的使用了数据库字段的推荐值排序。要涉及实际情况的推荐算法又是一个大坑了。 有时间写一个推荐算法调研。 可扩展的，秒杀模块，直播模块，消息模块。 以上几个模块都是在后台管理服务mall-admin模块下的，所以没有软件使用者角度的方法，接下来mall-portal模块，实现了客户端的请求处理。 收藏，关注，浏览历史，购物车管理，退货管理，前台订单管理，促销管理（计算购物车价格）。 收藏关注浏览历史都用MongoDB来存储。 MongoRepository 进阶篇-微服务项目Spring Cloud系列在我看来目前用不到，跟着作者的学习用例浅浅试用了一下，自己搭建的单体小项目用不到，接触不到公司项目就只能浅浅了解一下。 挖坑，分布式调研。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Security</tag>
        <tag>MybatisGenerator</tag>
        <tag>SwaggerUI</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fly bird]]></title>
    <url>%2Fflappy-bird.html</url>
    <content type="text"><![CDATA[搞点好玩的，这个简单的项目实现主要就是画面数值的精确计算。fly bird 绘制分析画面总的分为三部分，运行画面，开始画面和结束画面。设置状态转换，点击开始画面进入运行状态，点击结束画面回到开始状态（重新加载地图）。运行状态的设计是游戏核心。分析游戏的运行是通过鼠标点击来改变小鸟的运动，因此要对界面添加一个监听器，监听鼠标的变化。 地面类和柱子类都只需要计算好初始化位置和平移位置。 主要的逻辑在小鸟类实现。小鸟的飞行动作由加载的一系列图片循环加载完成。每一次点击都是完成一次抛物运动，因此涉及到了初速度，角度，重力加速度（伪）属性，以及时间属性。小鸟的位移只有垂直位移，移动的效果是通过地面和柱子的移动完成的。视觉上小鸟在做抛物线是由小鸟的旋转角度变化实现的。 1alpha = Math.atan(s / 8); 最后就是要判定游戏得分条件和结束条件。 Java Swing游戏用到了Java SWing，Swing是一个用于Java GUI的工具包。 JFrame – java的GUI程序的基本思路是以JFrame为基础，它是屏幕上window的对象，能够最大化、最小化、关闭。JPanel – Java图形用户界面(GUI)工具包swing中的面板容器类，包含在javax.swing 包中，可以进行嵌套，功能是对窗体中具有相同逻辑功能的组件进行组合，是一种轻量级容器，可以加入到JFrame窗体中。 在main程序中new JFrame()，添加了BirdGame()，其中BirdGame()继承自JPanel。 监听器 BufferedImage BufferedImage是Image的一个子类，主要作用是将一幅图片加载到内存中。 1BufferedImage image = ImageIO.read(new FileInputStream(imgPath)); 显示BufferedImage用Graphics: Graphics.drawImage() Graphics提供基本绘图和显示格式化文字的方法，Graphics2D提供了更强大的绘图能力。 repaint: 重绘此组件。如果组件是轻量组件，则此方法会尽快调用此组件的 paint 方法。否则此方法会尽快调用此组件的 update 方法。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Swing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2FMySQL.html</url>
    <content type="text"><![CDATA[MySQL的底层基础补一下。先占个坑。 执行步骤先检查是否有权限，如果没有权限直接返回，如果有权限就去查询缓存QueryCache（如果开了的话，现在已经关掉了），命中直接返回结果否则进行词法分析，语法分析，优化器进行优化（语义优化，语法优化，执行优化），然后执行，返回结果。 数据结构MySQL的存储采用了B+树的数据结构，建立的索引也是B+树。B+树是一种多路平衡树，最大搜索次数是树的深度。B+树支持全局搜索，相较二叉查找树更加矮胖，同样B树的非叶子节点存储数据信息，而B+树只存储键值，剩余的位置可以存储更多的键值，使得树更矮胖。因为叶子结点都在同一层，查询时间稳定。叶子结点由指针链接起来对范围查找非常有利。 索引要不要建立索引要多方考虑，索引的类型很多。ElasticSearch中采用了倒排索引，而MySQL中主键是聚簇索引，属于一级索引。 一级索引：B+树，叶子结点包含了行的全部数据（索引和数据存储），节点页只包含主键。 二级索引：二级索引可以有0个，1个或者多个。二级索引的结点只存被索引列的值，而二级索引的叶子结点存索引列值和主键值。 数据库容错 主从复制 QueryCache参考 避免相同SQL的硬解析（语法分析&gt;语义分析&gt;生成执行计划），SQL执行结果缓存在RESULT CACHE内存组件中，有效将的将物理IO转化为逻辑IO，提高SQL执行效率。但是更新数据库使缓存失效，因此频繁更新操作并不适合开启QC。理想的情况是相同的查询由相同或者多个客户机重复发出，被访问的底层数据本质上是静态或者半静态，并发性和QPS(Query Per Second)都不高，然而实际的业务系统都是有CRUD的，数据更新比较频繁，查询接口的QPS比较高。开启后对数据库并发度和处理能力都会降低很多。同时查询缓存碎片化还会导致服务器的负载升高，影响数据库的稳定性。 查询缓存分片数据块默认大小是4KB，如果有很多查询结果很小，那么默认数据块大小可能会导致内存碎片，由于内存不足，碎片可能会强制查询缓存从缓存中删除查询。在这种情况下，可以减小它的值，如果大量的查询有较大的结果集，可以增大该参数的值来提高性能。 这段的思想其实就是组原学过的内存管理，虽然QC已经退出MySQL，但在系统优化方法上还是可以学习的。 InnoDBBufferPool参考 MySQL不会直接修改磁盘的数据，会先改内存，然后记录redo log，等有空了再刷新磁盘，这些数据就存在Bufer Pool。就像我们平时开发会用redis来缓解数据库压力。基于LRU(least recently used)算法来管理内存。 这其实也是内存管理内容，缓存的思想无处不在。 Change Buffer只在操作二级索引时才用，因为聚簇索引必须是唯一的。要修改的页不在内存里，就把要对页的修改先寄到Change Bufer中，同时记录redo log，再慢慢把数据load到内存，然后把Change Buffer中的修改应用到内存（Buffer Pool)中，这个动作叫merge。 Adaptive Hash IndexMySQL索引在磁盘和内存都是B+树，频繁访问的数据用指针把数据位置记录下来。 Log Bufferredo log会刷到磁盘中。 Doublewrite Buffer用来保证数据页可靠性。 MySQL在刷数据到磁盘之前，要先把数据写到Doublewrite Buffer, 写完之后再开始写磁盘。万一发生crash可以利用它来修复磁盘数据。 PageCache是操作系统层面的，在磁盘上提供的缓存区。 面试专题参考1 2]]></content>
      <categories>
        <category>技术</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC和Druid]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93II.html</url>
    <content type="text"><![CDATA[算是数据库实战篇简单实现篇，包括了安装MySQL，使用JDBC和数据库连接池。 参考视频学习数据库软件的使用。 同时参考了博客，作者写的很全面。 可视化工具SQLyog下载 MySQL 安装 卸载，要删除注册表，删除C:/ProgramData下的MySQL文件。 配置 cmd==&gt;services.msc打开服务窗口 net stop mysql//以管理员身份打开cmd窗口 net start mysql 登录 mysql -uroot -pxxxx mysql -hip -uroot -pxxxx连接目标的密码（远程使用） mysql –host=ip –user=root –password=连接目标的密码 退出 exit quit 目录结构 安装目录 my.ini数据库配置信息 数据目录 常用查询语句 123456789show databases;show create database;create database if not exists db character set gbk;drop database if exists db;use db;select database();show tables;desc db;//表结构 问题汇总 在尝试Jdbc快速入门的时候遇到了class.forName(“com.mysql.jdbc.Driver”)加载失败，产生报错java.lang.ClassNotFoundException: com.mysql.jdbc.Driver，原因是同一个project建立了两个module时，第二个module并没有成功引入依赖jar包。解决方法，libs加入路径时搞错了。现在新版本不写class.forName()也可以通过，加了反而出错，原因不明。 Access denied for user &#39;&#39;@&#39;localhost&#39; (using password: YES)常见错误，查看数据库连接配置的用户名和密码是否正确 JDBC 使用步骤 下载导入;注册驱动;获取连接对象Connection;定义sql;获取执行对象;执行sql，返回结果;处理结果;释放资源 1234567891011121314151617//1. 加载数据库驱动Class.forName("com.mysql.jdbc.Driver");Class.forName("com.microsoft.jdbc.sqlserver.SQLServerDriver");//2. 建立连接URL用于标识数据库的位置Connection conn = DriverManager.getConnnection(url, user, pass);//通常存在配置文件中//3.执行数据库语句Statement st = conn.creatStatement();//向数据库发送连接的statement对象String sql = "select id, name from student;"int count = st.executeQuery(sql);if(count)&#123; System.out.println("成功创建");&#125;else&#123; System.out.println("创建失败");&#125;conn.close();st.close(); 12345678910111213141516UserService boolean register(User user); boolean active(String code); User login(User user);UserServlet register login active findOne exitUserDao User findByUsername(String username); void save(User user); User findByCode(String code); void updateStatus(User user); User findByUsernameAndPassword(String username, String password); 抽取JDBC工具类 分析 注册驱动抽取 Class.forName() 抽取方法连接对象 抽取方法释放资源 工具类静态方便调用 静态代码块：在加载如内存的时候就执行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class JDBCUtils &#123; private static String url; private static String username; private static String password; private static String driver; static&#123; try &#123; Properties prop = new Properties(); //获取src路径下文件的方式 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource("jdbc.properties"); String path = res.getPath(); prop.load(new FileReader(path)); url = prop.getProperty("url"); username = prop.getProperty("username"); password = prop.getProperty("password"); driver = prop.getProperty("driver"); Class.forName(driver);//加载驱动 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 * @return */ public static Connection getConnection() throws SQLException &#123; //字符串不能写死，采用配置文件解决 return DriverManager.getConnection(url, username, password); &#125; /** * 释放连接 * @return */ public static void close(Statement stmt, Connection conn, ResultSet rs)&#123; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; //不可以写一起，可能会漏掉，造成无法正常关闭 if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125;&#125; 数据库连接池存放数据库连接的容器，节约资源，用户访问高效。用户每次请求都需要向数据库获得链接，而数据库创建连接通常需要消耗相对较大的资源，创建时间也较长。假设网站一天10万访问量，数据库服务器就需要创建10万次连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、宕机。 获取DataSource, 然后调用ds.getConnection() C3P0 使用 导入jar包和依赖jar包 定义配置文件 c3p0.properties or c3p0-config.xml，放在src目录下 创建核心对象 ComboPooledDataSource 获取连接 12DataSource ds = new ComboPooledDataSource();//驱动程序提供厂商实现，可以通过它获取Connection对象Connection conn = ds.getConnection; Druid 使用 导入jar包 定义配置文件 可以是任意名称在任意目录下 加载配置文件 Properties 获取数据库连接：通过工厂来获取 DruidDataSourceFactory 获取连接 getConnection 定义工具类 提供静态代码块加载配置文件，初始化连接池对象 提供方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class druidUtils &#123; //定义一个DataSource private static DataSource ds; static &#123; try &#123; //加载配置文件 Properties prop = new Properties(); prop.load(druidUtils.class.getClassLoader().getResourceAsStream("druid.properties")); //获取DataSource ds = DruidDataSourceFactory.createDataSource(prop); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; /** * 释放资源 */ public static void close(Statement stmt, Connection conn, ResultSet rs)&#123; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; &#125; &#125; /** * 获取连接池 */ public static DataSource getDataSource()&#123; return ds; &#125;&#125; 配置文件druid.properties 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/db1username=rootpassword=rootinitialSize=5maxActive=10maxWait=3000 Spring JDBC Spring框架提供的对JDBC的简单封装 步骤： 导入jar包 创建JdbcTemplate对象，依赖于DataSource 调用JdbcTemplate方法完成crud]]></content>
      <categories>
        <category>技术</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>JDBC</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93.html</url>
    <content type="text"><![CDATA[数据库的基础学习笔记，跟着哈工大的老师视频学习。从关系代数到SQL语言，以及一些进阶数据库操作的简单学习。 关系模型 关系运算 关系代数 基于集合的运算 基于关系代数的数据库语言 关系演算 元组演算 基于逻辑的运算 域演算 基于示例的运算 关系列的取值范围就是域，域有相同的数据类型 笛卡儿积（每一个元素成为n-元组）：多个域的排列组合 笛卡儿积中具有某个意义的元组称为关系 域名和属性名不一样，为每一列起的名字叫属性名，不同列可能来自同一个域。 外码连接两个或者多个关系。 关系代数是一种抽象的语言 前提：满足并相容性，才能进行运算 基本操作： 并，差，笛卡儿积，选择（选择行操作），投影（选择列进行操作） 扩展操作 交，theta-Join（直接使用连接操作比笛卡儿积加一个选择操作快，DBMS可以进行直接操作），等值连接，特殊连接，自然连接 关系代数操作的组合和应用训练 要特别注意语义 关系代数的复杂扩展操作 除运算（包含了全部的，所有的） 外链接：左外连接（不丢失左侧元组数据），右外连接，全外连接 集合操作的特性 关系代数与sql语言的对应关系 Select From Where sql查询语句就是关于代数的组合 数据库管理系统就是解析这样的组合，拆解开，按照一定的次序分解开，调用基本的操作算法来予以实现。 关系演算元组演算（有难度的位置）：一种逻辑表达，以元祖为基本单位循环遍历。与关系代数可以相互转换。 存在量词 对r中的每一个t进行F(t)检验 全称量词 关系域演算：过程性非常差，适合用户使用来表达查询条件 QBE域演算语言 通过填表的方式，高度非过程化的查询语言。 安全性 关系运算不一定是安全的。不产生无穷关系和无穷验证的运算被称为是安全的。 关系运算总结关系运算有三种：关系代数，关系元组演算，关系域演算，都是抽象的数学关系，体现了三种不同的思维。关系代数是基于集合的操作思维，后两者是基于逻辑的思维。关系代数是安全的。三种关系运算都可以说是非过程性的。 ISBL语言：基于关系代数的数据库语言。 QUEL语言 数据库语言SQL DDL 定义数据库 DML操纵数据库 Structured Query Language(SQL) 建立数据库：定义数据库和表，添加元组。 Create datebase xxx Create table Students(Snumber char(8) not null, Sname char(10), Ssex char(2)); 利用数据库进行简单的查询 Select ... From ... Where... 结果唯一性问题 DISTINCT 结果排序问题order by 列名 【asc/desc】 模糊查询 Select Sname From Student Where Sname Like &#39;张__&#39;; % ： 零个或者多个字符 _ ： 单个字符 \： 转义字符 多表联合查询 表示笛卡儿积操作。 Select S1.Snumber From SC S1, SC S2 Where S1.Snumber = S2.Snumber and ... SQL的更新操作 增 INSERT Insert Into Teacher Values (&quot;005&quot;,&quot;张三&quot;); Insert Into St(S#, Sname) Select S#, Sname From Student Order By Sname;批元组新增 删 DELETE Delete From Student Where S# =&#39;100&#39;; Update Teacher Set Salary = Salary * 1.05 Where D# in (...) 修正与撤销 Alter Table Student Add Saddr char[40],PID char[18]; Alter Table Student Modify Sname char(10); Alter Table Student Drop Unique(Sname); Drop Table Student;撤销学生表Student；delete语句知识删除表中的元组，而drop table 的操作撤销包含表格式，表中所有元组，由该白哦导出的视图等所有相关内容。 指定与关闭命令 Use Student Close Student DBMS交换环境简介 利用SQL语言表达复杂查询 子查询 IN 和 NOT IN 列出选修了001号课程的学生的学号和姓名 Select S#, Sname From Student Where S# in (Select S# From SC Where C# = &#39;001&#39;); 既学过001号课程又学过002号课程的学生的学号 Select S# From SC Where C# = &#39;001&#39; and S# in(Select S# From SC Where C# = &#39;002&#39;); 非相关子查询和相关子查询 theta some / theta all类似于全称量词和存在量词 找出工资最低的教师姓名 Select Tname From Teacher Where Salary &lt;= all(Select Salary From Teacher); 找出001号课程成绩不是最高的所有学生的学号 Select S# From SC Where C# = &#39;001&#39; and Score &lt; some(Select Score From SC Where C# = &#39;001&#39;); 等价性变换需要注意 some 等价于in not in 等价于 &lt;&gt;all EXIST not Exists可以实现很多新功能 检索学过001号教师主讲的所有课程的所有同学的姓名 Select Sname From Student Where not exists (Select * From Course Where Course.T#=&#39;001&#39; and not exists(Select * From SC Where S# = Student.S# and C# = Course.C#)); 不存在/ 有一门001号老师讲的课程/ 该同学没学过 列出没学过李明老师讲授的任何一门课程的所有同学的姓名 Select Sname From Student Where not exists(Select * From SC, Course, Teacher Where Tname = &#39;liming&#39; and Course .T# = Teacher.T# and Course.C# = SC.C# and Student.S# = SC.S#) 不存在/ 学过一门课程 从肯定过度到否定之否定 列出至少学过9803号同学学过的所有课程的同学的学号 Select DISTINC S# From SC SC1 Where not exists (Select * From SC SC2 Where S# = &#39;9803&#39; and not exists (Select * From SC Where C# = SC2.C# and S# = SC1.S#)) 不存在// 9803的some一门课程 //该同学 没学过 利用SQL语言进行计算 聚集函数 count sum avg max min 求有差额的任意两位教师的薪水差额 1234567Select T1.Tname as TR1, T2.Tname as TR2,T1.Salary-T2.Salary From Teacher T1, Teacher T2 Where T1.Salary &gt;T2.Salary;Select S.S#, S.Sname, 2015-S.Sage+1 as Syear From Student S;Select Sum(Salary) From Teacher;Select AVG(Score) From Course C, SC Where C.Cname='数据库' and C.C# = SC.C#; 分组聚集计算与分组过滤计算 12345678#求每一个学生的平均成绩Select S#, AVG(Score) From SC Group by S#;#求每一门的平均成绩Select C#, AVG(Score) From SC Group by C#;#求不及格课程超过两门的同学的学号Select S# From SC Where Score&lt;60 Group by S# Having Count(*)&gt;2;#求有两门以上不及格课程同学的学号及其平均成绩Select S#,AVG(Score) From SC Where S# in(Select S# From SC Where Score&lt;60 Group by S# Having Count(*)&gt;2) Group by S#; 实现并交差 UNION/ /INTERSECT/ /EXCEPT 123Select S# From SC Where C#='002'INTERSECTSelect S# From SC Where C# = '003'; 空值 Select Sname From Student Where Sage is null; 内连接，外连接 求所有教师的任课情况并按教师号排序 Select Teacher.T#, Tname ,Cname From Teacher Inner Join Course On Teacher.T#=Course.T# Order by Teacher.T# ASC; SQL视图 数据库完整性完整性约束条件（OPAR） O： 约束的对象 P：谓词条件，什么样的约束 A：触发条件 R：响应动作，不满足时怎么办 约束分类 静态约束，通过Create语句来完成， 在任一时候均满足的约束 域完整性约束：施加在某一列 举例 1Create Table Student(S# char(8) not null unique, Sname char(10), Ssex char(2) constraint ctssex check(Ssex='男' or Ssex ='女')， Sage integer check(Sage&gt;=1 and Sage&lt;150),D# char(2) references Dept(D#) on delete cascade, Sclass char(6)); check()加约束条件，同where的使用 on delete cascade，外键，删除关联（查询） 1Create Table SC(S# char(8) check(S# in (select S# from Student)), C# char(3) check(C# in (select C# from course)), Score float(1) constraint ctscore check (Score &gt;= 0.0 and Score &lt;= 100.0) 关系完整性约束：施加在关系/表上 断言，会影响数据库的效率增加数据库的负担，慎用 Create assertion xxx check (条件) 动态约束 ：从一状态到另一状态时应满足的约束 触发器， Trigger 12345create trigger delS# after delete on Student referencing old oldifor each row begin delete sc where S# = :oldi.S# end; 数据库安全性SOTP 自主安全性的实现方式 存储矩阵 视图 SQL语言授权和收回授权 Grant Select On Employee To UserB WITH GRANT OPTION 授权过程，注意授权的传播范围（深度，广度）。 强制安全性 嵌入式SQL高级语言与SQL语言结合 变量声明与数据库连接 exec sql connect to default; exec sql disconnect current; exec sql commit release;(Oracle) exec sql rollback release;(Oracle) 事务：具有ACID特性的若干数据库基本操作的组合体 ACID：原子性，一致性，隔离性，持久性 事物处理是DBMS的核心技术 declare section; SQL错误捕获语句；SQL connect；SQL commit work；SQL rollback and disconnect; 数据集和游标 检索多行结果用到游标，游标定义一次，多次打开，多次执行，多次关闭。 123456789101112exec sql declare cur_student cursor for select Sno, Sname from Student where Scalss = :vclass order by Sno for read only;exec sql open cur_student;...exec sql fetch cur_student into :vSno, :vSname;...exec sql close cur_student;#开关游标 exec sql open cursor_name;exec sql close cursor_name; 可滚动游标：可使指针在数据集之间灵活移动。 数据库的更新与删除：分两种，查找更新与定位更新；查找删除和定位删除 1234567exec sql declare stud cursor for select* from student s where s.sclass='000' for update of sclass; exec sql open stud While(TRUE)&#123; exec sql fetch stud into :vSno, :vSname; exec sql update student set sclass='002' where current of stud; &#125; 异常状态捕获及错误处理机制 状态是嵌入式SQL语句的执行状态，尤其指一些出错状态。状态捕获和处理包括三部分： 设置sql通信区：exec sql include sqlca; 设置状态捕获语句： exec sql whenever sqlerror goto report_error; 状态处理语句：report_error:exec sql rollback; 状态捕获语句可能出现无限循环 handle_error: exec sql whenever sqlerror continue; 错误捕获语句的作用域 动态SQL 静态SQL：冒号传递，游标读取。 动态SQL，构造sql的字符串，然后交给DBMS执行。 动态sql语句的执行方式 立即执行（text语句一定是完整的） 延迟执行 数据字典与SQLDA：系统目录，类似于查找索引的东西 ODBC是一种标准，open database connection 索引索引文件：索引字段和行指针 创建一个索引： create index idxName on student(sname) 撤销索引：drop index idxName 是否建立：考虑插入时间删除时间访问时间与空间负载的问题。既要改善性能又要控制代价。 稠密索引和稀疏索引 稀疏索引（要求排序存储），稠密索引（候选键属性和非候选键属性） 主索引和辅助索引 主索引通常是聚簇索引（以磁盘块为索引项。 倒排索引 以关键词指向的文档， key {doc1, doc2, doc3…} 多级索引：B+树 查询优化在连接和乘积运算之前尽早做选择运算 语义优化 语法优化：逻辑查询优化（关系代数操作次序），10个等价性交换定理。 执行优化：物理执行优化–代价估算（准确性有待商量）–算法选择和装配次序 在DML编译器执行 事务处理并发控制 因为数据共享会有不一致发生 三种典型的不一致现象：丢失修改，不能重复读，脏读 类似于操作系统进程控制 事务： 数据库管理系统提供的控制数据操作的一种手段， ACID 封锁协议要考虑：封锁的类型，封锁的粒度（基本在元组），相容性矩阵（一个事务上锁后其他事务的权限），封锁的时机（分为四个） 故障：故障恢复包括原子性和持久性 故障恢复程序占百分之十。是核心技术。 事务故障： 重做事务Redo和撤销事务Undo 系统故障：掉电，非正常关机。会影响到数据库缓存区。通过运行日志的手段。运行日志定期设置和更新检查点（为了判断从哪一点开始恢复）。 介质故障：磁盘坏了，用副本。确定备份时刻，转储点，运行日志至少要包括在转储点之前。]]></content>
      <categories>
        <category>技术</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java爬虫]]></title>
    <url>%2F%E7%88%AC%E8%99%AB%E7%BB%83%E6%89%8B.html</url>
    <content type="text"><![CDATA[爬虫练手 该项目是牛客网的项目，基于webmagic开源项目制作一个高效爬虫。项目采用了springboot框架。 webmagic使用相关博客 官方中文文档 最需要关心的是PageProcessor接口。 自定义的Processor继承PageProcessor接口，重写process(Page page)方法编写抽取逻辑。调用page.putField()将结果存起来。调用page.addTargetRequest()可以存入一个url作为下一个爬取的页面地址。 如果是单纯的爬取到现在就可以实现了，官方给出的代码做了很多的解耦和扩展。还用到了被我遗忘很久的设计模式。 策咯模式是把process()中处理也页面的方法抽取出来，用继承接口ProcessStrategy()的方式进行，使得代码解耦合。 面向接口编程而不要面向实现编程。 并且对process方法做了增强，前后都留了处理方法。这就是程序扩展性。 如果需要处理的数据超过两条，那么将他们封装成一个model吧！ 装饰模式在单页爬取的基础上实现多页迭代爬取。 对ProcessStrategy()进行虚假的实现，通过重载构造方法的方式将单页面处理方法组合进去。再创建一个子类继承这个虚假装饰类，做真正的实现。 插播：组合和聚合的区别 组合是较为紧密的关系，部分和整体共存亡，一般通过构造的方式成为整体的一部分。 聚合式较为松散的关系，部分和整体的生命周期未必一致。部分的实例化过程在整体外进行，通常以属性的方式成为整体的一部分。这是我的理解。 观察者模式Pipeline会在一个爬取任务完成后被调用，比如存入数据库，或者打印到控制台。 当Pipeline准备好结果时主动去推送结果。 Observer可以是多个观察者（项目），Observable处理观察者的添加删除通知，自定义的pipeline继承Observable通知观察者（实现接口Observer，又是多态）。 Jsoup和XPath基本思路就是寻找有唯一表示的div，根据class一层层定位（最好直接根据id定位，因为id是唯一的），最后找到想要的元素和属性。 Jsoup是用于解析HTML XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。 爬取数据的注意点： 听说很费IP (doge.jpg)，还容易犯错，爬虫被封IP最直接的因素的是访问速度过快。谨慎爬取。建议使用代理ip。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>项目</category>
        <category>WebMagic</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>WebMagic</tag>
        <tag>Xpath</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021总结]]></title>
    <url>%2F2021%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[2021的最后一天了，年度总结来啦！ 跨年是在实验室和宿舍度过的，但是是在摸鱼啦。 今年还算是努力学习的一年，虽然也时而摸鱼丧气，但还是一步步进步了很多。上半年在写论文，虽然发不发还是问题，但是学会了用latex，学会了用endnote整理文献，下半年再学框架和做项目，学习了数据库基础，SSM框架，SpringBoot框架，尝试了运行开源项目，从黑马旅游网的简单制作到mall的开源项目，研究了老师给的车联网项目，也在此基础上做自己的项目。最近在学习linux。心血来潮也会刷刷leetcode，虽然通常坚持不了几天。刷题其实还是挺费时间的。大热门的深度学习也想涉及一点，总之就是东一脚西一脚，深深浅浅摸石头过河。 跨专业真的是很痛苦的一件事，虽然做好了补基础的准备，但把位置摆在一群科班堆里的时候，还是感受到了不小的差距，仿佛在经历科班的本科生活。又说到丧气的事了，以此为理由而接受差距放任自己是绝对不可能的，新一年也要加油要努力。现在已经很少提自己以前的专业了，还是希望把现在的位置摆在CSer，一个菜鸟CSer努力进化的路。 研究生生活更多的是在自学，老师给的只是课题和资源，因为专业领域的问题，导师实际上能帮助的很少，时常在困惑自己的毕业和就业问题。焦虑并不能解决问题，所以不如学习技术，充实自己。 新年期待的话希望能找到好的实习，好的就业，继续好好写博客，好好生活。 未来的路还很长，拭目以待。]]></content>
      <categories>
        <category>生活</category>
        <category>岁岁念</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[car2car项目运行实录]]></title>
    <url>%2Fcar2car%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E5%AE%9E%E5%BD%95.html</url>
    <content type="text"><![CDATA[在尝试做项目，说是课题也不像课题，老师给的权限很宽，那就按我的想法来尝试，记录一下尝试的过程和途中遇到的bug… 陈年旧项目简介本来是打算在原项目的基础上做的，所以最开始选择了导入jar包然后添加到项目中。jar包的下载就是度娘。然后导入项目。 本项目用到了以下几个额外的jar包 POI： 读取excel数据 net.sf.json.JSONObject：转换beans，maps，collections, java arrays, xml等为JSON对象和反转换的java库 Gson是Google提供的用来在Java对象和JSON数据之间映射的JAVA类库 commons.fileupload.jar为web应用程序或者servlet提供文件上传功能。 IDEA项目导入jar包的方法有两个 File –&gt; Project Structure-&gt;Modules-&gt;Dependencies，点绿色的加号导入 需要导入的Jar包上，点击右键，选择Add as Library… amap的使用方法 sessionStorage对象 修改为maven项目但是导jar包配置各种东西真的太麻烦了，于是决定用maven管理老项目，pom.xml配置真香。 打包成maven项目](https://blog.csdn.net/weixin_30348133/article/details/114560553) .classpath 文件：指定了源文件位置，con容器为JRE，编译输出位置。指定了java项目在逻辑结构与文件系统的物理结构之间的对应关系。 右键选择 JavaDemo（项目名称），选择“Configure –&gt; Convert to Maven Project”， 填写“Group ID”和“Artifact Id”都为“JavaDemo” 完成pom.xml的修改—复制了一部分itheima的项目配置 参照标准的目录结构修修补补总算是弄好了 部署在tomcat上 报错：org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Tomcat]....搜索了好几个回答，发现相似点是jar包问题，就试着删除web目录下的lib目录，证实报错原因是jar包的重复，问题解决。 原来的项目编码是gbk的，编译出错。为了方便改为UTF-8，可以使用批量处理脚本，完美解决 报错2：Skipping non-war project tomcat没有启动，无tomcat日志信息，解决方法： 1234&lt;groupId&gt;com.itheima&lt;/groupId&gt;&lt;artifactId&gt;maven_web&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt; &lt;!--加这一句--&gt; 到这里为止，终于部署到tomcat成功，但是页面乱码了，不要紧，肯定是编码问题。 报错3：Servlet不能正常访问，论版本兼容的重要性。tomcat各版本的兼容，其实是在运行其他项目时遇到的问题，一并归纳。 数据库设计 编码问题解决好了，那就进入数据库的连接。原本的数据库与前端页面的交互代码写得比较繁杂，这里可以优化为采用数据库连接池和Spring框架提供的JDBCTemplate来进行优化。 数据库的设计方面，数值范围是一个讨论问题。 报错：运行tomcat时无法连接到数据库，本地测试和连接其他的项目都可以，唯独这个项目不可以。尝试了给数据库更高的权限，尝试了改密码，都没有解决。啊卡了好久，解决无果。 本地测试了jdbc工具类和连接池工具类都没有问题。 优化注解注入，简化web.xml的配置 目前的计划： 了解已知代码的逻辑实现和已有的功能。 文献查询，聚类分析的基本方式和基于LoRa的应用 取合适的模型进行坐标点的分类 修改项目框架为Springboot更新为主流的应用框架。参考了开源项目-mall 数据库连接 一边学一边做，首先使用之前新建的数据库，采用新学Mybatis框架 编写实体类 domain.User/domain.Data 编写dao接口 UserMapper/DataMapper 测试 导入静态资源和页面​ 静态资源放在static.asserts下面，页面放置在templates下 无法加载样式—莫名其妙又可以加载了 代替jsp使用Thymeleaf ,不是前后端分离的。 前后端分离都提到了解决跨域问题，所以什么是跨域问题？nginx是什么？如何使用redis？参考1 用json和ajax实现前后端分离—-原项目就是采用了前后端分离的做法，所以正好保留 原项目实现登录功能(伪)： 使用SpringMVC的话就直接砍掉了servlet，使用Contoller替换掉servlet，SpringMVC嵌入了自动的json转换，只需要加一个@ResponseBody 反正折腾了半天是可以实现登录成功了，但是跳转了wmap.html页面。 添加了lombokLombok表达式—面向函数编程 参考1 2 MybatisGenerator使用Mybatis Generator可以快速根据数据库中已经建立好的表来创建mybatis代码 发生错误，The specified target project directory mall-tiny-01\src\main\resources does not exist 路径不对，参考博客解决，查看edit configuration拼接路径 生成的文件到了另一模块上，果然还是路径错了 未报错但是没有产生文件，参考博客修改路径中的\为/，成功生成文件 报错 Column id, specified as an identity column in does not exist in the table. 参考博客解决，在生成器的配置文件里的数据库连接地址中添加: nullCatalogMeansCurrent=true 路径追加问题 参考博客 参考博客1–详细介绍了generator 参考2步骤详细。 使用@MapperScan注解扫描多个包，参考 启动项目异常，Result Maps collection already contains value for，原因是Mybatis gennerator生成xml，但是如果同名xml之前已经存在，那么生成的时候会在xml里面在之前的代码后面继续追加，而不会覆盖同名的语句。因此有可能报这个错误。如果是再次生成代码，必须先将已经生成的代码删除，仔细检查一下xml文件看是否存在两个id为BaseResultMap的resultMap，删除多余的，只保留一个就可以解决问题。参考博客 Swagger-UI 使用步骤 添加项目依赖 添加Swagger2Config配置类 给Controller加注解 启动项目，线上观看结果 http://localhost:8080/swagger-ui.html。 报错： Plugin &#39;org.springframework.boot:spring-boot-maven-plugin:&#39; not found 解释最清楚的博客，解决方法是添加版本号 spring-boot-maven-plugin没有设置version，它会先去远程仓库找最新的版本，然后download到本地，然后完成maven操作等。但是远程仓库里没有相应的jar包，导致执行maven编译出错。因为远程仓库里已经有了最新版本的路径，它就不会使用已经存在的版本。 CommentGenerator自定义注释生成中，org.mybatis.generator.api.dom.java.CompilationUnit;中方法解析失败，Cannot resolve method &#39;isJavaInterface&#39; in &#39;CompilationUnit&#39; 果真是版本问题，Mybatis generator的版本由1.4.0改为1.3.7就好了。本菜鸡一个个试出来的，不知道有没有更好的方法。 项目启动出错，Failed to start bean &#39;documentationPluginsBootstrapper&#39;; nested exception is java.lang.NullPointerException 据说是版本号的冲突，心累，未解决，把Swagger-UI和MybatisGenerator都删了，然后回到开始实现登录功能哈哈哈哈我又回来了，Springboot版本号改成了2.1.3.RELEASE，原来用的2.6.1，感谢博主的提供的思路。 逆向工程 The server time zone value &#39;???ú±ê×??±??&#39; is unrecognized or represents more than one time zone. 数据库和系统时区差异所造成的，解决方法加serverTimezone=GMT%2B8，参考博客 总之成功了^w^ 修改Mybatis Generator注释生成规则—-待解决 CommentGenerator为MyBatis Generator的自定义注释生成器，修改addFieldComment方法使其生成Swagger的@ApiModelProperty注解来取代原来的方法注释，添加addJavaFileComment方法，使其能在import中导入@ApiModelProperty，否则需要手动导入该类，在需要生成大量实体类时，是一件非常麻烦的事。 Spring Security登录认证学习了新项目有了新的想法，使用SpringSecurity实现登录功能。 实现登录功能有的几个方式：参考1，参考2 Springboot使用pagehelper pagehelper的使用方法有两种，集成成功。 错误：SpringBoot单元测试使用@Test没有run方法的问题 参考 因为改成了2.1.7.RELEASE，版本不同，项目的结构也不同。测试方法的public没了。然后改回了2.6.0.版本，但是仍然有问题。pagehelper循环依赖的问题。项目启动不了，我版本又改回了2.5.6，会标红但是可以运行。 引发了新问题，需要登陆才能查看swagger文档，但是登录密码错误，待解决，好像知道原因了，是因为添加了security和token，虽然还没有集成完全。 分析继续完成security—-需要更改数据库 因为需要自定义 UserDetailsService:SpringSecurity定义的核心接口，用于根据用户名获取用户信息，需要自行实现； UserDetails：SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限），需要自行实现； 设计数据库—用MybatisGenerator生成model和mapper—完成service—controller Hibernate-validator校验框架（待添加） 使用教程 实现 错误：Could not resolve placeholder &#39;jwt.secret&#39; in value &quot;${jwt.secret}&quot; 忘记配置了 获取权限列表，因为我的项目是简化版本的权限只需要，mall项目是四表联查找到权限封装为Permission对象，Security究竟是如何读取权限的呢 123456789public final class SimpleGrantedAuthority implements GrantedAuthority &#123; private static final long serialVersionUID = 510L; private final String role; public SimpleGrantedAuthority(String role) &#123; Assert.hasText(role, "A granted authority textual representation is required"); this.role = role; &#125;&#125; 使用Swagger测试接口时一直没反应，后来发现是Swagger配置类没有增加登录认证功能 错误：Encoded password does not look like BCrypt 密码的加密方式不对，找到原因了，数据库取出的代码是未加密的，而mall的项目中数据库存的密码是加过密的，偷个懒先把他的密码拷贝过来试试。 茅塞顿开，救命我会用debug了，找寻一个项目的运行逻辑可以打断点一步步运行。（迟来的领悟，其实之前看视频看到过） 错误：java.lang.String is in module java.base of loader &#39;bootstrap&#39;; com.tsuki.cartocar.mbg.model.UserInfo is in unnamed module of loader &#39;app&#39;类型转换错误 123456//AdminUserDetails，仍旧是权限定义错误@Overridepublic Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; //返回当前用户的权限 return null;&#125; 参考了博客 List&lt;? extends Number&gt; 定义了泛型的上界是 Number, 即 List 中包含的元素类型是 Number 及其子类. 而 List&lt;? super Number&gt; 定义了泛型的下界, 即 List 中包含的是 Number 及其父类. permissionlist.stream() Stream API的聚合使用 获取权限的修改主要在三个文件，UserServiceImpl.java &amp; SecurityConfig.java &amp; AdminUserDetails.java &amp; UserController.java 123456789101112131415161718192021222324252627282930313233343536373839//UserController @ApiOperation("获取用户所有权限（包括+-权限）") @RequestMapping(value = "/permission/&#123;userId&#125;", method = RequestMethod.GET) @ResponseBody public CommonResult&lt;List&lt;UserInfo&gt;&gt; getPermissionList(@PathVariable String userId) &#123; UserInfo userInfo = userInfoMapper.selectByPrimaryKey(userId); List&lt;UserInfo&gt; permissionList = userService.getPermissionList(userInfo); return CommonResult.success(permissionList); &#125;//UserServiceImpl @Override public List&lt;UserInfo&gt; getPermissionList(UserInfo userInfo) &#123; List&lt;UserInfo&gt; permission = new ArrayList(); //String roleId = userInfo.getRoleId(); permission.add(userInfo); return permission; &#125;//SecurityConfig @Bean public UserDetailsService userDetailsService() &#123; //获取登录用户信息 return username -&gt; &#123; UserInfo userInfo = userService.getUserByUsername(username); if (userInfo != null) &#123; List&lt;UserInfo&gt; permissionList = userService.getPermissionList(userInfo); return new AdminUserDetails(userInfo,permissionList); &#125; throw new UsernameNotFoundException("用户名或密码错误"); &#125;; &#125;//AdminUserDetails @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; //返回当前用户的权限 return permissionList.stream() .filter(permission -&gt; permission.getRoleId()!=null) .map(permission -&gt;new SimpleGrantedAuthority(userInfo.getRoleId())) .collect(Collectors.toList()); &#125; 错误：org.springframework.web.bind.MissingPathVariableException: Required URI template variable &#39;userId&#39; for method parameter type String is not present 主要是自己对注解的理解不清楚导致的，@PathVariable请求路径名称写错了。 自定义UserDetails实现用户登录访问 – 从数据库读取数据实现用户登录访问 错误：java.sql.SQLException: Field &#39;id&#39; doesn&#39;t have a default value 是因为MybatisGenerator生成的Mapper.xml中插入默认主键是自增的从而不插入主键，而我的不是。暂时的解决方式是修改主键为自增，参考博客也并没有解决。主键自增要求键值为int类型。都要改。。所以修改mapper中的insert方法，添加插入主键，成功！ 123456789&lt;insert id="insert" parameterType="com.tsuki.cartocar.mbg.model.UserInfo"&gt; &lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.String"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; insert into user_info (id, username, password, role_id, devID) values (#&#123;id, jdbcType=VARCHAR&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;roleId,jdbcType=VARCHAR&#125;, #&#123;devid,jdbcType=VARCHAR&#125;)&lt;/insert&gt; 到目前为止，用户的登录注册就完成了！大功告成！]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>项目</category>
        <category>cart</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis]]></title>
    <url>%2FMyBatis.html</url>
    <content type="text"><![CDATA[系列三来了…这次是Mybatis 写此系列的目的是做一个学习笔记管理，方便以后复习用。 快速入门 添加坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.26&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; 创建数据表 编写实体类 编写dao接口 mapper 编写映射文件UserMapper dtd的约束头参考 编写核心配置文件SqlMapConfig.xml 编写测试类 增删改查 1234sqlSession.selectList("userMapper.findAll");sqlSession.insert("userMapper.add", user);sqlSession.update("userMapper.update", user);sqlSession.delete("userMapper.delete", 3); 核心配置文件 SqlMapConfig.xml emvironments—数据库环境的配置，指定事务管理类型和数据源 transactionManager: JDBC, MANAGED dataSource: POOLED , JNDI, UNPOOLED mappers—加载映射文件 userMapper.xml properties—加载外部properties文件 typeAliases—定义别名 typeHandlers—配置自定义类型处理器 处理日期转换为例 定义转换类继承类BaseTypeHandler&lt;&gt; 覆盖4个未实现的方法 在核心配置文件SqlMapConfig.xml中进行配置 测试 12345678910111213141516171819public class DateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; @Override //将java类型转换为数据库需要的类型 public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType jdbcType) throws SQLException &#123; long time = date.getTime(); preparedStatement.setLong(i, time); &#125; @Override //以下三个将数据库类型转换为java类型 //String是要转换的字段名称 //resultSet查询出的结果集 public Date getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; long aLong = resultSet.getLong(s); Date date = new Date(aLong); return date; &#125; ...&#125; 1234&lt;!--自定义注册类型处理器--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler="com.tsuki.handler.DateTypeHandler"/&gt;&lt;/typeHandlers&gt; plugins 扩展功能 – PageHelper，第三方插件进行功能扩展 步骤 导入通用的PageHelper坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;4.2&lt;/version&gt;&lt;/dependency&gt; 在核心配置文件中配置PageHelper插件 123456&lt;!--配置分页助手插件--&gt;&lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageHelper"&gt; &lt;property name="dialect" value="mysql"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 测试 PageHelper.startPage(1, 2); 相应api(单元测试用) SqlSessionFactoryBuilder SqlSessionFactory: openSession() or openSession(boolean autoCommit) 可以设置自动提交事务 SqlSession，增删改查 Dao层实现 传统方式 代理开发方式 区别就是需不需要手动实现接口 sqlSession.getMapper(UserMapper.class); 要保持四个一致：映射文件中的mapper的namespace要是interface的全包名，id和方法名一致，parameterType和形参类型一致，resultType和返回值类型一致。 映射配置文件深入1. 常用标签&lt;select&gt; &lt;insert&gt; &lt;update&gt; &lt;delete&gt; 1234567891011&lt;mapper namespace="com.tsuki.dao.UserMapper"&gt; &lt;select id="findAll" resultType="user"&gt; select * from user &lt;/select&gt; &lt;insert id="save" parameterType="user"&gt; insert into user values(#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;birthday&#125;) &lt;/insert&gt; &lt;select id="findById" resultType="user"&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 2. 动态sql占内存 &lt;if&gt; &lt;foreach&gt;&lt;sql&gt;&lt;where&gt; 多表操作注解常用注解：用注解替代映射文件 简单查询—-注解加载接口方法上 @Insert @Delete @Update @Select 1234&lt;!--加载映射关系--&gt;&lt;Mappers&gt; &lt;package name="com.tsuki.mapper"/&gt;&lt;/Mappers&gt; 复杂查询 @Result @Results @One(一对一) @Many(一对多，多对多) 套娃 报错 java.lang.ClassCastException: com.github.pagehelper.PageHelper cannot be cast to org.apache.ibatis. 探究plugins分页插件时的问题，多半是版本问题—-论springboot的好处，内置版本号 is not known to the MapperRegistry, 原因是namespace没有修改为全包名 用Mybatis插入数据但是没反应，用错了标签，’‘用成了’‘]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>框架笔记</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记]]></title>
    <url>%2FSpringMVC.html</url>
    <content type="text"><![CDATA[系列二来了…这次是SpringMVC 写此系列的目的是做一个学习笔记管理，方便以后复习用。 Spring集成web环境原理： 添加坐标 servlet和jsp 添加web层servlet，在web.xml配置servlet web通过spring容器获取Service对象—–在web项目中通过ServletContextListener监听Web应用的活动，在web应用启动时，加载spring配置文件，创建上下文对象ApplicationContext，将其存储到最大的与servletContext域中，这样就可以在任意位置从域中获取ApplicationContext对象了。（web.xml配置监听器） 步骤 配置ContextLoaderListener监听器 123456789 &lt;!--全局化初始参数--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--配置监听器--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 使用WebapplicationcontextUtils获取应用上下文 1234ServletContext servletContext = this.getServletContext();ApplicationContext app = (ApplicationContext) WebApplicationContextUtils.getWebApplicationContext(servletContext);UserService userService = app.getBean(UserService.class);userService.save(); 快速入门 导入坐标 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;!--&lt;scope&gt;provided&lt;/scope&gt;疑问导入spring-web包时加了范围会出错--&gt;&lt;/dependency&gt; 配置核心控制器DispatcherServlet web.xml 123456789101112131415&lt;!--配置springmvc的前端控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载servlet时加载配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 创建Controller类和视图页面，注入Spring容器 12345678@Controllerpublic class UserController &#123; @RequestMapping("/quick")//访问路径 public String save()&#123; System.out.println("controller running"); return "success.jsp"; &#125;&#125; 使用注解配置Controller类中业务方法的映射地址 配置SpringMVC核心文件spring-mvc.xml 配置扫描组件，和context空间 1234567&lt;!--Controller组件扫描-需要加载context空间--&gt;&lt;context:component-scan base-package="com.tsuki.controller"/&gt;&lt;!--配置组件扫描,小tip，可以设置扫或者不扫--&gt;&lt;context:component-scan base-package="com.tsuki"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;&lt;/context:component-scan&gt; 客户端发起请求测试 访问路径”/quick” 相关组件DispathcherServlet; HandlerMapping; HandlerAdapter; Handler; View Resolver; View; 注解解析 @RequestMapping: URL与处理请求的方法之间建立联系 ​ 参数： value,method(RequestMethod.POST), params 视图解析器配置： 有默认配置—-可以指定功能进行增强–配置内部资源视图解析器 redirect和forward 12345&lt;!--配置内部资源视图解析器，但是这样做不好阅读啊（小疑问），而且做了代码内部修改--&gt;&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt; SpringMVC的请求和响应数据响应的方式1. 页面跳转 返回字符串–参见快速入门， prefix + String + suffix 代表页面跳转 返回ModelAndView save()参数还可以是HttpServletRequest等官方的定义，但是不建议使用，model和view可以拆开使用也可以一起使用，可以new也可以作为形参传入。 1234567891011121314151617181920212223242526@RequestMapping("/quick4") public String save4(Model model)&#123; model.addAttribute("username", "lisi"); return "success.jsp"; &#125; @RequestMapping("/quick3") public ModelAndView save3(ModelAndView modelAndView)&#123; modelAndView.setViewName("success.jsp"); modelAndView.addObject("username", "zhangsan"); return modelAndView; &#125; @RequestMapping("/quick2") public ModelAndView save2()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("success.jsp"); modelAndView.addObject("username", "helloworld"); return modelAndView; &#125; @RequestMapping("/quick") public String save()&#123; System.out.println("controller running"); return "success.jsp"; &#125; 2. 回写数据 直接返回字符串 @ResponseBody 12345678910@RequestMapping("/quick6")@ResponseBodypublic String save6() throws JsonProcessingException &#123; User user = new User(); user.setUsername("henry"); user.setAge(30); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(user);//jackson进行转换 return json;&#125; 返回对象和集合–设置将对象转换为json对象输出（配置处理器映射器）—可以通过mvc的注解替代以上操作 spring-mvc.xml， 同时要加入springmvc的命名空间，就可以不需要json转换工具了 12345xmlns:mvc="http://www.springframework.org/schema/mvc"xsi:schemaLocation=" http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&lt;!--mvc的注解驱动--&gt;&lt;mvc:annotation-driven/&gt; 数据请求1. 实现数据请求方式 基本数据类型参数 POJO类型参数 数组类型参数 123456//localhost/Springdemo/quick8?strs='111'&amp;strs='222' @RequestMapping("/quick8") @ResponseBody public void save8(String[] strs)&#123; System.out.println(Arrays.asList(strs)); &#125; 以上三种都比较简单，只要名称一致框架就会自动封装 集合类型参数 将集合包装到一个POJO中 123456789101112public class VO &#123; private List&lt;User&gt; userList; //提供get 和set&#125;//VO作为形式参数@RequestMapping("/quick10")@ResponseBodypublic void save10(VO vo)&#123; System.out.println(vo);&#125;//此处要求VO中的属性名称和表单提交的名称一致&lt;input type="text" name="userList[0].username"&gt;&lt;br/&gt; ajax请求时指定contextType为json，使用 @RequestBody 访问jQuery失败： 12&lt;!--开发资源的访问 spring-mvc.xml, 开放静态资源的访问--&gt;&lt;mvc:default-servlet-handler/&gt; 12345678910var userList = new Array();userList.push(&#123;username:"zhangsan", age:12&#125;);userList.push(&#123;username: "lisi", age: 15&#125;);$.ajax(&#123; type:"POST", url:"$&#123;pageContext.request.contextPath&#125;/quick9", data:JSON.stringify(userList),//将数组转为json数据 contentType: "application/json; charset=utf-8"&#125;); 12345@RequestMapping("/quick9")@ResponseBodypublic void save9(@RequestBody List&lt;User&gt; userList)&#123; System.out.println(userList);&#125; 2. 获取数据细节 中文乱码问题 @RequestParam （value， required， defaultValue）和 @PathVariable 123456789101112//localhost/quick11?name=zhangsan@RequestMapping("/quick11")@ResponseBodypublic void save11(@RequestParam("name") String username)&#123; System.out.println(username);&#125;//localhost/quick11?username=zhangsan@RequestMapping("/quick12/&#123;username&#125;")@ResponseBodypublic void save12(@PathVariable("username") String username)&#123; System.out.println(username);&#125; 自定义类型转换器– 定义com.tsuki.converter.DateConverter实现Converter接口 1234567891011121314151617181920212223package com.tsuki.converter;import org.springframework.core.convert.converter.Converter;//注意不要导错包import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class DateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String dateStr) &#123; SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd"); Date date=null; try &#123; date=format.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125; 在配置文件中声明转换器，在 &lt;annotation-driven&gt; 中引用转换器。spring-mvc.xml 123456789101112&lt;!--mvc的注解驱动--&gt;&lt;mvc:annotation-driven conversion-service="conversionService"/&gt;&lt;!--开发资源的访问--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="com.tsuki.converter.DateConverter"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 获取Servlet相关API：直接形参注入 @RequestHeader和@CookieValue 1234567891011@RequestMapping("/quick14")@ResponseBodypublic void save14(@CookieValue(value = "JSESSIONID", required = false) String user_agent)&#123; System.out.println(user_agent);&#125;@RequestMapping("/quick13")@ResponseBodypublic void save13(@RequestHeader(value = "User-Agent", required = false) String user_agent)&#123; System.out.println(user_agent);&#125; 文件上传 表单编写 123456&lt;%--注意enctype的填写--%&gt;&lt;form action="$&#123;pageContext.request.contextPath&#125;/quick15" method="post" enctype="multipart/form-data"&gt; 名称&lt;input type="text" name="username"&gt;&lt;br/&gt; 文件&lt;input type="file" name="uploadFile"&gt;&lt;br/&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; pom.xml导入坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 配置文件上传解析器 spring-mvc.xml 12345&lt;!--配置文件上传解析器--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="UTF-8"/&gt; &lt;property name="maxUploadSize" value="500000"/&gt; &lt;/bean&gt; 编写文件上传代码 123456789@RequestMapping("/quick15")@ResponseBodypublic void save15(String username, MultipartFile uploadFile) throws IOException &#123; //uploadFile形参名字与表单的提交文件name名称一致 System.out.println(username); String originalFilename = uploadFile.getOriginalFilename(); //保存到某位置 uploadFile.transferTo(new File("F:\\图片\\"+originalFilename));&#125; 拦截器 快速入门 创建拦截器实现HandlerInterceptor接口 1234567891011121314151617181920212223242526public class MyInterceptor1 implements HandlerInterceptor &#123; //目标方法执行之前 执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("preHandle running..."); String param = request.getParameter("param"); if("yes".equals(param))&#123; return true; &#125;else&#123; request.getRequestDispatcher("success.jsp").forward(request,response); return false; &#125; &#125; //目标方法执行之后，视图对象返回之前执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; modelAndView.addObject("name", "Java"); System.out.println("postHandle running..."); &#125; //在流程都执行完毕后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("aftercomletion running..."); HandlerInterceptor.super.afterCompletion(request, response, handler, ex); &#125;&#125; 配置拦截器 spring-mvc.xml 12345678&lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对那些资源进行拦截--&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean class="com.tsuki.interceptor.MyInterceptor1"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 测试 1234567891011@Controllerpublic class TargetController &#123; @RequestMapping("/target") public ModelAndView show()&#123; System.out.println("target is running..."); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("name", "Tomcat"); modelAndView.setViewName("index.jsp"); return modelAndView; &#125;&#125; 登录验证案例（待实践）过滤器： 获取session对象 request.getSession().getAttribute(“user”) 判断是否有user，否（return false） 是 （return true） 登录： login(username, password){} 调用userService.login():返回User（查表并用jdbcTemplate接收） 判断user是不是空，有（存到Session，并跳转首页） 否（跳转到登录页面） 异常处理配合日志输出使用 123456789&lt;!--配置异常处理器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;error.jsp&quot;/&gt; &lt;!--&lt;property name=&quot;exceptionMappings&quot;&gt; &lt;map&gt; &lt;entry key=&quot;异常类型&quot; value=&quot;错误视图&quot;&gt; &lt;/map&gt; &lt;/property&gt;--&gt; &lt;/bean&gt; 自定义异常处理 1. 创建异常处理器类实现HandlerExceptionResolver 2. 配置异常处理器到spring-mvc.xml 3. 编写异常页面 JdbcTemplate(待补充)补充 SimpleDateFormat中有两个方法，parse()和format() parse()把String型的字符串转换成特定格式的date类型 format()把Date型的字符串转换成特定格式的String类型 equals：参考博客 public boolean equals(Object obj) { return (this == obj); } 运行问题 报错1：Servlet不能正常访问，错误代码500，原因在于版本，我原本用的是tomcat10，改成tomcat9之后成功解决。论版本兼容的重要性。tomcat各版本的兼容 创建web项目还是不熟练。教程 本来Servlet要注入到web.xml中才会运行的，但是不知道什么原因不需注入也可以访问到。 SpringMVC错误：org.springframework.web.servlet.DispatcherServlet noHandlerFound ，我的错误原因是访问静态资源，改为访问jsp就成功了 在导入了jackson的坐标后发生了新的错误：java.lang.NoClassDefFoundError: com/fasterxml/jackson/databind/exc/InvalidDefinitionException ，找到问题了，版本不兼容，致命 在测试jsp页面发出post请求，用$.ajax响应集合类型参数是出现找不到jQuery和访问路径/quick的情况，原因是路径问题。url:&quot;${pageContext.request.contextPath}/quick9&quot;, 是jsp获取绝对路径的方式，这篇博客解析 SpringMVC中已经配置了解决中文乱码问题的过滤器后，还会出现中文乱码现象，尝试了博客所述的方法但是还未解决乱码问题，但是使用maven发布时不会乱码]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>框架笔记</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring笔记]]></title>
    <url>%2FSpring.html</url>
    <content type="text"><![CDATA[写此系列的目的是做一个学习笔记管理，方便以后复习用。 Spring是轻代码，重配置的框架。 Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层 SpringMVC 和持久层 Spring JDBCTemplate 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。 Spring框架的核心功能： 创建管理所有的Java对象，这些对象被称为Bean。 参考文档 参考视频 Spring快速入门 导入Spring开发的基本包坐标 pom.xml 123456789101112&lt;properties&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写Dao接口和实现类 12345678910public interface UserDao &#123; public void save();&#125;public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println("UserDao save method running...."); &#125;&#125; 创建Spring核心配置文件 在类路径下（resources）创建applicationContext.xml配置文件 1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt; 在Spring配置文件中配置UserDaoImpl 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置--&gt; &lt;bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 使用Spring的API获得Bean实例 1234567@Testpublic void test1()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao userDao = (UserDao) applicationContext.getBean("userDao"); userDao.save();&#125; Spring配置文件重要配置标签12345678910111213&lt;bean&gt;标签 id属性:在容器中Bean实例的唯一标识，不允许重复 class属性:要实例化的Bean的全限定名 scope属性:Bean的作用范围，常用是Singleton(默认)和prototype &lt;property&gt;标签：属性注入 name属性：属性名称 value属性：注入的普通属性值 ref属性：注入的对象引用值 &lt;list&gt;标签 &lt;map&gt;标签 &lt;properties&gt;标签 &lt;constructor-arg&gt;标签&lt;import&gt;标签:导入其他的Spring的分文件 Bean实例化的三种方式无参构造方法实例化 1&lt;bean id = "userDao" class = "com.itheima.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt; 工厂静态方法实例化 工厂实例方法实例化 Bean的依赖注入依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC（反转控制） 的具体实现。 在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。 用依赖注入的方式管理Bean之间的依赖关系。依赖注入可以让Bean以配置文件组织在一起，是一种优秀的解耦方式。 依赖注入有两种方式，set注入和构造注入。（设计模式解耦合） set注入和构造注入 123456789101112&lt;!--set方式注入--&gt;&lt;bean id="userDao" class="com.tsuki.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;&lt;bean id="userService" class="com.tsuki.service.impl.UserServiceImpl"&gt; &lt;!--set方法后的名字是name，ref是指向注入的UserDao的id--&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--构造器方式注入--&gt;&lt;bean id="userDao" class="com.tsuki.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;&lt;bean id="userService" class="com.tsuki.service.impl.UserServiceImpl"&gt; &lt;constructor-arg name="userDao" ref="userDao"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 相关APIapplicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象 ApplicationContext的实现类 1）ClassPathXmlApplicationContext 它是从类的根路径下加载配置文件 推荐使用这种2）FileSystemXmlApplicationContext 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。3）AnnotationConfigApplicationContext 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 123ApplicationContext app = new ClasspathXmlApplicationContext("xml文件");app.getBean("id");app.getBean(Class); Spring配置数据源（连接池）druid步骤： 导入依赖 pom.xml 1234567891011121314151617181920212223242526272829&lt;!--mysql驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.26&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;!--druid连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt;&lt;!--导入Junit--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--版本要求高于4.11--&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 创建DataSource 在Spring中采用注入容器的方法 applicationContext.xml 123456&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/db1"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt; 将参数提取到properties文件中后如何注入容器 1.需要引入context的命名空间和约束路径 命名空间 xmlns:context=&quot;http://www.springframework.org/schema/context&quot; 约束路径 http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd applicationContext.xml 1234567891011&lt;!--加载外部配置文件，classpath是从类加载文件resources中加载--&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;&lt;!--注入datasource--&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;!--spl表达式，类似el表达式的用法 value="$&#123;key&#125;"--&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 使用 123456789@Testpublic void test2() throws SQLException &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");//加载Spring的配置文件 //从容器中获取对象 DataSource ds = (DataSource) applicationContext.getBean("dataSource"); Connection conn = ds.getConnection(); System.out.println(conn); conn.close();&#125; 注解开发简化和舍弃Spring的配置文件，方便快捷 原始注解 @Component &lt;bean id=&quot;userDao&quot; class=&quot;com.tsuki.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; @Controller @Service @Repository @Autowired @Qualifier---@Resource按名称注入 123&lt;bean id="userService" class="com.tsuki.service.impl.UserServiceImpl"&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;&lt;/bean&gt; @Value(普通属性) @Scope 配置组件扫描 12&lt;!--配置组件扫描--&gt; &lt;context:component-scan base-package="com.tsuki" /&gt; 新注解开发—全注解开发 旧注解有几方面不能满足 @Configuration Spring的核心配置类，用类的方式替代xml文件， 注解的方式替代标签 非自定义的bean @Bean(&quot;dataSource&quot;) 配置文件properties @PropertySource(&quot;classpath:jdbc.properties&quot;) 组件扫描 @ComponentScan(&quot;com.tsuki&quot;) 引入import @Import Junit的集成 导入spring集成Junit坐标 pom.xml 1234567891011121314151617181920&lt;!--导入Junit--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--版本要求高于4.11--&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;!--导入spring的test坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; @Runwith代替原来运行周期 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration指定配置文件或配置类 @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) @Autowired注入需要测试的对象 创建测试方法进行测试 AOP事务控制未完待续。。。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>框架笔记</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摩尔投票法]]></title>
    <url>%2F%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[有时候，刷算法题的关键是读懂题目。时常卡在读不懂题目=_= 摩尔投票法今日的力扣每日一题是229.Majority Element II。看懂题目后最开始的想法就是普通的，遍历一遍数组统计出每个数字出现的次数存在数组中，然后再遍历一次数组找出是否存在次数大于⌊ n/3 ⌋的元素。 看了评论区题解学到了新的解题方法。刷题在于学习总结嘛。本题可以用到摩尔投票法的变体。 摩尔投票法出自论文，算法解决的问题是如何在任意多的候选人中，选出获得的票数最多的那个。算法演示，文章做了很详细的解读。摩尔投票法主要分为两个阶段，第一阶段筛选可能的元素，第二阶段验证。应用在众数的解答上。 Majority Element II 解答 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; int x = 0, y = 0; int cx = 0, cy = 0; for(auto num : nums)&#123; if((cx == 0||num == x)&amp;&amp; num != y)&#123; cx++; x = num; &#125;else if(cy == 0|| num == y)&#123; cy++; y = num; &#125;else&#123; cx--; cy--; &#125; &#125; int countx = 0, county = 0; for(auto num:nums)&#123; if(num == x) countx++; if(num == y) county++; &#125; int target = nums.size()/3; if(countx &gt; target) res.push_back(x); if(county &gt; target &amp;&amp; y != x) res.push_back(y); return res; &#125;&#125;; 参考博客 169 Majority Element 解答 前提条件中假设数组非空，且一定存在多数元素，所以可以省掉第二阶段验证。 12345678910111213141516class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int res = 0; int count = 0; for(auto num: nums)&#123; if(count == 0 || num == res)&#123; res = num; count++; &#125;else&#123; count--; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>摩尔投票法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAD]]></title>
    <url>%2FMad.html</url>
    <content type="text"><![CDATA[常调侃说做MAD死路一条，实际上也真是如此？ 最近重拾做视频，发完以后没人看难免失落就去搜了这个问题，不禁思考起剪mad的初衷。 什么是一个好的MAD？ 一个好的MAD是讲述一个好的故事或者给观者带来好的视觉享受，用MAD讲好故事才是一开始想做的。 现在的状况是有点陷入了技术突破的死区里，一直很想做一个欧美风的MAD，大概就是视觉体验吧。说实话现在剪的视频没什么内容。最近剪的两篇个人向都在追求技术，只是镜头的简单拼接，勉强算是考虑了镜头的衔接。放在众多优秀作品里只能说普通又普通，没有画面，没有故事，没有播放量才是常态。而且我做mad是为了播放量吗，虽然不在意播放是假的，但是初心是为了突破自己，做自己喜欢的事，所以不忘初心真的很难的。 (人总是在找合适的理由安慰自己哈) 虽然这些年也没有把重心放在做视频上，好几年不学新技术，但也确实是毫无进步。剪了这么多年仍旧没什么质量提升，其实这种状况下不如不发，好好沉淀一下。 重要的从来不是在AE和Vegas里花多少时间，它只是工具，重要的是表达自己的思想，享受尝试新东西的快乐。所以，喜欢就坚持下去！]]></content>
      <categories>
        <category>生活</category>
        <category>MAD</category>
      </categories>
      <tags>
        <tag>MAD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vegas 导入 AE]]></title>
    <url>%2FVegas%E8%BD%ACAE.html</url>
    <content type="text"><![CDATA[电脑带不动Pr，所以一开始就用的vegas，虽然vegas有很多插件 例如newBlue都很好用，但是做特效和拉曲线当然还是AE方便，于是就想着有没有什么方法能在vegas粗剪的视频导入ae。以前就找过相关的教程，但是时隔太久不用，我存在哪里已经忘了，又折腾半天，这回一定要存好。于是有了这篇博客。 操作步骤： 在vegas中粗剪完成放在一个视频轨道上，删掉音频 文件==&gt;导出 ==&gt; Media Composer AAF File 打开AE， 文件==&gt;导入==&gt;Pro Import After Effects… 修改合成大小 附：使用的软件版本是AE CC 2015和Vegas13 参考视频，感谢up主，视频还提供了AE转Vegas的操作，暂时没有用到就先m一下，不展开记录了 完]]></content>
      <categories>
        <category>技术</category>
        <category>剪辑</category>
        <category>vegas</category>
      </categories>
      <tags>
        <tag>vegas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Latex]]></title>
    <url>%2Flatex.html</url>
    <content type="text"><![CDATA[第一次用latex排版，记录一下使用过程中遇到的问题。 哈哈哈论文能不能投不知道，调格式倒是挺折腾。记录下来以后说不定会用到，省得再折腾一次。总的来说上手还是挺快的，博主的经历和latex编辑注意事项也给小白的我很多的帮助。 texlive的编辑器显示效果不是很好看，但是图个省事就没有安装vscode。 下载模板首先下载完成IEEEtrans模板之后的使用。 IEEEtran.cls文件复制到texlive\2021\texmf-local\tex\latex 以管理员方式运行cmd，&gt;texhash 将.tex文件复制到texlive文件夹里面即可 参见博客。 然后就可以开始快乐编辑内容。 公式篇关于插入公式真的是很方便，只要多用几次就能掌握常用的命令，希腊字母根据发音的写法也很好记，打开了新世界大门。 如何插入公式。 123456\begin&#123;equation&#125; \begin&#123;split&#125; P(t)=P(t-t_0)+D(t), x = a + b. \end&#123;split&#125;\end&#123;equation&#125; 要记得加入宏包 \usepackage{amsmath} 公式的常用符号的写法看这里。符号大全补充看这里。 导数相关的符号看这里。都是基础问题就不赘述。 如何排版公式，善用&amp;符号。 图片篇加入宏包 \usepackage{graphicx} 如何插入图片，看这里。 12345678\begin&#123;figure&#125;[htbp] \centering \includegraphics[width=2.5in]&#123;fig1.eps&#125; \caption&#123;name&#125; \label&#123;fig1&#125;\end&#123;figure&#125; %如何解决路径问题graphicspath&#123;&#123;img/&#125;&#125;%当前路径下存放图片的文件夹 如何插入eps图片，简单粗暴，我是直接PS另存为解决了。其他解决方法看这里。 文献篇如何插入文献？ 创建bibtex文件，建立参考文件库。 便捷使用google的引用功能，轻松搞定！ 文章主体添加引用 \cite{ref} 四次编译，就可以引用位置和参考文献位置链接互通啦！这里被卡了一会，参考文章总算解决掉了。 高亮内容的制作，参考文章 如何插入链接型的文献呢？看这里 我是手动修改的.bib文件，不知道有没有更便捷准确的方法，如果有人看的话，欢迎邮件交流。 123456@Misc&#123;timmurphy.org,howpublished = &#123;[EB/OL]&#125;,note = &#123;\url&#123;http://timmurphy.org/2009/07/22/line-spacing-in-latex-documents/&#125; Accessed April 4, 2010&#125;,title = &#123;Line Spacing in LaTeX documents&#125;,author = &#123;Murphy, Timothy I&#125;&#125; 在插入链接型参考文献的时候，引申一下EB/OL的含义。 交叉引用通过图片和公式的交叉引用，无论公式挪动到哪里都能正确的编号，省了自己费劲数的功夫，还不会产生失误。 \ref命令配合\label的使用基本就解决了图片公式以及文献的引用，一个ref走天下。 引用图片 \ref{fig1} 引用文献 \ref{ref1} 引用方程 \ref{equation1} 此外还可以导入amsmath包用 \eqref{equation1} 参考文章： 文章1 文章2 碎碎念在学习latex的过程中，刷到了一篇关于如何写好论文的博客，给迷茫的我上了一课。 写paper的两种方式: Idea-&gt;Do Research-&gt;Write Paper Idea-&gt;Write Paper-&gt;Do Research 以前一直认为论文是以结果为导向的，这可能与我过往做物理实验的经历有关。还是道行尚浅啊。每次在组会上说到论文没有成果展示的时候，老师都会反问一句一定要有成果吗？当时不理解，现在读到这篇文章，哦原来，paper真正的目的是交流思想的。其实写文章的过程中也查阅了很多的文献，仔细回想一下这些优秀的文献也确实如此。]]></content>
      <categories>
        <category>技术</category>
        <category>论文</category>
        <category>latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>IEEEtrans</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java,python,c#事件机制和常用库比较]]></title>
    <url>%2Fhomework02.html</url>
    <content type="text"><![CDATA[本篇博客其实是课后作业，搬过来。 最近刷题，复习Java常用类是突然想起来以前做过的比较，不甚成熟，补充在一起。 作业1Java，Python和JavaScript中对事件机制的支持语法及使用方法 在c#中事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。 包含事件的类用于发布事件。这被称为 发布器（publisher） 类。其他接受该事件的类被称为 订阅器（subscriber） 类。事件使用 发布-订阅（publisher-subscriber） 模型。 发布器（publisher） 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。 订阅器（subscriber） 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）。 观察者模式是一种常用的设计模式，这种设计模式刚好可以用于事件驱动机制。 Python中的事件机制参考自博客(https://blog.csdn.net/brucewong0516/article/details/84031715) 监听器（subscriber）监听了事件源（publisher），当事件源发送事件时，所有监听该事件的监听器（subscriber）都会接收到消息并作出响应。 Python中也有event（事件），是线程threading模块中的一个类，它提供了简单的几个方法，set(), clear(), wait(timeout), isSet()。而我们要探讨的事件机制是以下的实现方法。 已知Python中可直接传递函数名，实现类似c#中委托的功能，故可以在注册事件的回调时，代入一个参数callback，在注册函数实体内，存在一个list将callback添加进去， 12def register_callback(self, cb): self.callbacks.append(cb) 以下是一个稍显复杂的实现方法。通过eventManager可以实现事件触发，当事件触发时，推送事件到线程中运行。eventManager主要包含以下几个方法。 run(), AddEventListener(), RemoveEventListener(), SendEvent() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from queue import Queue, Emptyfrom threading import *class EventManager: def __init__(self): self.__eventQueue = Queue() self.__active = False self.__thread = Thread(target = self.__Run) #事件处理线程，创建一个线程用于run() self.__handlers = &#123;&#125;#保存对应事件的响应函数 def __Run(self): while self.__active == True: try: #获取事件的阻塞时间设为1秒 event = self.__eventQueue.get(block = True, timeout = 1) #发出通知 if event.type_ in self.__handlers: for handler in self.__handlers[event.type_]: handler(event) except Empty: pass def Start(self): self.__active = True #启动事件处理线程 self.__thread.start() def Stop(self): self.__active = False #等待事件处理进程退出 self.__thread.join() def AddEventListener(self, type_, handler): try: handlerList = self.__handlers[type_] except KeyError: handlerList = [] self.handler[type_] = handlerList if handler not in handlerList: handlerList.append(handler) def RemoveEventListener(self, type_, handler): try: handlerList = self.__handlers[type_] if handler in handlerList: handlerList.remove(handler) if not handlerList: del self.handlers[type_] except KeyError: pass def SendEvent(self, event): self.__eventQueue.put(event) 实例调用 1234567891011121314151617181920212223242526272829303132333435363738394041import sysfrom datetime import datetimefrom threading import *from eventManager import * #事件名称 新文章EVENT_ARTICAL = "Event_Artical" #事件源 公众号class PublicAccounts: def __init__(self,eventManager): self.__eventManager = eventManager def WriteNewArtical(self): event = Event(type_=EVENT_ARTICAL) event.dict["artical"] = u'如何写出更优雅的代码\n' self.__eventManager.SendEvent(event) #发送事件 print(u'公众号发送新文章\n') class Listener: def __init__(self,username): self.__username = username #监听器的处理函数 读文章 def ReadArtical(self,event): print(u'%s 收到新文章' % self.__username) print(u'正在阅读新文章内容：%s' % event.dict["artical"])#--------------------------------------------------------------------def test(): # 实例化监听器 listner1 = Listener("thinkroom") #订阅者1 listner2 = Listener("steve") #订阅者2 eventManager = EventManager() eventManager.AddEventListener(EVENT_ARTICAL, listner1.ReadArtical) eventManager.AddEventListener(EVENT_ARTICAL, listner2.ReadArtical) eventManager.Start() publicAcc = PublicAccounts(eventManager) timer = Timer(2, publicAcc.WriteNewArtical) timer.start() if __name__ == '__main__': test() Java的事件机制参考自博客(https://www.jianshu.com/p/ccd468c6be8a) (https://www.cnblogs.com/liao13160678112/p/6596218.htm) (https://www.cnblogs.com/yulinfeng/p/5874015.html) 用观察者模式实现事件机制 对于观察者模式，Java已经为我们提供了已有的接口和类。可以利用Java提供的Observer接口和Observable类实现观察者模式。 12345678910111213141516171819202122232425262728293031import java.util.Observable;import java.util.Obsever;public class Subscribe implements Observer&#123; public Subscribe (Observable o)&#123; o.addObserver(this); &#125; public void update(Observable o, Object arg)&#123; System.out.println("收到通知:" + ((Publish)o).getData()); &#125;&#125;public class Publish extends Observable&#123; private String data = ""; public String getData()&#123; return data; &#125; public void setData(String data)&#123; if(!this.data.equals(data))&#123; this.data = data; setChanged(); //改变通知者的状态 &#125; notifyObservers(); //调用父类Observable方法，通知所有观察者 &#125;&#125;public class Main&#123; public static void main(String[] args)&#123; Publish publish = new Publish(); Subscribe subscribe = new Subscribe(publish); publish.setData("start!"); &#125;&#125; 也可以自己实现。 12345678910111213141516171819202122232425262728293031public class Event &#123; public ArrayList&lt;Callback&gt; callbackList;//与事件相关的事件处理函数 //遍历所有的事件触发通知 public void emit()&#123; for(Callback cb : callbackList)&#123; cb.run(); &#125; &#125; //注册事件处理函数 public registerCallback(Callback cb)&#123; callbackList.add(cb); &#125; //移除注册 public removeCallback(Callback cb)&#123; callbackList.remove(cb); &#125;&#125;/*事件处理函数类*/public interface Callback &#123; void run();&#125;public class OnClick implements Callback &#123; //函数 public void run()&#123; System.out.println("you just clicked me!"); &#125;&#125; //testEvent e = new Event(); e.registerCallback(new OnClick()); //注册到队列中e.emit();//do something 观察者模式存在不足之处，两个观察者模式的观察者都是实现了同一接口，如果两个观察者风马牛不相及又该怎么办。参考委托和事件的关系，我们可以用callback实现一个“委托”，即也可以用反射实现事件机制。 12345678910111213141516171819202122232425262728293031323334353637383940/*事件处理类*/public class EventHandler &#123; //事件源 private Object sender; //事件处理函数名称（用于反射） private String callback; public EventHandler(Object sender, String callback)&#123; this.sender = sender; this.callback = callback; &#125; //事件触发 public void emit()&#123; Class senderType = this.sender.getClass(); try &#123; //获取并调用事件源sender的事件处理函数 Method method = senderType.getMethod(this.callback); method.invoke(this.sender); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125;&#125;/*事件源*/public class Button()&#123; /*可以在此设置Button类的相关属性，比如名字等*/ private String name; ... //事件处理函数 public void onClick()&#123; System.out.println("you just clicked me!"); &#125;&#125; /*实现事件驱动机制*/Button b = new Button();if(/*收到按钮点击信号*/)&#123; EventHandler e = new EventHandler(b, "onClick"); e.emit();&#125; JavaScript的事件机制参考自博客（https://blog.csdn.net/a2013126370/article/details/82290180） 事件是将JavaScript和网页联系在一起的主要方式。 事件：用户或浏览器自身执行的某种动作，换言之，文档或浏览器发生的一些特定的交互瞬间。 事件处理程序：又称事件侦听器，事件发生时执行的代码段。 事件流：事件流描述的是从页面中接收事件的顺序。 两种基本事件模型 事件冒泡：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 事件捕获：事件从最不精确的对象(document 对象)开始触发，然后到最精确。 DOM事件流 同时支持 两种基本事件模型，规定事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。 DOM事件处理程序绑定时，程序员可以自己选择绑定事件时采用事件捕获还是事件冒泡。 IE事件流 IE只支持事件冒泡，不支持事件捕获。 事件处理程序绑定方式 DOM事件处理方式，可以通过addEventListener方法 addEventListener(“事件名”，事件处理程序，ture/false:在事件捕获/冒泡阶段调用模型) 对应的事件处理程序移除方法：removeEventListener，参数必须相同。 IE事件处理程序 程序作用域为全局作用域，this指向window对象 添加方法：attachEvent(“on+事件名”，事件处理程序) 移除方法：detachEvent(“on+事件名”，事件处理程序) 综合以上所述，写可跨浏览器的事件处理程序（构造EventUtil对象，为其添加可兼容各浏览器的事件处理方法），如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*可跨浏览器的事件处理程序构造EventUtil对象，为其添加可兼容各浏览器的事件处理方法*/var EventUtil = &#123; /*添加事件处理程序*/ addHandler: function (element, type, handler) &#123; if (element.addEventListener) &#123; addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = handler; &#125; &#125;, /*移除事件处理程序*/ removeHandler: function (element, type, handler) &#123; if (element.removeEventListener) &#123; removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125;, /*获得事件对象*/ getEvent: function (event) &#123; return event ? event : window.event; &#125;, /*获得事件的目标*/ getTarget: function (event) &#123; return event.target || event.scrElement; &#125;, /*取消事件的默认行为*/ preventDefault: function (event) &#123; if (event.preventDefault) &#123; event.preventDefault; &#125; else &#123; event.returValue = false; &#125; &#125;, /*阻止事件进一步冒泡*/ stopPropagation: function (event) &#123; if (event.stopPropagation) &#123; event.stopPropagation; &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125;; 作业2简介Java和Python中对常用数据容器的支持库和使用方式 Java的常用库参考自菜鸟教程，Java官方中文文档 2022年补充 Java提供的数据集合主要涉及两部分，一部分是java.util.Collection的实现类，一部分是java.util.Map的实现类。 Java框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。 因为相关类众多，这里做一个简单的示例。使用Java提供的类库是要使用import， 注意Java对大小写敏感。 import java.util.*; Collection接口 参考图来源 List接口是有序的collection。List最大的特点就是有序可重复。Set正与List相反，无序不可重复。 List的子类，有Vector，ArrayList，LinkedList。 1） ArrayList， 是基于数组实现的List类，它封装了一个动态的增长的，允许再分配的Object[]数组，允许对元素进行快速随机访问。 123import java.util.ArrayList;ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;();sites.add("Google"); 2）Vector，是通过数组实现的，不同的是它支持线程的同步。 123import java.util.Vector;Vector v = new Vector();v.addElement(new Integer(1)); 3）Stack，是Vector提供的一个子类，模拟栈的数据结构。 123import java.util.StackStack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();st.push(new Integer(10)); Vector已经建议弃用了，因为它加了太多的synchronized。Stack继承了Vector也弃用了 Vector和ArrayList的区别是什么 一是线程安全问题，二是扩容问题，Vector默认扩容两倍，而ArrayList扩容实现用的算术右移，新容量是原来的1.5倍 4）LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除。 123import java.util.LinkedList;LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();list.add(2); List的实现方式有LinkedList和ArrayList两种，如何选择，要考虑到实现的功能和效率问题。链表和数组的最大区别就是数组是可以随机访问的。这部分的效率问题其实就是数据结构的内容。 Set接口 Set接口的实现类有HashSet，TreeSet，LinkedHashSet。 1） HashSet类，用Hash算法来存储集合中的元素。 123import java.util.HashSet;HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;();sites.add("Google"); 2）LinkedHashSet，也是根据元素的hashCode值来决定元素的存储位置，但和HashSet不同的是，它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。 3）EnumSet是一个专门为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式、或隐式地指定。EnumSet的集合元素也是有序的 4）TreeSet采用红黑树结构，特点是可以有序。 Queue接口 Queue有两组API，基本功能是一样的。根据需求选择一组统一使用。 1) 提供了Deque接口，专门用于操作表头和表尾，可以当作堆栈，队列和双向队列使用。 2) PriorityQueue，优先队列按照队列中某个属性的大小来排列。 在实现普通队列时建议使用ArrayDeque，效率更高。只要不是不需要存null值，就用ArrayDeque。 Map接口用于保存具有映射关系的数据。 Map的子类，子接口 1）HashMap和HashSet集合不能保证元素的顺序一样，HashMap也不能保证key-value对的顺序。并且类似于HashSet判断两个key是否相等的标准一样: 两个key通过equals()方法比较返回true、 同时两个key的hashCode值也必须相等 123import java.util.HashMap;HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;();Sites.put(1, "Google"); 2）HashTable类是一个古老的Map实现类。 3）SortedMap接口下的类，TreeMap类，是一个红黑树结构，每个键值对都作为红黑树的一个节点。TreeMap存储键值对时，需要根据key对节点进行排序，TreeMap可以保证所有的key-value对处于有序状态。 同时，TreeMap也有两种排序方式：自然排序、定制排序（类似于上面List的重写CompareTo()方法）。 Python的常用库参考自菜鸟教程， python中文手册 Python中同样提供了一些基本容器，列表，元组，字典和集合，以及collections中几种已经预先实现的容器数据结构namedtuple(), deque, ChainMap, Counter, OderedDict, defaultdict等等 同样的Python的每一数据类型都包含了很多的方法。以list为例： 1234567891011list.append(x)list.extend(L)list.insert(i,x)list.remove(x)list.pop()list.clear()list.index(x)list.count(x)list.sort()list.reverse()list.copy() 具体的使用说明可参考官方文档。 Python数据类型首先，Python中的基本顺序存储结构是列表和元组，在操作和复杂度上和数组完全相同，其中列表是可变数据类型，元组是不可变数据类型。 1）list是Python中最基本的数据结构，列表的数据项不需要具有相同的数据类型。 1234list = ['red', 'green', 12]print(list[0])list.append('blue')del list[0] list也可以当作堆栈和队列来用。 2）元组与列表类似，不同之处在于元组的元素不能修改。 12345tup1 = ('physics', 'chemistry', 1997, 2000)tup2 = (50,)print(tup1[0])tup3 = tup1 + tup2del tup1 3）字典是另一种可变容器模型，可存储任意类型对象 12345dict = &#123;'a': 1, 'b': 2&#125;print(dict['a'])dict['a'] = 8del dict['a']dict.clear() 4）集合set是一个无序的不重复元素序列。基本功能包括关系测试和消除重复元素。集合对象还支持 union（联合），intersection（交），difference（差）和 sysmmetric difference（对称差集）等数学运算。 1234thisset = set(("google", "runoob", "taobao"))thisset.add("facebook")thisset.update([1,4],[5,6])thisset.remove("taobao") collections模块Python的collections模块实现了一些数据结构，使用时可以用import导入 import collections 栈和队列 1）namedtuple是继承自tuple的子类，namedtuple创建一个和tuple类似的对象，而且对象拥有可访问的属性。 123from collections import namedtuplePoint = namedtuple('point', ['x', 'y'])p = Point(1, 2) 2）队列 1234import queueQ = queue.Queue()Q.put(10)print(Q.get()) 3）双端队列 12from collections import dequeq = deque([1, 2]) 作业3编写有序表合并算法代码，以及相应的单元测试代码 123456789101112131415161718192021222324252627282930313233343536373839namespace demo&#123; public class MyObject &#123; //升序的有序表合并 public int[] UpMerge(int[] l1, int[] l2) &#123; int[] L = new int[l1.Length + l2.Length]; int count = 0; int i = 0, j = 0; while (i &lt; l1.Length &amp;&amp; j &lt; l2.Length) &#123; if (l1[i] &lt; l2[j])//相对于升序的有序表合并，降序的有序表仅需改动此处符号 &#123; L[count++] = l1[i++]; &#125; else &#123; L[count++] = l2[j++]; &#125; &#125; if (i &lt; l1.Length) &#123; while (i &lt; l1.Length) L[count++] = l1[i++]; &#125; else &#123; while (j &lt; l2.Length) L[count++] = l2[j++]; &#125; return L; &#125; //降序的有序表合并，与以上代码基本相同 //public int[] DownMerge(int[] l1, int[] l2) //&#123; //&#125; &#125;//MyObject&#125; 测试代码 12345678910111213141516171819202122using System;using Microsoft.VisualStudio.TestTools.UnitTesting;using demo;namespace test01&#123; [TestClass] public class UnitTest4 &#123; [TestMethod] public void TestMethod1() &#123; int[] L1 = &#123; 2, 4, 6, 8 &#125;; int[] L2 = &#123; 1, 3, 5, 7, 9, 10, 11, 12&#125;; MyObject my = new MyObject(); int[] LU = my.UpMerge(L1, L2); for(int i = 0; i &lt; 12; i++) &#123; Assert.AreEqual(i + 1, LU[i]); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html</url>
    <content type="text"><![CDATA[开启了动态规划刷题模块，动态规划的关键是写出状态方程和确定边界，从易到难开启练级之路。 动态规划在什么情况下用到动态规划 一维/二维LCP 19. 秋叶收藏集 （待完成 先是四个简单题入门 leetcode509 斐波那契数 leetcode1137 第n个泰波那契数 leetcode70 爬楼梯 计数问题 leetcode746 使用最小花费爬楼梯 最优问题 509算是最基础的递归，1137使用递归会超时，从官方解答中学到了滚动数组的解法。滚动数组可以将二维降为一维。 70算是一个典型的动态规划，登顶的情况可以分为最后一级台阶为1或为2，自然可以写出状态方程，dp[n] = dp[n-1] + dp[n-2]，同样可以使用滚动数组的方式减少内存占用，解决超时问题。746是70的变体，可以选择从下标为0或1的元素作为初始阶梯，状态方程可以写为dp[i] = min(dp[i - 1]+ costs[i - 1], dp[i - 2] + costs[i - 2]); leetcode198 打家劫舍 leetcode213 打家劫舍II 一维，打家劫舍这两个题，偷第k家，最大收益dp[k-2]+nums[k]，不偷第k家，最优收益就是偷前一家的最大收益dp[k-1] 213同样可以使用滚动数组来降低空间复杂度。 213是198的变体，题解中有一个使用两次贪心算法求解的，没太理解。 123456dp1[1] = nums[0]; dp2[1] = nums[1]; for(int i=2; i &lt; n; i++)&#123; dp1[i] = Math.max(dp1[i - 2]+nums[i -1], dp1[i - 1]); dp2[i] = Math.max(dp2[i - 2]+nums[i], dp2[i - 1]); &#125; leetcode740 删除并获取数 先做散列再做打家劫舍 leetcode 53 最大子数组和 这道题竟然是简单难度。拿到题的思路是暴力解法和动态规划，但是状态方程着实被难住了，作为新手还是要积累经验。 f(i) 表示以 i 元素为结尾的连续数组的最大和。 考虑到 f(i)只和 f(i-1)相关，可以只用一个变量 pre 来维护对于当前 f(i) 的 f(i-1)的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。 LeetCode-Solution leetcode 918 环形子数组的最大和 这题分两种情况，第一种最大和数组不是环，第二种最大和数组涉及环。题解的图很清楚，关键是对于第二种情况的理解。接下来的解法类似于53最大子数组之和。 leetcode152 乘积最大子数组 感觉上和最大连续子数组和是一个类型。但实际上有区别。记录乘积为正的最大和乘积为负的最小连续子数组大小。 leetcode 1567 乘积为正数的最长子数组长度 我是废物.jpg，类似于152题，记录最长乘积正数数组长度和最长乘积负数长度。 调试真心好用==正式上机不知道有没有调试功能 leetcode 1014 最佳观光组合 暴力解法果然超时了，O(n^2)能过的数据规模大概在1000左右。MARK！一边遍历一边计算最大值。数学思维值得学习。 139. 单词拆分 字符串s.substring()用法。定义 dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[0..i-1]是否能被空格拆分成若干个字典中出现的单词。对于字符串 s[0..i-1]的分割点 j，前j个字母已经判断过，只需要判断[j, i]是否在字典中。从而形成了重叠子问题。 413. 等差数列划分 以nums[i]作为结尾的等差数列，答案增加的次数 t_i, 如果到i+1也满足等差数列，$$t_{i+1} = t_i + 1$$若不满足等差队列则t = 0 42. 接雨水 这是一道困难题，（待完成。 91. 解码方法 （待完成 最xx序列/串当题目和序列或者字符串相关时，可以考虑把状态设计成下面两种形式： 令dp[i]表示以A[i]结尾的xxx 令dp[i][j]表示A[i]到A[j]区间的xxx 300. 最长递增子序列 一维 123456789for(int i = 1; i &lt; n; i++)&#123; dp[i] = 1; for(int j = 0; j &lt; i; j++)&#123; if(nums[i] &gt; nums[j])&#123; dp[i] = Math.max(dp[i], dp[j] + 1); &#125; &#125; max = Math.max(max, dp[i]);&#125; 1143. 最长公共子序列 二维，dp[i][j]代表text1的 i 位前和text2的 j 位前最长公共子序列。 516. 最长回文子序列 二维，子序列通常是不连续的，而子串通常是连续的。 dp[i][j]表示字符串s的下标范围[i, j] 内的最长回文子序列长度。 12345678910111213int n = s.length();int[][] dp = new int[n][n];for(int i = n - 1; i &gt;= 0; i--)&#123; dp[i][i] = 1; for(int j = i + 1; j &lt; n; j++)&#123; if(s.charAt(i) == s.charAt(j))&#123; dp[i][j] = dp[i + 1][j - 1] + 2; &#125;else&#123; dp[i][j] = Math.max(dp[i+1][j], dp[i][j - 1]); &#125; &#125;&#125; 为什么要逆序遍历？ 因为状态转移式里面需要用到 dp[i+1] （或dp[j-1]），所以在遍历到 i,j 的时候，诸如 i+1,j-1 这些点，是应该需要已经访问过了的（否则未访问过的点，dp就成初始值 0 了）所以 i 要逆序遍历，j 要正序遍历 5. 最长回文子串 二维，动态规划。意外的卡了很久，是因为边界条件赋值错了，可恶。按照长度递归。 123456789101112131415161718192021222324252627 int n = s.length(); int[][] dp = new int[n][n]; int maxLen = 1; int begin = 0; for(int i = 0; i &lt; n; i++)&#123; dp[i][i] = 1; if(i &lt; n - 1 &amp;&amp; s.charAt(i) == s.charAt(i + 1))&#123; dp[i][i + 1] = 1; maxLen = 2; begin = i; &#125; &#125;//计算dp[0][4]时，将会转化为dp[1][3]，并不是初始化过的值。对枚举顺序调和也无法解决这个问题，则换个思路//根据递推写法从边界出发的原理，注意到边界问题是字串长度为1和2的字串，每次转移时都是对字串长度剪了1，不妨从子串长度和枚举子串初始位置进行枚举 //子串长度 for(int L = 3; L &lt;= n; L++)&#123; //枚举初始位置 for(int i = 0; i + L - 1 &lt; n; i++)&#123; int j = i + L -1; if(s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + 1][j - 1] == 1)&#123; dp[i][j] = 1; maxLen = L; begin = i; &#125; &#125; &#125; 392. 判断子序列 376. 摆动序列 路径问题64. 最小路径和 二维，比想象的简单，每次只能向下或者向右一步，本来以为要有个directions数组，逐个方向枚举，好像不需要。dp[i][j]表示当前位置的最小路径和。 123456789101112131415161718 int rows = grid.length, columns = grid[0].length; int[][] dp = new int[rows][columns];//边界 dp[0][0] = grid[0][0]; for(int i = 1; i &lt; rows; i++)&#123; dp[i][0] = dp[i - 1][0] + grid[i][0]; &#125; for(int j = 1; j &lt; columns; j++)&#123; dp[0][j] = dp[0][j - 1] + grid[0][j]; &#125;//状态转移 for(int i = 1; i &lt; rows; i++)&#123; for(int j = 1; j &lt; columns; j++)&#123; dp[i][j] = Math.min(dp[i][j - 1] + grid[i][j], dp[i - 1][j] + grid[i][j]); &#125; &#125; return dp[rows - 1][columns - 1]; 62. 不同路径 二维，小case，和上一个问题基本一样。 63. 不同路径 II 在上一题的基础上多了一个判断。看了官解有更简洁的写法，可以通过滚动数组优化。因为f(i, j)只与f(i - 1, j)和f(i, j -1)有关，可以用滚动数组的思想简化空间复杂度。 「滚动数组思想」是一种常见的动态规划优化方法，在我们的题目中已经多次使用到，例如「剑指 Offer 46. 把数字翻译成字符串」、「70. 爬楼梯」等，当我们定义的状态在动态规划的转移方程中只和某几个状态相关的时候，就可以考虑这种优化方法，目的是给空间复杂度「降维」。 作者：LeetCode-Solution 动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，比如这里的统计方案数的问题，它们都存在一定的递推性质。前者的递推性质还有一个名字，叫做 「最优子结构」 ——即当前问题的最优解取决于子问题的最优解，后者类似，当前问题的方案数取决于子问题的方案数。所以在遇到求方案数的问题时，我们可以往动态规划的方向考虑。 优化的代码： 1234567891011121314151617int m = obstacleGrid.length, n = obstacleGrid[0].length;int[] dp = new int[n];if(obstacleGrid[0][0] == 0) &#123; dp[0] = 1;&#125;for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(obstacleGrid[i][j] == 1)&#123; dp[j] = 0; continue; &#125; if(j - 1 &gt;= 0)&#123; dp[j] += dp[j - 1]; &#125; &#125;&#125; 931. 下降路径最小和 一维即可解决。注意调整枚举顺序，状态转移方程中$$matrix[i][j] = min(matrix[i + 1][j], matrix[i + 1][j - 1],matrix[i+ 1][j + 1]) + matrix[i][j];$$与第 i + 1 项有关。 120. 三角形最小路径和 也是非常相似的题。可以二维降一维。$$ans[j] = Math.min(ans[j], ans[j + 1])+ triangle.get(i).get(j);$$221. 最大正方形 背包问题416. 分割等和子集 dp[i][j]的含义很重要。 1234567891011121314151617181920boolean[][] dp = new boolean[n][target + 1];//前[0, i]个数选取和等于target，target+1是考虑到和为0//边界for(int i = 0; i &lt; n; i++)&#123; dp[i][0] = true;&#125;dp[0][nums[0]] = true;for(int i = 1; i &lt; n; i++)&#123; int num = nums[i]; for(int j = 1; j &lt;= target; j++)&#123; if(num &lt; j)&#123; //选或不选 dp[i][j] = dp[i - 1][j]|dp[i - 1][j - num]; &#125;else&#123; dp[i][j] = dp[i - 1][j]; &#125; &#125;&#125;return dp[n - 1][target]; 494. 目标和 本以为会是和416分割等和子集差不多的题。状态转移方程很容易想到，卡在了dp数组的定义。看了评论区的解释豁然开朗。采用倒序的原因mark一下。 1234567891011121314151617181920212223242526/* 原问题等同于： 找到nums一个正子集P和一个负子集N，使得总和等于target。即sum - sum(N) == sum(P)即sum(P) - sum(N) == target, sum - sum(N) - sum(N) = target即2 * sum(N) = sum - target; sum - target必须&gt;=0的偶数。换位sum(P)同理。即2 * sum(P) == target + sum(nums)， 其中target + sum(nums)必须&gt;=0且为偶数，否则等式不可能成立。则问题转换为：存在多少个子集P，使sum(N) == (sum - target)/2。*/ public int findTargetSumWays(int[] nums, int target) &#123; int sum = 0; for(int num: nums)&#123; sum += num; &#125; int diff = sum - target; if(diff &lt; 0 || diff % 2 != 0) return 0; int neg = diff / 2; int[] dp = new int[neg + 1];//考虑和为0 dp[0] = 1; for(int num : nums)&#123; //实现时，内层循环需采用倒序遍历的方式，这种方式保证转移来的是dp[i−1][] 中的元素值。 for(int j = neg; j &gt;= num; j--)&#123; dp[j] = dp[j] + dp[j - num]; &#125; &#125; return dp[neg]; &#125; 解法二回溯（算是加入target的集合类吧）。 1049. 最后一块石头的重量 II 跪了。和上一题一样怎么想到是背包问题有点难。理解题意，简单来说就是任意选i块石头，使得他们的重量趋近于总重量的一半，因为这样和另一半抵消的差值就是最小的（From Eason同学）。是目标和的变体。 474. 一和零 三维01背包问题，dp[i][j][k]三维数组来表示字符串前i个字符串中使用j个0和k个1最多得到的子集个数。方法二可以使用滚动数组降低维度。 ===================手动分割线===================== 补充一个背包问题汇总： 01背包：416. 分割等和子集 474. 一和零 494. 目标和 879. 盈利计划 1049. 最后一块石头的重量 II 1230. 抛掷硬币 完全背包：1449. 数位成本和为目标值的最大数字 322. 零钱兑换 518. 零钱兑换 II 279. 完全平方数 518. 零钱兑换 II 典型的完全背包问题。每个元素可以重复选取，且不考虑选取的顺序，组合问题。dp[i]表示金钱和为i的硬币组合数。第一层循环是遍历coins，确定的顺序不会出现重复的排列。第二层循环从coin开始遍历到amount，mark学习。 1234567891011public int change(int amount, int[] coins) &#123; int[] dp = new int[amount + 1]; dp[0] = 1; for (int coin : coins) &#123; //以当前coin为结尾的且和为i for (int i = coin; i &lt;= amount; i++) &#123; dp[i] += dp[i - coin]; &#125; &#125; return dp[amount];&#125; 377. 组合总和 Ⅳ 和上一题相似，完全背包问题。最开始的想法是回溯。每个元素可以重复选取，不同的是这题中需要考虑选取元素的顺序，排列问题。 322. 零钱兑换 dp[i]表示金钱和为i的最少个数。 Arrays.fill(dp, max) 279. 完全平方数 dp[i] 表示和为i的完全平方数的最小数量。 Arrays.fill(dp, Integer.MAX_VALUE); 和上一题很像。 70. 爬楼梯 终于遇到一个简单题。还是做过的。可以用滚动数组的思想优化空间复杂度。 股票问题121. 买卖股票的最佳时机 这题可以暴力解也可以借鉴1014，将双重循环转变为单层循环，用动态规划解。难得自己解出来。 122. 买卖股票的最佳时机 II 这题看了题解才发现好简单，我自己搞复杂了。算在贪心里更合适，动态规划大材小用。可以先购买然后同一天出手，分为两种情况，当前持有股票和不持有股票，dp[i][0]表示不持有股票，前i天的最大利润，dp[i][1]表示持有股票，前i天的最大利润。 123456dp[0][0] = 0;dp[0][1] = -prices[0];for(int i = 1; i &lt; n; i++)&#123; dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);&#125; 123. 买卖股票的最佳时机 III 限定最多完成两笔交易。 12345678int buy1 = -prices[0], sell1 = 0;int buy2 = -prices[0], sell2 = 0;for(int i = 1; i &lt; n; i++)&#123; buy1 = Math.max(buy1, -prices[i]); sell1 = Math.max(sell1, buy1 + prices[i]); buy2 = Math.max(buy2, sell1 - prices[i]); sell2 = Math.max(sell2, buy2 + prices[i]);&#125; 188. 买卖股票的最佳时机 IV **这几个股票问题里最复杂的一个了吧。上一题的升级版，限定最多完成k笔交易。类似的我们用一系列变量存储【买入】的状态，再用一系列变量存储【卖出】的状态。官解有点难以理解，参考了讨论区的题解。 12345678910int[] buy = new int[k + 1];int[] sell = new int[k + 1];Arrays.fill(buy, -prices[0]);for (int i = 1; i &lt; n; i++) &#123; for (int j = 1; j &lt;= k; j++) &#123; buy[j] = Math.max(buy[j], sell[j - 1] - prices[i]); sell[j] = Math.max(sell[j], buy[j] + prices[i]); &#125;&#125;return sell[k]; 股票问题思路 我们用 buy[i][j]表示对于数组 prices[0..i] 中的价格而言，进行恰好 j 笔交易，并且当前手上持有一支股票，这种情况下的最大利润；用sell[i][j]表示恰好进行 j 笔交易，并且当前手上不持有股票，这种情况下的最大利润。 作者：LeetCode-Solution 309. 最佳买卖股票时机含冷冻期 12345678f[0][0] = -prices[0];//持有股票f[0][1] = 0;//未持有股票，冷冻期f[0][2] = 0;//未持有股票，非冷冻期for(int i = 1; i &lt; n; i++)&#123; f[i][0] = Math.max(f[i - 1][0], f[i -1][2]- prices[i]); f[i][1] = f[i - 1][0] + prices[i]; f[i][2] = Math.max(f[i - 1][2], f[i - 1][1]);&#125; 714. 买卖股票的最佳时机含手续费 和122. 买卖股票的最佳时机 II 的唯一区别在于有咩有手续费。有了前面的基础好写很多。 123456dp[0][0] = 0;//不持有股票dp[0][1] = -prices[0] - fee;//持有股票for(int i = 1; i &lt; n; i++)&#123; dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] -fee);&#125; 记忆化搜索 记忆化搜索=搜索的形式+动态规划的思想。记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划”。 from：记忆化搜索专题]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <url>%2FJAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[c#, Python都是动态语言，可以在运行时改变自身结构。而反射是Java非常重要的动态特性 思考：方法变量化是不是也是一种动态性的体现？ 理解Class类并获取Class类的实例Class的实例就对应一个运行时类 1234567//方式一：调用运行时类的属性：.classsClass clazz1 = Person.class;//方式二：通过运行时类的对象调用getClass()Person p1 = new Person();Class clazz2 = p1.getClass();//方式三：调用Class的静态方法：forName(String classPath)，实际中应用多，体现了反射的动态性Class clazz3 = Class.forname("java.lang.String"); 补充一点，后续学到编译内容是再更新。 类的加载过程 Load=&gt;Link=&gt;Initialize Load:将class文件读入内存，并在堆里为之创建一个java.lang.Class对象。此过程由类加载器完成。 Link:将类的二进制数据合并到JRE中 Initialize: JVM负责对类进行初始化 创建运行时类的对象反射机制应用最多的地方来了！ 创建类的对象：调用Class对象的newInstance()方法 要求类必须有一个无参构造器，类的构造器访问权限要足够。 12Class clazz = Person.class;Person obj = clazz.newInstance(); 没有无参的构造器也可以创建对象，调用类中的指定构造器 123456Class clazz = Class.forName("aa.Java.Person");//获取指定构造器Constructor con = clazz.getDeclaredConstructor(String.class,Integer.class);con.setAccessible(true);//调用此构造器创建运行时类的对象Person p2 = (Person)con.newInstance("Peter",20); 调用运行时类的指定结构调用指定属性123456789Class clazz = Person.class;//创建运行时类的对象Person p = (Person)clazz.newInstance();//获取运行时类中指定变量名的属性Field name = clazz.getDeclaredField("name");//保证当前属性是可访问的name.setAccessible(ture);//设置指定对象的此属性值name.set(p,"name"); 调用指定方法同理实例化class==&gt;找到方法==&gt;调用方法invoke() 使用频率更高。 1234Class clazz = Person.class;Method show = clazz.getDeclaredMethod("show", String.class);show.setAccessible(true);Object returnValue = show.invoke(p, "CHN"); 调用指定构造器已经在创建运行时类的对象部分介绍过。 反射的应用–动态代理补充：静态代理，以设计模式中的工厂模式做例，实际上是多态性的体现。 碎碎念，到处都存在的多态性和解耦合操作。 分别有三个对象，提供一个接口，代理类和被代理类。代理类通过聚合的方式调用接口，被代理类实现接口中的目标方法。从而利用多态特点，代理类调用被代理类实现的目标方法。听起来比较绕口，就举个例子。 12345678910class ProxyClothFactory implements ClothFactory&#123; private ClothFactory factory; public ProxyClothFactory(ClothFactory factory)&#123; this.factory = factory; &#125; @override public void produceCloth()&#123; factory.produceCloth(); &#125;&#125; 动态代理内容有待补充。后续更新。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Endnotes]]></title>
    <url>%2FEndnotes.html</url>
    <content type="text"><![CDATA[最近在整理文献，写一个查找和下载文献的小心得。 ref download首先是下载文献，作为一个科研人，都逃不过读英文文献，除了学校图书馆的资源怎么下载其他文献呢？ 参考知乎回答，感谢答主！ 首先查找文献，翻墙和谷歌学术镜像网站。免费的外皮恩真的香，但是秉持好学的态度改天研究一下自己搭梯子哈哈。 然后是最近发现的宝藏网站，下载神器，文献小镇！强推！ Endnotes接下来下载一时爽，阅读火葬场。面对下载的几十文献真是抓狂，一边是看完就忘，一边是难以分类标记，上学这么多年到现在才学会如何整理文献真是惭愧。 用了Endnotes真是相见恨晚。下载安装和导入文献基本教程都可以参考博客，博主写的很详细。使用了文献管理软件的感觉就是获得了解放，再也不用为文献格式发愁，可以尽情的快乐插入文献了。 我不生产教程，我只是教程的拼接工。 但是目前使用了Endnotes，也有一些问题，中文文献难以识别，没有标签功能。 在整理插入文献的过程中可以一边查看文献一边完善论文内容，提高工作效率。 后续使用其他文献管理软件体验不定期更新。 完。]]></content>
      <categories>
        <category>技术</category>
        <category>论文</category>
        <category>Endnotes</category>
      </categories>
      <tags>
        <tag>endnotes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VISA]]></title>
    <url>%2Fvisa.html</url>
    <content type="text"><![CDATA[最近开始跑老师给的现成软件，记录一下遇到的问题。 首先如何把一个项目跑起来？小白的我快要吐血了。计划之后试试开源项目。 先叨叨两句题外话，太久不用git，上传好像出了点问题。远程仓库和本地仓库地址不一致，上次搞了半天也没弄好，倒是能上传文章了，但还是会报错。过几天有空再搞一下。 技术点本项目主要用了对设备的程控。NI-VISA是美国国家仪器NI公司开发的一种用来与各种仪器总线进行通信的高级应用编程接口。参考博客如何使用VS2010调用visa进行程控，开始！ 下载所以开始在电脑上安装NI提供的库，如果安装失败的话，重新下载安装包下载。安装失败的原因现在也没搞清楚，难道是以前安装labview的注册表没清干净？其中曲折把系统盘误删文件搞坏还修了好久，泪目。可以写个合集了”这些年我遇到过的麻烦“。 回到正题， 文件安装目录：C:\Program Files (x86)\IVI Foundation\VISA\WinNT lib文件位置：C:\Program Files (x86)\IVI Foundation\VISA\WinNT\lib\msc .h文件位置：C:\Program Files (x86)\IVI Foundation\VISA\WinNT\Include 如何添加库到工程中？这里涉及到静态库的使用。之前在课上一知半解，现在终于用到了。参考文章c++静态库与动态库 这里卡了好久，最后采取了文章中提到的方法二： 属性==&gt;配置属性==&gt;链接器==&gt;命令行 输入静态库的完整路径。 之前采用方法三，一直没能导入成功，不知道哪里出了问题，摊手。 属性==&gt;配置属性==&gt;链接器==&gt;常规，附加依赖库目录输入静态库所在的目录 属性==&gt;配置属性==&gt;链接器==&gt;输入，附加依赖库中输入静态库名visa32.lib 此时生成解决方案出现了报错 “LINK:fatal error LNK1104: 无法打开文件‘C：/Program.obj” 解决方案是静态库路径加引号。参见博客 继续报错，无法解析外部符号 参考博客 继续上回分解，发现我整个搞错了。 首先分清楚这几个附加目录分别表示什么。检查发现是添加在C\C++ ==&gt;附加库目录起作用了。 然后解决无法解析外部符号，引用另一个库项目中的实现。完美解决。 完。]]></content>
      <categories>
        <category>技术</category>
        <category>VISA</category>
      </categories>
      <tags>
        <tag>VISA</tag>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯剪枝]]></title>
    <url>%2F%E5%9B%9E%E6%BA%AF.html</url>
    <content type="text"><![CDATA[刚开始刷题大部分都不会，有的题有思路但是代码写不明白，参考了很多官方和评论区大佬的答案，学到了很多。解答用的语言是c++，在边学边用，官方的STL库还不熟悉，菜鸟如我经常搞错vector的用法。 本来打算九月底发的博客拖到了现在(十一月初），十月也没有继续刷题。开始准备做项目不由感叹门外汉入门真是不容易，什么都不会，扶额。 这一个月做过的题类型有，回溯算法加剪枝， 二叉树的遍历和递归， 并查集等等。 2022 用Java重刷一遍，修改了内容。 回溯算法加剪枝一直碰到用回溯算法就歇菜。现在还没有完全掌握。 回溯算符与递归的区别在于，回溯过程中达到结束条件要恢复状态回溯到上一层，再次搜索，而递归是一个劲往某个方向。回溯与DFS的区别就是有无状态的重置。 在题解区看到答主的回答颇有所获，非常感谢。但是实际应用中画出递归树不好理解。 1.DFS 和回溯算法区别DFS 是一个劲的往某一个方向搜索，而回溯算法建立在 DFS 基础之上的，但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。因此回溯算法与 DFS 的区别就是有无状态重置 2.何时使用回溯算法当问题需要 “回头”，以此来查找出所有的解的时候，使用回溯算法。即满足结束条件或者发现不是正确路径的时候(走不通)，要撤销选择，回退到上一个状态，继续尝试，直到找出所有解为止 子集和组合对于这类寻找所有可行解的题都可以用回溯来解决。 78. 子集 补充一点Java的解决方案，思路是一样的。 12345678910public void dfs(int curr, int[] nums)&#123; if(curr == nums.length)&#123; ret.add(new ArrayList&lt;Integer&gt;(path)); return; &#125; path.add(nums[curr]); dfs(curr+1, nums);//选择 path.remove(path.size() - 1); dfs(curr+1, nums);//不选择&#125; 90. 子集 II使用了剪枝。使用了start变量。 参考了官方的答案，递归枚举类题的包括以下几个步骤： 画出递归树（关键 递归边界，记录的条件 设置了vector: temp当前的记录，vector&lt;vector&lt;&gt;&gt;: ret返回所有的记录 判断是否需要剪枝处理 1234sort(nums.begin(), nums.end());if(i &gt; start &amp;&amp; nums[i] == nums[i - 1])&#123; continue;&#125; 组合中可以选择或者不选择当前位置，之后递归考虑下一个位置。 1234temp.push_back(cur);dfs(cur + 1);temp.pop();dfs(cur + 1); （事实告诉我们不要写一半跑路，时隔一个月我已经看不懂之前写的了，趁着快要考试继续做算法总结 递归的解法中，关键在于这句话*，对于当前选择的数curr，若前面有与其相同的数pre，且没有选择pre，此时包含curr的子集，必然会出现在包含pre的所有子集中。 所以设置了一个boolean位判断是否选择了之前同值的数。官解有点费解，本题解借鉴了更易懂的写法。 123456789101112131415public void dfs(int start, int[] nums)&#123; if(start == nums.length)&#123; ret.add(new ArrayList&lt;Integer&gt;(path)); return; &#125; path.add(nums[start]);//选择 dfs(start + 1, nums); path.remove(path.size() - 1);//回溯，不选择 //跳过重复值 while(start &lt; (nums.length - 1) &amp;&amp; nums[start] == nums[start + 1])&#123; start++; &#125; dfs(start + 1, nums); &#125; 组合中配合使用了剪枝来减少时间。 39. 组合总和中传入了target变量。 补充递归解法，选择和不选择，ret和path作为全局变量定义在方法外。 123456789101112131415public void dfs(int[] candidates, int target, int index)&#123; if(index == candidates.length) return; if(target == 0)&#123; ret.add(new ArrayList&lt;Integer&gt;(path)); return; &#125; //不选择 dfs(candidates, target, index + 1); //选择,包含=，因为路径还没加入ret if(target - candidates[index] &gt;= 0 )&#123; path.add(candidates[index]); dfs(candidates, target-candidates[index], index); path.remove(path.size() - 1); &#125; &#125; 组合总和2使用了剪枝。 全排列46. 全排列 Java版本也是一样的思路，设置used数组。这一题是不需要剪枝的，思路比较简单。 47. 全排列 II设置了visited数组。 核心代码如下： 12345678for(int i = 0; i &lt; nums.size(); i++)&#123; if(visited[i] == true) continue; visited[i] = true; temp.push_back(); dfs(); visited[i] = false;//回退 temp.pop_back();&#125; 考虑剪枝处理 12345sort(nums.begin(), nums.end());// i &gt; 0 是为了i - 1 有效if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1])&#123; continue;&#125; Java版本 123456789101112131415161718public void backtrace(int[] nums, boolean[] used)&#123; if(path.size() == nums.length)&#123; ret.add(new ArrayList&lt;Integer&gt;(path)); return; &#125; for(int i = 0; i &lt; nums.length; i++)&#123; if(!used[i])&#123; if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1])&#123; continue; &#125; path.add(nums[i]); used[i] = true; backtrace(nums, used); used[i] = false; path.remove(path.size() - 1); &#125; &#125;&#125; 剑指 Offer 38. 字符串的排列 和全排列的思路几乎一样。在于字符串api的熟练使用。字符串问题一般是转为字符数组来解决。StringBuffer用法 12345678910 StringBuffer path = new StringBuffer(); char[] chars = s.toCharArray(); //List&lt;String&gt;转为String[] String[] ans = new String[ret.size()]; for(int i = 0; i &lt; ret.size(); i++)&#123; ans[i] = ret.get(i); &#125;path.append(chars[i]);path.deleteCharAt(path.length() - 1); 搜索参考博文 37. 解数独 这是道困难，一整个震惊之前居然做过，毫无印象。回溯，标记状态位，不过是比较复杂的情况。行标记，列标记，以及块标记，将空白待添块添加到队列，逐个筛查。 79. 单词搜索 有点类似数独，小tip，可以用 int[][] directions = {/{0, 1}, {0, -1}, {1, 0}, {-1,0}/}; 表示网格的上下左右四个方向，还有一些小细节，越界判断，if(newi &gt;= 0 &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;=0 &amp;&amp; newj &lt; board[0].length)和check结果的if判断，直接return会丢失一些结果。 51. N 皇后 法一，基于集合的回溯剪枝。变量很多，但是思路不变，行优先，逐行填入。有一个难点是怎么确定对角线是否已经被占用，左上到右下的对角线，行坐标-纵坐标的差相等，左下到右上对角线，行坐标+纵坐标的和相等。 基于集合用到了HashSet。难点二生成返回的board结合。 123456789101112131415161718 Set&lt;Integer&gt; columns = new HashSet&lt;&gt;(); Set&lt;Integer&gt; diagonals1 = new HashSet&lt;&gt;(); Set&lt;Integer&gt; diagonals2 = new HashSet&lt;&gt;(); int[] queens = new int[n]; Arrays.fill(queens, -1); backtrack(ret, queens, 0, n, columns, diagonals1, diagonals2);//生成board public List&lt;String&gt; generateBoard(int[] queens, int n)&#123; List&lt;String&gt; board = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; n; ++i)&#123; char[] row = new char[n]; Arrays.fill(row, '.'); row[queens[i]] = 'Q'; board.add(new String(row)); &#125; return board; &#125; 法二 基于位运算的回溯。（待完成 面试题 08.12. 八皇后 就是上一道N皇后本尊。 131. 分割回文串 官解给的是回溯加动态规划预处理，但是本菜鸡还是先用回溯直接做了。重点在于子串。 123456789101112131415161718public void backtrack(String s, int start)&#123; if(start == s.length())&#123; ret.add(new ArrayList&lt;String&gt;(segments)); return; &#125; for( int end = start; end &lt; s.length(); ++end)&#123; String sub = s.substring(start, end + 1);//子串 //剪枝判断 if(!isPalindrome(sub))&#123; continue; &#125; segments.add(sub); backtrack(s, end + 1); segments.remove(segments.size() - 1); &#125;&#125; 93. 复原 IP 地址 和分割回文串应该是一类题。return的情况要考虑全。 401. 二进制手表 递归层次遍历 二叉树层次遍历和层次相关时，可以用queue.size()获取一层的个数，一层一层的处理。如leetcode 637，二叉树层平均值，leetcode 117，层链接 相关于二叉树的题十有八九是递归算法，属于有思路但是写出来的代码总有逻辑错误的题，栈溢出，多半是递归边界问题，还有递归的参数没弄对。 分治]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯算法</tag>
        <tag>二叉树</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[十月间断的学了一些设计模式。这是个长久的课程，还没有学会怎么实际运用到项目中。 跟随着视频来学。 为什么学习设计模式？ 为了让程序具有更好的代码重用性，可读性，可扩展性，可靠性，使程序呈现高内聚，低耦合的特性。 什么时候用到设计模式？ 面向对象（oo）=&gt; 功能模块[设计模式 + 算法（数据结构）] =&gt; 框架[ 多种设计模式 ] =&gt; 架构[ 服务器集群 ] 学习步骤 应用场景 –&gt; 设计模式 –&gt; 剖析原理 –&gt; 分析实现步骤（图解，类图） –&gt; 代码实现 –&gt; 框架或项目源码分析的步骤讲解 设计模式的七大原则设计模式为什么这样设计的原则。 字符流会查码表，字节流不查码表 编码：字符—&gt;码表—&gt;数字 解码：数字—&gt;码表—&gt;字符 Reader默认查询的码表是与操作系统一致的码表，操作系统是中文的，所以reader使用GBK码表 java查的是unicode的码表 1. 单一职责原则 一个类只负责一个职责。 2. 接口隔离原则 使用多个单独的接口。 3. 依赖倒转原则 其核心是面向接口编程（即抽象类）。 4. 迪米特法则（最少知道原则） 体现了封装的思想。可以适当违反。 5. 开闭原则OCP 对扩展开放，对修改关闭。 6. 里氏替换原则 oo中继承的思考。 所有引用基类的地方必须能透明的使用其子类的对象。 使用继承时尽量不要重写父类的方法。 创建一个更加基础的类。使用依赖，聚合，组合的关系。 7. 合成复用原则 尽量使用合成聚合的方式，而不是使用继承。 UML语言介绍统一建模语言。 类图-依赖关系（Dependence）只要在类中用到了对方，他们就存在依赖关系。 类图-泛化关系（generalization），就是继承关系，是依赖关系的特例。 类图-实现关系（Implement），是依赖关系的特例 123456public interface PersonService&#123; public void delete(Interger id);&#125;public class PersonServiceBean implements PersonService&#123; public void delete(Interger id)&#123;&#125;&#125; 类图-关联关系（Association） 类与类之间的联系，是依赖关系的特例。有单向和双向关系。 类图-聚合关系（Aggregation） 整体与部分的关系，整体与部分可以分开。比如Person和IDCard。聚合式关联关系的特例。 类图-组合关系（Composition）也是整体与部分的关系，但是整体与部分不可以分开。例如Person和head。同生共死的关系。 123456public class Person&#123; private IDCard card; private Head head = new head();&#125;public class IDCard&#123;&#125;public class Head&#123;&#125; 创建型模式1. 单例模式主要步骤： 1) 构造器私有化 (防止 new ) 2) 类的内部创建对象 3) 向外暴露一个静态的公共方法 饿汉式 123456789101112class Singleton&#123; //构造器私有化 new private Singleton()&#123; &#125; //本类内部创建对象实例。 private final static Singleton instance = new Singleton(); //提供一公有的静态方法，返回实例对象 public static Singleton getInstance()&#123; return instantce; &#125;&#125; 优缺点：写法简单，在类装载的时候完成实例化，避免了线程同步问题，没有达到懒加载的效果。 可用，但会造成内存的浪费。 双重检查 12345678910111213141516class Singleton&#123; private static volatile Singleton instance;//volatile可以实现立刻写到内存中 //构造器私有化 private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; Double-Check是多线程开发中常使用的。线程安全，延迟加载，效率较高。 静态内部类 123456789101112class Singleton&#123; private static volatile Singleton instance; private Singleton()&#123;&#125; //写一静态内部类 private static class SingletonInstance&#123; private static final Singleton INSTANCE = new Singleton(); &#125; //提供一静态的公有方法，直接返回 SingletonInstance.INSTANCE。 public static Singleton getInstance()&#123; return SingletonInstance.INSTANCE; &#125;&#125; 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。避免了线程不安全，利用静态内部类特点实现延迟加载，效率高。推荐使用。 枚举法 123456enum Singleton&#123; INSTANCE; public void sayOK()&#123; System.out.println("ok"); &#125;&#125; 借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。这种方式是 \Effective** \Java** 作者 \Josh** \Bloch** 提倡的方式.推荐使用 2. 简单工厂模式12345678910111213141516...class FoodFactory&#123; public static Food getFood(int n)&#123; Food food = null; switch(n)&#123; case 1: food = new Hamburger(); break; case 2: food = new RiceNoodle(); break; &#125; return food; &#125;&#125;... 服务器修改了具体产品的类名后，客户端不知道。 工厂的实现不易于扩展，违反了ocp原则，故引入了工厂方法模式。 3. 工厂方法模式1234567891011121314151617181920212223242526272829303132333435interface food&#123; void eat();&#125;class Hamburger implements Food&#123; public void eat()&#123; System.out.println("吃汉堡！"); &#125;&#125;class RiceNoodle implements Food&#123; public void eat()&#123; System.out.println("吃米线！"); &#125;&#125;//食物工厂interface FoodFactory&#123; public Food getFood()&#123;&#125;&#125;class HamburgerFactory implements FoodFactory&#123; public Food getFood()&#123; return new Hamburger(); &#125;&#125;class RiceNoodleFactory implements FoodFactory&#123; public Food getFood()&#123; return new RiceNoodle(); &#125;&#125;public static void main()&#123; FoodFactory ff = new HamburgerFactory(); Food food = ff.getFood(); food.eat(); &#125; 工厂的名字是视为接口的，是趋向稳定的。 但是当种类很多时，会造成类爆炸式增长，于是引入抽象工厂。 4. 抽象工厂12345678910111213141516interface Factory&#123; public Food getFood()&#123;&#125; public Drink getDrink()&#123;&#125; &#125;class KFCFactory implements Factory&#123; public Food getFood()&#123; return new Hamburger(); &#125; public Drink getDrink()&#123; return new Cola(); &#125;&#125;class SanQinFactory implements Factory&#123; ...&#125; 无论有多少产品等级，工厂就一类。 冰箱电视洗衣机视为产品等级，工厂厂家海尔海信华为系列产品视为产品簇。虽然新增一个工厂很便捷，但抽象工厂扩展产品等级需要所有的工厂都修改，用Spring框架解决。 抽象工厂中可以生产多个产品，这多个产品之间必有内在联系。同一个工厂中的产品都属于一个产品簇。 5. 原型模式1234567891011121314151617181920212223242526272829public class Sheep implements Cloneable&#123; private String name; private int age; private String color; //构造器 public Sheep(String name,int age, String color)&#123; this.name = name; this.age = age; this.color = color; &#125; //提供对外的接口 public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; ... //克隆该实例 protected Object clone()&#123; Sheep sheep = null; try&#123; sheep = (Sheep)super.clone();//sheep是object，但是object不一定是sheep &#125;catch(Exception e)&#123; System.out.println(e.getMessage()); &#125; return sheep; &#125;&#125; Java中的Object类是所有类的根类，Object类提供了一个clone()的方法。需要实现clone的java类必须实现一个接口Cloneable，该接口表示该类能复制且有复制的能力。 上例的clone实现使用了默认的clone()，是浅拷贝，要实现深拷贝可以采用重写clone函数或者序列化。 c++可以用拷贝构造函数 123456789101112class ISplitter&#123;public: virtual void split() = 0; virtual ISplitter* clone() = 0;//纯虚函数 virtual ~ISplitter()&#123;&#125;&#125;class BinarySplitter: public ISplitter&#123;public: virtual ISplitter* clone()&#123; return new BinarySplitter(*this); &#125;&#125; 6. 建造者模式建造产品的过程的产品解耦合？ 与工厂模式的区别： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//Productpublic class House&#123; private String baise; private String wall; private String roofed; public String getBaise()&#123; return baise; &#125; public void setBaise()&#123; this.baise = baise; &#125; ...&#125;//抽象建造者public abstract class HouseBuilder&#123; protected House house = new House(); public abstract void buildBasic(); public abstract void buildWall(); public abstract void roofed(); public House buildHouse()&#123; return house; &#125; &#125;public class CommonHouse extends HouseBuilder&#123; public void buildBasic()&#123; System.out.println("普通房子打地基5m"); &#125; public void buildWall()&#123; System.out.println("普通房子打砌墙10cm"); &#125; public void roofed()&#123; System.out.println("普通房子打顶"); &#125;&#125;public class HighHouse extends HouseBuilder&#123; public void buildBasic()&#123; System.out.println("高楼打地基100m"); &#125; public void buildWall()&#123; System.out.println("高楼打砌墙20cm"); &#125; public void roofed()&#123; System.out.println("高楼打顶"); &#125;&#125;...//可扩展房子类型 //建造指挥public class HouseDirector&#123; HouseBuilder houseBuilder = null; //构造器传入houseBuilder public HouseDirector(HouseBuilder houseBuilder)&#123; this.houseBuilder = houseBuilder; &#125; //setter传入houseBuilder public void setHouseBuilder(HouseBuilder houseBuilder)&#123; this.houseBuilder = houseBuilder; &#125; public House constructHouse()&#123; houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); &#125;&#125;//用户public class Client&#123; public static void main()&#123; CommonHouse commonHouse = new CommonHouse(); HouseDirector houseDirector = new HouseDirector(commonHouse); House house = houseDirector.constructHouse(); &#125;&#125; 未完待续…]]></content>
      <categories>
        <category>技术</category>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>设计模式，创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数码人像摄影读书笔记与实战]]></title>
    <url>%2F%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1%E4%B8%8E%E5%90%8E%E6%9C%9F.html</url>
    <content type="text"><![CDATA[人像摄影是摄影门类中难较高的。最近读了《品像–数码人像摄影与后期专业教程》这本书，作者徐阳。介绍了各种摄影技巧，本文就其中的几个点做一个笔记。 上一篇博客记录了风光摄影中的一些专业知识和技巧，关于器材和相机的相关概念类似，不作过多描述。那么直接进入主题。 拍摄技法 摇拍是一种拍摄移动中的被摄体的技法，以摇动镜头的方式跟随被摄体来表现其速度感。 俯拍有利于表现地平面上景物层次、数量、位置等，给人一种辽阔深远的感受。 仰拍有利于突出被摄体高大的气势，能将树这样向上生长的景物在画面上充分展开。仰拍人物时要注意，脸部较胖的尽量不要这样拍。 平摄人物活动的场面，能让人感到平等、亲切。 多次曝光是在一幅胶片或感光器上拍摄几个影像。 人像基本构图同风光摄影的构图有很多相似之处，人物摄影的主体是人，将人放在画面中的什么位置，如何突出人物主体的地位是应该考虑的问题。 构图 井字构图是一个万能的选择。 中央构图可以配合其他的因素增加图片的分量。 对角线构图可以使画面活力大增，可以包含人身体的各个部位。 开放式构图强调画面内外的联系。 留白式构图可以使观者的思维有所联想和延伸，能产生遐想。 双重架构式构图可以使画面产生远近，明暗，虚实等装饰效果。 大景别构图常用在风景优美广阔或大气巍峨的地点来拍摄人像，为避免环境喧宾夺主，可以从环境与人物的虚实、明暗、色彩、质感、动静等的对比达到拍摄意图。 透视构图可以由空间线条聚焦到被摄体。 人像公式化构图人像公式化构图可分为特写、半身、七分身、九分身和全身等构图类型。 特写与半特写对见于影视和妆面的拍摄，以头顶到胸为构图框线，对被摄者要求面容姣好，表现力强。 半身构图以头部至腰胯部为构图框，加入了部分肢体。 七分身构图到膝盖部位上下。九分身构图到脚踝，要求被摄者的小腿部分漂亮。 全身一般为带背景内容的人像照片。 摆姿技巧这部分内容不仅可以在拍摄模特的时候使用，在平常的摆拍中也可以用到，可以说拯救姿势废。 各种姿势站姿、坐姿、躺卧姿、蹲姿、跪姿、趴姿、跳姿、手姿。 一般常见的站姿有S形，三角形和斜线型。在表现坐姿时注意坐下时应尽量虚坐在椅子边缘。 躺卧姿可以非常好的突出女性的柔美曲线，采用躺姿时可以利用手臂的支撑来营造肢体的变化，可采用水平线对角线等构图方法。 跪姿非常适合表现女性妖娆性感的一面。 趴姿中手臂的动作很重要。 跳姿在于拍摄者的抓拍。 疼痛法摆姿虽然疼痛法在美姿中已提出好多年，但是拍摄过程中它还是一个屡试不爽的技巧。可以牙疼、轻度头疼、重度头痛、脖子疼、胸疼、腰疼、肚子疼、腿疼、脚疼，身体尽量避免出现平行或垂直的线条。 背景与人物背景对一幅人像作品的成败起了举足轻重的作用，利用好人物与环境背景的明暗对比，色彩对比，疏密对比，虚实对比，体积对比，曝光对比，动静对比关系等，会有意想不到的效果。 实战有人说摄影是熟练工种，也对，但是再想想，哪种艺术不是熟练工种？ 我常会被摄影技巧打动，但我不太喜欢这个词，我之所以为它所动，是因为真正好的技巧之听命于神秘的内心世界。–戴安·阿勃斯(Diane Arbus) —- 5.27更新 —-在接触了真实的相机之后发现第一次看书时忽略的内容都很重要，在此补上一些重要概念。本次实践使用的相机是佳能700D。半按快门对焦后完全按下快门拍摄。 光线的应用光比，亮部与暗部，光比扩大会增加层次感，轮廓硬朗。可以在亮部测出光圈大小，暗部测出光圈大小。相差1级光圈光比为2：1，相差2级光圈光比为4：1，相差3级光圈光比为8：1.大于8属于大光比。更容易控制高调和低调的照片。硬调和柔调，分别表示亮暗的过度程度。大部分照片硬调更好看。曝光宽容度。利用宽容度有限可以创造出于人眼效果不同的效果。 闪光灯及应用在光线昏暗的环境下拍照，如果使用闪光灯加较快的快门拍摄，容易造成前景主体太亮，而背景依旧昏暗，无法辨别细节。而慢速闪光同步会延迟数码相机的快门释放速度，以闪光灯照明前景，配合慢速快门（如1/15s）为弱光背景曝光。这样就能摄出前后景均得到和谐曝光的照片。 前帘同步闪光是指先闪光，主要用于在光线较暗的时候拍清楚主体。后帘同步闪光主要用于运动的物体拍摄。拍摄时后帘同步开启，快门开启，拉出一串运动的影像，最后闪光灯开启，将主体定格。特殊效果用于表现运动。前后帘在快门速度比较满时比较明显。闪光灯的光会快速的衰减。闪光灯摄影快门不是控制因素。 闪光灯曝光控制闪光灯曝光控制，可以减少或增加闪光补偿来控制。暗光情况使用闪光灯应该适当增加ISO，慢速快门。 使用方法弱光增强；强光补光；增加眼神光；创意闪光。 测光测光分为评价测光，中央重点平均测光和点测光。 中央重点平均测光可以说是人像拍摄独享的测光模式，非常适合画面中央被摄主体亮度均匀而主体周围光线变化较大的场合。 点测光可以精准控制曝光，是针对画面中央极小范围进行测光的模式。 相机的设置 拍摄模式的选择一般情况下对于人像拍摄使用更多的是光圈优先曝光和手动曝光。白平衡放在自动档（配合jpg格式照片），对焦用的更多的是中心点对焦和单次对焦。 测光模式测光方式用中央重点和点测光。因为作为人像拍摄，首先要保证所拍人物的正确曝光。特写的拍摄用局部测光，更精细的拍摄，逆光等使用点测光，光比比较大的场景中用中央重点平均测光。 ISO调整光线允许的情况下设为100或200. ISO一般情况下越低越好。光线较暗，阴天的傍晚可以选择400，室内光线较暗可以选择800，偷拍可以选择1600。感光度越高，照片质量越粗糙。 自动化亮度启动自动亮度优化虽然会拖慢机内处理速度但是拍人像无所谓。 光圈一般镜头会用到的光圈号数为f/2.8~f/22.光圈优先AE是一种在人像和风光摄影中都最常用的自动曝光方式。 曝光如何准确曝光，测光表标尺到零就可以准确曝光。标尺在负的一端时，可以先将光圈缩小，接下来再考虑转动快门。如果标尺在正的一端，光圈增大，接下来转动快门，增快快门速度。快门速度过快时，手很难端稳，可以选择三脚架或者开闪关灯。手动模式M下可以拨动轮盘调节快门，Av+轮盘调节光圈。 拍摄人像时的两种常用镜头 原厂镜头和副厂镜头副厂镜头有些品质不输原厂，而且价格比原厂便宜。 变焦镜头和定焦镜头24~70mm或24~120mm属于标准变焦镜，70~200mm或70~300mm属于望远变焦镜。50mm、85mm和135mm属于定焦镜头，这些镜头都可以用来拍摄人像。长焦端的镜头景深浅。初学者可以优先使用中望远镜头入手。 夜间拍摄 夜景采用广角镜头摄影，风光摄影。拍摄地点多为俯拍，增加画面中的信息量。夜景广角镜头是一个较好的镜头，感光度ISO应尽量低，快门速度慢（无法手端），产生了长时间曝光。利用三脚架取景，辅助使用快门线实现闭门。降噪功能设为自动时在镜头速度较慢的时候打开。白平衡设置5500以上色温，低色温显示冷调，也可以直接设置为钨丝灯模式。对焦选择单次对焦。面对白纸时会对焦失败，采用手动对焦，拨动对焦环即可。建议使用平均测光。建议使用小光圈，让光源表现出星芒。小光圈8 11 16等成像质量会更好。如果拍摄的不是大场景可以使用大光圈。夜景摄影没有苛刻的曝光要求。拍摄夜景避免大光源入镜。 拍摄夜景人像使用快门优先，慢速快门可以拍背景，前景由闪光灯照亮。焦距短一点，光圈收小一些。ISO可以使用400~800， 稍大的F4、F2.8的光圈。找到合适的快门，在此快门基础上减少一道两级的曝光。白平衡模式使用闪光灯，设置后帘同步。要搞清楚闪光灯的范围，不超过5m。快门最好用脚架。拍摄人像可以采用中长焦。85mm以上。]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
        <category>人像摄影</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>人像摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[风光摄影读书笔记]]></title>
    <url>%2F%E9%A3%8E%E5%85%89%E6%91%84%E5%BD%B1.html</url>
    <content type="text"><![CDATA[Everything you need to know about landscape photography techniques and subjects.一直都很想学习摄影，虽然没有专业器材，但用手机镜头记录下生活的点点滴滴也是一件美好的事情。正值毕业季，为了在校园拍出美美的回忆，去图书馆补充了一下专业知识《风光摄影圣经》。本篇博客作为一个风光摄影的读书笔记。 风光摄影的前期准备在进行摄影之前需要先对摄影的器材和名词了解一下。 相机相关概念风光摄影要求照片的暗部细节有很好的表现，意味着相机要有较高的色彩宽容度和分辨率。 镜头的分类 广角镜头分两种，普通广角镜头焦距一般在24~38mm，超广角镜头的焦距为13~24mm。广角镜头景深比较大，可以有效的夸张前景和表现景物的远近层次。 标准镜头是与人眼的视角相近的镜头，国际标准为50mm。一般用于空中拍摄，或者近距离风光拍摄和中景特写。 长焦镜头通常焦距在70~400mm之间。长焦镜头可以将远处的景物拉近拍摄，产生空间压缩的效果，还可以作为特写镜头。 变焦镜头的画质要略逊色于定焦镜头。镜头的分类在使用AE搭建场景的时候已经初步接触，在这里再次遇到做个整理。贴上AE中运用摄像机做的镜头模仿练习。 光圈和景深 光圈是相机上用来控制镜头孔径大小的部件。光圈f值=镜头的焦距/镜头口径的直径。光圈f值越小，在同一单位时间内的进光量便越多，而且上一级的进光量刚好比下一级的多一倍。利用小光圈可以获得大景深。在风光摄影中，中景，全景，远景等景别适合用小光圈拍摄增加纵深感。 景深是焦点前后的一段能清晰显示的景物的清晰度范围。拍摄花和昆虫的照片中将背景拍的很模糊为小景深，将背景与被摄主体拍的一样清晰为大景深。影响景深的因为有光圈，焦距和物距三大方面。景深的使用，在3d建模的过程中接触过，保留模型的景深导入AE进行后期处理，可以营造很好的空间效果。 不同的快门低速快门可以虚化动体，制造出虚实相衬的效果，将画面拍出动感，比如烟雾缭绕的感觉。而高速快门可以凝固动体，可以清晰的记录快速运动中的物体，高速快门的应用在于时机的捕捉。下图为低速快门图，图源网络。第一次见到低速快门拍照的照片，真实的仙境感。 取景拍摄可以根据景物的特点选择横画幅和竖画幅，拍照时将手机持平，使照片内的地平线水平，给人以平稳安定的感觉，一般忌讳将地平线居中。照片要吸引观众的视线，给人留下深刻印象，这就要画面的趣味点，我们可以用前景的物体使得普通的风光照片更有趣味性。不同的景别： 近景所展现的主体细节更丰富。中景经常记录我们眼前发生的事物，常常以动作或情节取胜。全景可以完整的表现主体的形体及周遭环境。远景画面开阔，景深悠远。 用光与构图光影变换塑造了不同风格的画面，是拍照中不可忽略的因素，虽然影子影响画面的美观，但是用好影子也会有意想不到的效果。 光线 顺光拍摄给人明亮晴朗的感觉。 侧光拍摄可以产生具有明显方向性的投影，具有非常好的造型效果。前侧光使画面更加丰富；正侧光是的画面有一个非常明显的过渡，除了拍摄要求显示凹凸明显的碑刻等物体外，很少使用；后侧光多用于艺术创作，纵深感强。 逆光塑造独特的效果。拍摄透明，半透明的物体逆光为最佳光线。 眩光在光线和拍摄主题合适时，只要曝光合适，再结合良好的构图和被摄主体，往往会得到神奇的戏剧化效果。 构图巧妙的构图是一种艺术，是一种美学概念。 总感觉自己拍出来的照片很难看，原来是从来没有注意过构图，一直都是凭感觉瞎拍，学了构图以后也可以实践一番了。构图不仅在拍照中会用到，画画和搭建场景中都会用到。 经典的三分法即黄金分割法。 S形构图动感效果强，既动又稳。远景俯拍效果最佳，适合山川河流的自然起伏和人体动物物体的曲线排列变化。 A形构图具有向上的冲击力和强劲的视觉引导力。适合拍摄眼神的长路，长桥和高耸的建筑物。 O形构图稳定感强。 斜线构图能形成深度空间，使画面具有活力，还能形成指向性，同时给人以三位空间感。溪流、铁轨、小路、围栏、墙壁、篱笆、电线以及远景中的道路桥梁都可以做斜线。 对角线构图，具有方向感，动感和活泼。线条汇聚，吸引人们的视线。 曲线构图。 稳定的三角形构图。 漂亮的放射形构图，常用于要突出主体，而场面又复杂的场合。 突出主体的框架式构图，一般用于有前景的拍摄， 比如利用门窗，山洞口，其他框架作为前景。本文没能加入很多的图片说明，这里有前人的构图总结。希望在今后的拍照运用中逐渐实践学到的方法，创建属于自己的作品图库。 色彩探索不同的色彩能使人产生不同的官能感觉。暖色调使人感到热烈兴奋，冷色调使人感到优雅，宁静。在摄影中如何搭配色彩构成画面，什么样的色彩搭配在一起更加漂亮，这是每个摄影人必须学会的理论知识。色彩之间的搭配主要有富有烘托效果的同类色(45deg)，具有表现效果的互补色(150~180deg)，效果和谐的相邻色(90deg以内)，突出主体的对比色(对比形式多样，有冷暖，补色，明暗的对比。红与绿，蓝与黄石互补色。)等几个分类。 有时会觉得拍照就是一个高级的绘画过程，逼真的展现事物的原貌，同样考虑到了构图，光影，色彩，可以说艺术是相通的吧。读书笔记中有很多没有记录到的内容，比如测光与曝光，焦点的选择，滤镜的选择。这本书后几章的拍摄实践包括山水美景，冰雪云雾和日月星辰，提供了很多实用的拍摄tips，但是技巧都是在实践中磨练的，就不在这里记录了。等上手实践之后再来更新。 参考书籍：风光摄影圣经 –创造影像]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
        <category>风光摄影</category>
      </categories>
      <tags>
        <tag>风光摄影</tag>
        <tag>镜头</tag>
        <tag>构图</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客初体验]]></title>
    <url>%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%88%9D%E4%BD%93%E9%AA%8C.html</url>
    <content type="text"><![CDATA[Welcome to my blog.This is my very first post.折腾了好几天hexo配合github搭建博客成功，需要优化的还有很多，需要学习的技能也好多。建博客的过程中，遇到了好多问题，看教程的时候仿佛大家都水到渠成，只有我和成功之间隔着千山万水。ORZ记录一下遇到的问题和解决方法。 hexo+github搭建博客雏形首先感谢打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化手把手教程。 题外话之修改hosts访问google首先翻墙是一项必备技能，根据老D博客里的步骤替换hosts，出现了一些问题，目前仍然没能找到翻墙的正确姿势。 hostipconfig/flushdns 无法使用：查找后可以通过设置path解决。 出现了谷歌学术搜索页面，但是搜索会显示“请进行人机身份验证”。 前奏之安装node.js和git教程里很清楚了，不再赘述。安装之后用下述代码查看是否安装成功：12$ git --version$ node -v &lt;更新2022/3/20&gt; 建议先安装nvm方便切换node版本。 nvm use 切换版本没反应。表现症状为nvm use没有创建新的node.js快捷方式。重装了nvm解决了。 装nvm步骤 下载nvm，github太不稳定了，下载不了，感谢博主的百度云链接，然后参照文章进行安装，几个注意点：文件夹名不要出现 中文 和 空格；在运行nvm install 的时候，有可能会出现无权限安装的问题，如果遇到此问题，请 以管理员身份运行 cmd。 在nvm安装目录，找到 setting.txt用记事本打开添加如下两行： 12node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ nvm安装npm失败的解决方法： 手动去安装，下载地址， 自己下载node对应的npm版本 解压后将文件夹重命名为npm并复制到node_modules目录下 最后将npm中bin目录下的npm以及npm.cmd复制到与node_modules目录同级目录下 接着就可以优雅切换node版本了 全局npm重装了nvm也打算重装一下其他插件。但是切换node版本时需要重装cnpm和hexo，参考博客，设置全局npm方便不同版本公用。 修改全局安装路径和cache路径 12345npm prefix -g npm config get cachenpm config set prefix &quot;E:\Users\pcc\AppData\Roaming\nvm\npm_global&quot;npm config set cache &quot;E:\Users\pcc\AppData\Roaming\nvm\npm_cache&quot; 将npm包全局安装路径配置在环境变量中 npm_global hexo的安装与本地配置 安装npm npm install -g cnpm --registry=https://registry.npm.taobao.org 安装hexo cnpm install -g hexo-cli 做好前期准备开始安装hexo，血泪史，因为版本问题导致的惨剧，是谁说的warn信息都不用管的。 报错：local hexo not found in xxx:在网上各种搜索，删除项目中的package.json,执行npm init生成新的package.json替换，虽然不再报错，但是出现了新问题。 返回usage信息，hexo命令干脆不能用了，倒腾一晚上，git和nodejs确实装好了，也不是运行命令的目录不正确，最后考虑是环境变量问题。直到第二天重装node.js，确认问题是node.js版本过低所致。 部署到github出错 上传blog时的错误 [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Object， 参考博客报错原因是node版本过高。因为前段时间使用vue修改了node版本为14.16.0。修改为原来的版本v10.15.3 出错提示： fatal:Could not read from remote repository 原因是站点配置文件的网站写错了，参考文章。大费周章困扰好久。 错误： fatal: unable to access &#39;https://github.com…\&#39;: Empty reply from server 解决方法： git config --global --unset http.proxy 参考文章 OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 FATAL Something&#39;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html 1234git config --global --unset http.proxygit config --global --unset https.proxyenv GIT_SSL_NO_VERIFY=true hexo d 发文至此，终于在建好了博客雏形，看到网页的时候感动哭。先发文看看。 编辑博文并发表markdown是一种标记性语言，第一次接触也可以上手很快。新手速成看这里 中文乱码：多半是编码问题，换个编码方式编辑。使用UTF-8编码方式，成功解决。 如何更新博客： 12345$ hexo new "Hello world"$ hexo clean$ hexo g -d$ hexo s 网易云音乐产生外部链接http://link.hhtjim.com/163/xxx.mp3 将歌曲链接的对应id替换xxx位置即可安装插件aplayer之后插入博客中见下图： var ap = new APlayer({ element: document.getElementById("aplayer-sJFqBfRr"), narrow: false, autoplay: false, showlrc: false, music: { title: "Hit and Run", author: "Lolo", url: "https://link.hhtjim.com/163/28987151.mp3", pic: "https://i.loli.net/2019/05/09/5cd41d6fa31f5.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 插入图片七牛云倒腾半天，发现提供的免费域名只能用30天， 为了图片不失效，只能买自己的域名。目前由于懒就用了在线图床SM.MS。这里有关于图床的一些介绍。 副本之博客优化光秃秃的博客是没有灵魂的，接下来可以开始装装点点，开始幸福生活啦。 一个好的博客既要有好的内容，也要有漂亮的外在，门面嘛，既然要经营就要从内到外到经营好，于是开启了副本之漫长的优化之路。先写到这里，优化虽然跟着教程做了一些有了一些理解，等补一些之后再来更新。 未完待续~ 2021/06/01 时间一晃，博客优化还是没做哈哈哈，瞎折腾太累了。补充一下以前存的教程贴。 hexo搭建博客篇基于Hexo+Github+Coding搭建个人博客-基础篇 基于Hexo+Github+Coding搭建个人博客-进阶篇 博主整理的还是挺清楚的。很久之前参照进阶篇进行了搜索引擎优化，好像也没有用到，依旧是没人看的小博客orz。 Google Analytics教程,谷歌分析使用方法教程 突然发现适配手机端的教程挂掉了，啊.. 界面美化篇Hexo 博客优化之实用功能添加系列 Hexo 博客优化之博客美化系列 Hexo 博客添加各种有趣又有用的小功能 评论篇评论之前是用着valine，但是由于leancloud要求实名认证，不能用了，好吧，就很久没评论区了。 为你的Hexo加上评论系统-Valine gitment也试过，不知道什么问题不能用，人懒，先算了吧，反正也不会有人评论的。 Hexo-Next 添加 Gitment 评论系统 先这样吧]]></content>
      <categories>
        <category>技术</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hosts</tag>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
