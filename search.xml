<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2021总结]]></title>
    <url>%2F2021%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[2021的最后一天了，年度总结来啦！ 跨年是在实验室和宿舍度过的，但是是在摸鱼啦。 今年还算是努力学习的一年，虽然也时而摸鱼丧气，但还是一步步进步了很多。上半年在写论文，虽然发不发还是问题，但是学会了用latex，学会了用endnote整理文献，下半年再学框架和做项目，学习了数据库基础，SSM框架，SpringBoot框架，尝试了运行开源项目，从黑马旅游网的简单制作到mall的开源项目，研究了老师给的车联网项目，也在此基础上做自己的项目。最近在学习linux。心血来潮也会刷刷leetcode，虽然通常坚持不了几天。刷题其实还是挺费时间的。大热门的深度学习也想涉及一点，总之就是东一脚西一脚，深深浅浅摸石头过河。 跨专业真的是很痛苦的一件事，虽然做好了补基础的准备，但把位置摆在一群科班堆里的时候，还是感受到了不小的差距，仿佛在经历科班的本科生活。又说到丧气的事了，以此为理由而接受差距放任自己是绝对不可能的，新一年也要加油要努力。现在已经很少提自己以前的专业了，还是希望把现在的位置摆在CSer，一个菜鸟CSer努力进化的路。 研究生生活更多的是在自学，老师给的只是课题和资源，因为专业领域的问题，导师实际上能帮助的很少，时常在困惑自己的毕业和就业问题。焦虑并不能解决问题，所以不如学习技术，充实自己。 新年期待的话希望能找到好的实习，好的就业，继续好好写博客，好好生活。 未来的路还很长，拭目以待。]]></content>
      <categories>
        <category>生活</category>
        <category>岁岁念</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[car2car项目运行实录]]></title>
    <url>%2Fcar2car%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E5%AE%9E%E5%BD%95.html</url>
    <content type="text"><![CDATA[在尝试做项目，说是课题也不像课题，老师给的权限很宽，那就按我的想法来尝试，因此记录一下尝试的过程和途中遇到的bug… car2car本来是打算在原项目的基础上做的，所以最开始选择了导入jar包然后添加到项目中。jar包的下载就是度娘。然后导入项目。 本项目用到了以下几个额外的jar包 POI： 读取excel数据 net.sf.json.JSONObject：转换beans，maps，collections, java arrays, xml等为JSON对象和反转换的java库 Gson是Google提供的用来在Java对象和JSON数据之间映射的JAVA类库 commons.fileupload.jar为web应用程序或者servlet提供文件上传功能。 IDEA项目导入jar包的方法有两个 File –&gt; Project Structure-&gt;Modules-&gt;Dependencies，点绿色的加号导入 需要导入的Jar包上，点击右键，选择Add as Library… 如何判断什么时候需要抓异常。 amap的使用方法 sessionStorage对象 GPS所获取的信息 修改为maven项目但是导jar包配置各种东西真的太麻烦了，于是决定用maven管理老项目，pom.xml配置真香。 打包成maven项目 .classpath 文件：指定了源文件位置，con容器为JRE，编译输出位置。指定了java项目在逻辑结构与文件系统的物理结构之间的对应关系。 右键选择 JavaDemo（项目名称），选择“Configure –&gt; Convert to Maven Project”， 填写“Group ID”和“Artifact Id”都为“JavaDemo” 完成pom.xml的修改—复制了一部分itheima的项目配置 参照标准的目录结构修修补补总算是弄好了 部署在tomcat上 报错：org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Tomcat]....搜索了好几个回答，发现相似点是jar包问题，就试着删除web目录下的lib目录，证实报错原因是jar包的重复，问题解决。 原来的项目编码是gbk的，编译出错。为了方便改为UTF-8，可以使用批量处理脚本，完美解决 报错2：Skipping non-war project tomcat没有启动，无tomcat日志信息，解决方法： 1234&lt;groupId&gt;com.itheima&lt;/groupId&gt;&lt;artifactId&gt;maven_web&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt; &lt;!--加这一句--&gt; 到这里为止，终于部署到tomcat成功，但是页面乱码了，不要紧，肯定是编码问题。 报错3：Servlet不能正常访问，论版本兼容的重要性。tomcat各版本的兼容，其实是在运行其他项目时遇到的问题，一并归纳。 数据库设计 编码问题解决好了，那就进入数据库的连接。原本的数据库与前端页面的交互代码写得比较繁杂，这里可以优化为采用数据库连接池和Spring框架提供的JDBCTemplate来进行优化。 数据库的设计方面，数值范围是一个讨论问题。 报错：运行tomcat时无法连接到数据库，本地测试和连接其他的项目都可以，唯独这个项目不可以。尝试了给数据库更高的权限，尝试了改密码，都没有解决。啊卡了好久，解决无果。 本地测试了jdbc工具类和连接池工具类都没有问题。 优化注解注入，简化web.xml的配置 了解已知代码的逻辑实现和已有的功能。 功能设计 文献查询，聚类分析的基本方式和基于LoRa的应用 选取合适的模型进行坐标点的分类 编写逻辑代码 修改项目框架为Springboot新建一个模块module数据库连接 一边学一边做，首先使用之前新建的数据库，采用新学Mybatis框架 编写实体类 domain.User/domain.Data 编写dao接口 UserMapper/DataMapper 测试 数据库设计的三大范式 导入静态资源和页面​ 静态资源放在static.asserts下面，页面放置在templates下 无法加载样式—莫名其妙又可以加载了 代替jsp使用Thymeleaf ,不是前后端分离的。 前后端分离都提到了解决跨域问题，所以什么事跨域问题？nginx是什么？如何使用redis？参考1 用json和ajax实现前后端分离—-原项目就是采用了前后端分离的做法，所以正好保留 实现登录功能(伪)视图映射的优化 如何在最大化保留原有代码的情况下，实现项目运行？ 使用SpringMVC的话就直接砍掉了servlet，使用Contoller替换掉servlet，SpringMVC嵌入了自动的json转换，只需要加一个@ResponseBody 反正折腾了半天是可以实现登录成功了，但是跳转了wmap.html页面。 添加了lombokLombok表达式—面向函数编程 参考1 2 MybatisGenerator使用Mybatis Generator可以快速根据数据库中已经建立好的表来创建mybatis代码 发生错误，The specified target project directory mall-tiny-01\src\main\resources does not exist 路径不对，参考博客解决，查看edit configuration拼接路径 生成的文件到了另一模块上，果然还是路径错了 未报错但是没有产生文件，参考博客修改路径中的\为/，成功生成文件 报错 Column id, specified as an identity column in does not exist in the table. 参考博客解决，在生成器的配置文件里的数据库连接地址中添加: nullCatalogMeansCurrent=true 路径追加问题 参考博客 参考博客1–详细介绍了generator 参考2步骤详细。 使用@MapperScan注解扫描多个包，参考 启动项目异常，Result Maps collection already contains value for，原因是Mybatis gennerator生成xml，但是如果同名xml之前已经存在，那么生成的时候会在xml里面在之前的代码后面继续追加，而不会覆盖同名的语句。因此有可能报这个错误。如果是再次生成代码，必须先将已经生成的代码删除，仔细检查一下xml文件看是否存在两个id为BaseResultMap的resultMap，删除多余的，只保留一个就可以解决问题。参考博客 Swagger-UI 使用步骤 添加项目依赖 添加Swagger2Config配置类 给Controller加注解 启动项目，线上观看结果 http://localhost:8080/swagger-ui.html。 报错： Plugin &#39;org.springframework.boot:spring-boot-maven-plugin:&#39; not found 解释最清楚的博客，解决方法是添加版本号 spring-boot-maven-plugin没有设置version，它会先去远程仓库找最新的版本，然后download到本地，然后完成maven操作等。但是远程仓库里没有相应的jar包，导致执行maven编译出错。因为远程仓库里已经有了最新版本的路径，它就不会使用已经存在的版本。 CommentGenerator自定义注释生成中，org.mybatis.generator.api.dom.java.CompilationUnit;中方法解析失败，Cannot resolve method &#39;isJavaInterface&#39; in &#39;CompilationUnit&#39; 果真是版本问题，Mybatis generator的版本由1.4.0改为1.3.7就好了。本菜鸡一个个试出来的，不知道有没有更好的方法。 项目启动出错，Failed to start bean &#39;documentationPluginsBootstrapper&#39;; nested exception is java.lang.NullPointerException 据说是版本号的冲突，心累，未解决，把Swagger-UI和MybatisGenerator都删了，然后回到开始实现登录功能哈哈哈哈我又回来了，Springboot版本号改成了2.1.3.RELEASE，原来用的2.6.1，感谢博主的提供的思路。 逆向工程 The server time zone value &#39;???ú±ê×??±??&#39; is unrecognized or represents more than one time zone. 数据库和系统时区差异所造成的，解决方法加serverTimezone=GMT%2B8，参考博客 总之成功了^w^ 修改Mybatis Generator注释生成规则—-待解决 CommentGenerator为MyBatis Generator的自定义注释生成器，修改addFieldComment方法使其生成Swagger的@ApiModelProperty注解来取代原来的方法注释，添加addJavaFileComment方法，使其能在import中导入@ApiModelProperty，否则需要手动导入该类，在需要生成大量实体类时，是一件非常麻烦的事。 SpringSecurity+JWT登录控制学习了新项目有了新的想法，使用SpringSecurity实现登录功能。 实现登录功能有的几个方式：参考1，参考2 传统的Session认证方式http协议本身是一种无状态的协议，也就是每发起一次请求就要进行一次用户密码验证。因此我们在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送应用，应用就能识别请求来自哪个用户了，这就是传统的基于session认证。 总的来说登录验证就一下几步： 获取用户信息 调用service查询user 判断用户是否存在：有（存到Session，并跳转首页） 否（跳转到登录页面） 123456789101112131415161718192021222324//吐槽一下老旧的代码，甚至逻辑也不太清晰protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession(); response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); //从请求中获取用户名和密码 String name=request.getParameter("username"); String password=request.getParameter("password"); //设置session信息 session.setAttribute("name", name); //获取用户 UserDao ud=DaoFactory.getInstance().getUserDao(); JSONObject jsondata = new JSONObject(); //获取用户等级---查询user jsondata=ud.getGrade(name, password); //判断用户是否存在 if(jsondata.getString("grade") !="0")&#123; out.write(jsondata.toString()); &#125;else&#123; request.setAttribute("msg", "您的用户名和密码不正确"); request.getRequestDispatcher("/login.html").forward(request,response); &#125; out.write(jsondata.toString());&#125; 通常认证的记录被保存在内存中，传统的方式存在服务器开销大，扩展性差等问题。 基于token控制也是无状态的，但是它不需要在服务端去保留用户的认证信息或者会话信息。流程上是这样的： 用户使用用户名密码来请求服务器 服务器进行验证用户的信息 服务器通过验证发送给用户一个token 客户端存储token，并在每次请求时附送上这个token值 服务端验证token值，并返回数据 这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。 以上分析参考自文章什么是JWT 配合本篇博客Spring Security-安全管理框架，更好的进行验证。 实现Springboot使用pagehelper pagehelper的使用方法有两种，集成成功。 错误：SpringBoot单元测试使用@Test没有run方法的问题 参考 因为改成了2.1.7.RELEASE，版本不同，项目的结构也不同。测试方法的public没了。然后改回了2.6.0.版本，但是仍然有问题。pagehelper循环依赖的问题。项目启动不了，我版本又改回了2.5.6，会标红但是可以运行。 引发了新问题，需要登陆才能查看swagger文档，但是登录密码错误，待解决，好像知道原因了，是因为添加了security和token，虽然还没有集成完全。 继续完成security—-需要更改数据库 因为需要自定义 UserDetailsService:SpringSecurity定义的核心接口，用于根据用户名获取用户信息，需要自行实现； UserDetails：SpringSecurity定义用于封装用户信息的类（主要是用户信息和权限），需要自行实现； 设计数据库—用MybatisGenerator生成model和mapper—完成service—controller SpringSecurity的核心类Spring Security 使用、实现权限访问控制 Spring Security的GrantedAuthority（已授予的权限） UserDetails用户详情： 123456789public interface UserDetails extends Serializable &#123; Collection&lt;? extends GrantedAuthority&gt; getAuthorities();//权限 String getPassword(); //密码 String getUsername(); //用户名 boolean isAccountNonExpired(); //账号是否未过期 boolean isAccountNonLocked(); //账号是否未锁定 boolean isCredentialsNonExpired();//密码是否未过期 boolean isEnabled(); //是否激活&#125; Hibernate-validator校验框架（待添加）使用教程 角色权限 错误：Could not resolve placeholder &#39;jwt.secret&#39; in value &quot;${jwt.secret}&quot; 忘记配置了 获取权限列表，因为我的项目是简化版本的权限只需要，mall项目是四表联查找到权限封装为Permission对象，Security究竟是如何读取权限的呢 123456789public final class SimpleGrantedAuthority implements GrantedAuthority &#123; private static final long serialVersionUID = 510L; private final String role; public SimpleGrantedAuthority(String role) &#123; Assert.hasText(role, "A granted authority textual representation is required"); this.role = role; &#125;&#125; 使用Swagger测试接口时一直没反应，后来发现是Swagger配置类没有增加登录认证功能 错误：Encoded password does not look like BCrypt 密码的加密方式不对，找到原因了，数据库取出的代码是未加密的，而mall的项目中数据库存的密码是加过密的，偷个懒先把他的密码拷贝过来试试。 茅塞顿开，救命我会用debug了，找寻一个项目的运行逻辑可以打断点一步步运行。（迟来的领悟，其实之前看视频看到过） 错误：java.lang.String is in module java.base of loader &#39;bootstrap&#39;; com.tsuki.cartocar.mbg.model.UserInfo is in unnamed module of loader &#39;app&#39;类型转换错误 123456//AdminUserDetails，仍旧是权限定义错误@Overridepublic Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; //返回当前用户的权限 return null;&#125; 参考了博客 List&lt;? extends Number&gt; 定义了泛型的上界是 Number, 即 List 中包含的元素类型是 Number 及其子类. 而 List&lt;? super Number&gt; 定义了泛型的下界, 即 List 中包含的是 Number 及其父类. permissionlist.stream() Stream API的聚合使用 获取权限的修改主要在三个文件，UserServiceImpl.java &amp; SecurityConfig.java &amp; AdminUserDetails.java &amp; UserController.java 123456789101112131415161718192021222324252627282930313233343536373839//UserController @ApiOperation("获取用户所有权限（包括+-权限）") @RequestMapping(value = "/permission/&#123;userId&#125;", method = RequestMethod.GET) @ResponseBody public CommonResult&lt;List&lt;UserInfo&gt;&gt; getPermissionList(@PathVariable String userId) &#123; UserInfo userInfo = userInfoMapper.selectByPrimaryKey(userId); List&lt;UserInfo&gt; permissionList = userService.getPermissionList(userInfo); return CommonResult.success(permissionList); &#125;//UserServiceImpl @Override public List&lt;UserInfo&gt; getPermissionList(UserInfo userInfo) &#123; List&lt;UserInfo&gt; permission = new ArrayList(); //String roleId = userInfo.getRoleId(); permission.add(userInfo); return permission; &#125;//SecurityConfig @Bean public UserDetailsService userDetailsService() &#123; //获取登录用户信息 return username -&gt; &#123; UserInfo userInfo = userService.getUserByUsername(username); if (userInfo != null) &#123; List&lt;UserInfo&gt; permissionList = userService.getPermissionList(userInfo); return new AdminUserDetails(userInfo,permissionList); &#125; throw new UsernameNotFoundException("用户名或密码错误"); &#125;; &#125;//AdminUserDetails @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; //返回当前用户的权限 return permissionList.stream() .filter(permission -&gt; permission.getRoleId()!=null) .map(permission -&gt;new SimpleGrantedAuthority(userInfo.getRoleId())) .collect(Collectors.toList()); &#125; 错误：org.springframework.web.bind.MissingPathVariableException: Required URI template variable &#39;userId&#39; for method parameter type String is not present 主要是自己对注解的理解不清楚导致的，@PathVariable请求路径名称写错了。 自定义UserDetails实现用户登录访问 – 从数据库读取数据实现用户登录访问 错误：java.sql.SQLException: Field &#39;id&#39; doesn&#39;t have a default value 是因为MybatisGenerator生成的Mapper.xml中插入默认主键是自增的从而不插入主键，而我的不是。暂时的解决方式是修改主键为自增，参考博客也并没有解决。主键自增要求键值为int类型。都要改。。所以修改mapper中的insert方法，添加插入主键，成功！ 123456789&lt;insert id="insert" parameterType="com.tsuki.cartocar.mbg.model.UserInfo"&gt; &lt;selectKey keyProperty="id" order="AFTER" resultType="java.lang.String"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; insert into user_info (id, username, password, role_id, devID) values (#&#123;id, jdbcType=VARCHAR&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;roleId,jdbcType=VARCHAR&#125;, #&#123;devid,jdbcType=VARCHAR&#125;)&lt;/insert&gt; 到目前为止，用户的登录注册就完成了！大功告成！]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>项目</category>
        <category>cart</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis]]></title>
    <url>%2FMyBatis.html</url>
    <content type="text"><![CDATA[系列三来了…这次是Mybatis 写此系列的目的是做一个学习笔记管理，方便以后复习用。 快速入门 添加坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.26&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt; 创建数据表 编写实体类 编写dao接口 mapper 编写映射文件UserMapper dtd的约束头参考 编写核心配置文件SqlMapConfig.xml 编写测试类 增删改查 1234sqlSession.selectList("userMapper.findAll");sqlSession.insert("userMapper.add", user);sqlSession.update("userMapper.update", user);sqlSession.delete("userMapper.delete", 3); 核心配置文件 SqlMapConfig.xml emvironments—数据库环境的配置，指定事务管理类型和数据源 transactionManager: JDBC, MANAGED dataSource: POOLED , JNDI, UNPOOLED mappers—加载映射文件 userMapper.xml properties—加载外部properties文件 typeAliases—定义别名 typeHandlers—配置自定义类型处理器 处理日期转换为例 定义转换类继承类BaseTypeHandler&lt;&gt; 覆盖4个未实现的方法 在核心配置文件SqlMapConfig.xml中进行配置 测试 12345678910111213141516171819public class DateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; @Override //将java类型转换为数据库需要的类型 public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType jdbcType) throws SQLException &#123; long time = date.getTime(); preparedStatement.setLong(i, time); &#125; @Override //以下三个将数据库类型转换为java类型 //String是要转换的字段名称 //resultSet查询出的结果集 public Date getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; long aLong = resultSet.getLong(s); Date date = new Date(aLong); return date; &#125; ...&#125; 1234&lt;!--自定义注册类型处理器--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler="com.tsuki.handler.DateTypeHandler"/&gt;&lt;/typeHandlers&gt; plugins 扩展功能 – PageHelper，第三方插件进行功能扩展 步骤 导入通用的PageHelper坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;4.2&lt;/version&gt;&lt;/dependency&gt; 在核心配置文件中配置PageHelper插件 123456&lt;!--配置分页助手插件--&gt;&lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageHelper"&gt; &lt;property name="dialect" value="mysql"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 测试 PageHelper.startPage(1, 2); 相应api(单元测试用) SqlSessionFactoryBuilder SqlSessionFactory: openSession() or openSession(boolean autoCommit) 可以设置自动提交事务 SqlSession，增删改查 Dao层实现 传统方式 代理开发方式 区别就是需不需要手动实现接口 sqlSession.getMapper(UserMapper.class); 要保持四个一致：映射文件中的mapper的namespace要是interface的全包名，id和方法名一致，parameterType和形参类型一致，resultType和返回值类型一致。 映射配置文件深入1. 常用标签&lt;select&gt; &lt;insert&gt; &lt;update&gt; &lt;delete&gt; 1234567891011&lt;mapper namespace="com.tsuki.dao.UserMapper"&gt; &lt;select id="findAll" resultType="user"&gt; select * from user &lt;/select&gt; &lt;insert id="save" parameterType="user"&gt; insert into user values(#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;birthday&#125;) &lt;/insert&gt; &lt;select id="findById" resultType="user"&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 2. 动态sql占内存 &lt;if&gt; &lt;foreach&gt;&lt;sql&gt;&lt;where&gt; 多表操作注解常用注解：用注解替代映射文件 简单查询—-注解加载接口方法上 @Insert @Delete @Update @Select 1234&lt;!--加载映射关系--&gt;&lt;Mappers&gt; &lt;package name="com.tsuki.mapper"/&gt;&lt;/Mappers&gt; 复杂查询 @Result @Results @One(一对一) @Many(一对多，多对多) 套娃 报错 java.lang.ClassCastException: com.github.pagehelper.PageHelper cannot be cast to org.apache.ibatis. 探究plugins分页插件时的问题，多半是版本问题—-论springboot的好处，内置版本号 is not known to the MapperRegistry, 原因是namespace没有修改为全包名 用Mybatis插入数据但是没反应，用错了标签，’‘用成了’‘]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>框架笔记</category>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC笔记]]></title>
    <url>%2FSpringMVC.html</url>
    <content type="text"><![CDATA[系列二来了…这次是SpringMVC 写此系列的目的是做一个学习笔记管理，方便以后复习用。 Spring集成web环境原理： 添加坐标 servlet和jsp 添加web层servlet，在web.xml配置servlet web通过spring容器获取Service对象—–在web项目中通过ServletContextListener监听Web应用的活动，在web应用启动时，加载spring配置文件，创建上下文对象ApplicationContext，将其存储到最大的与servletContext域中，这样就可以在任意位置从域中获取ApplicationContext对象了。（web.xml配置监听器） 步骤 配置ContextLoaderListener监听器 123456789 &lt;!--全局化初始参数--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--配置监听器--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 使用WebapplicationcontextUtils获取应用上下文 1234ServletContext servletContext = this.getServletContext();ApplicationContext app = (ApplicationContext) WebApplicationContextUtils.getWebApplicationContext(servletContext);UserService userService = app.getBean(UserService.class);userService.save(); 快速入门 导入坐标 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;!--&lt;scope&gt;provided&lt;/scope&gt;疑问导入spring-web包时加了范围会出错--&gt;&lt;/dependency&gt; 配置核心控制器DispatcherServlet web.xml 123456789101112131415&lt;!--配置springmvc的前端控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载servlet时加载配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 创建Controller类和视图页面，注入Spring容器 12345678@Controllerpublic class UserController &#123; @RequestMapping("/quick")//访问路径 public String save()&#123; System.out.println("controller running"); return "success.jsp"; &#125;&#125; 使用注解配置Controller类中业务方法的映射地址 配置SpringMVC核心文件spring-mvc.xml 配置扫描组件，和context空间 1234567&lt;!--Controller组件扫描-需要加载context空间--&gt;&lt;context:component-scan base-package="com.tsuki.controller"/&gt;&lt;!--配置组件扫描,小tip，可以设置扫或者不扫--&gt;&lt;context:component-scan base-package="com.tsuki"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;&lt;/context:component-scan&gt; 客户端发起请求测试 访问路径”/quick” 相关组件DispathcherServlet; HandlerMapping; HandlerAdapter; Handler; View Resolver; View; 注解解析 @RequestMapping: URL与处理请求的方法之间建立联系 ​ 参数： value,method(RequestMethod.POST), params 视图解析器配置： 有默认配置—-可以指定功能进行增强–配置内部资源视图解析器 redirect和forward 12345&lt;!--配置内部资源视图解析器，但是这样做不好阅读啊（小疑问），而且做了代码内部修改--&gt;&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt; SpringMVC的请求和响应数据响应的方式1. 页面跳转 返回字符串–参见快速入门， prefix + String + suffix 代表页面跳转 返回ModelAndView save()参数还可以是HttpServletRequest等官方的定义，但是不建议使用，model和view可以拆开使用也可以一起使用，可以new也可以作为形参传入。 1234567891011121314151617181920212223242526@RequestMapping("/quick4") public String save4(Model model)&#123; model.addAttribute("username", "lisi"); return "success.jsp"; &#125; @RequestMapping("/quick3") public ModelAndView save3(ModelAndView modelAndView)&#123; modelAndView.setViewName("success.jsp"); modelAndView.addObject("username", "zhangsan"); return modelAndView; &#125; @RequestMapping("/quick2") public ModelAndView save2()&#123; ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName("success.jsp"); modelAndView.addObject("username", "helloworld"); return modelAndView; &#125; @RequestMapping("/quick") public String save()&#123; System.out.println("controller running"); return "success.jsp"; &#125; 2. 回写数据 直接返回字符串 @ResponseBody 12345678910@RequestMapping("/quick6")@ResponseBodypublic String save6() throws JsonProcessingException &#123; User user = new User(); user.setUsername("henry"); user.setAge(30); ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(user);//jackson进行转换 return json;&#125; 返回对象和集合–设置将对象转换为json对象输出（配置处理器映射器）—可以通过mvc的注解替代以上操作 spring-mvc.xml， 同时要加入springmvc的命名空间，就可以不需要json转换工具了 12345xmlns:mvc="http://www.springframework.org/schema/mvc"xsi:schemaLocation=" http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&lt;!--mvc的注解驱动--&gt;&lt;mvc:annotation-driven/&gt; 数据请求1. 实现数据请求方式 基本数据类型参数 POJO类型参数 数组类型参数 123456//localhost/Springdemo/quick8?strs='111'&amp;strs='222' @RequestMapping("/quick8") @ResponseBody public void save8(String[] strs)&#123; System.out.println(Arrays.asList(strs)); &#125; 以上三种都比较简单，只要名称一致框架就会自动封装 集合类型参数 将集合包装到一个POJO中 123456789101112public class VO &#123; private List&lt;User&gt; userList; //提供get 和set&#125;//VO作为形式参数@RequestMapping("/quick10")@ResponseBodypublic void save10(VO vo)&#123; System.out.println(vo);&#125;//此处要求VO中的属性名称和表单提交的名称一致&lt;input type="text" name="userList[0].username"&gt;&lt;br/&gt; ajax请求时指定contextType为json，使用 @RequestBody 访问jQuery失败： 12&lt;!--开发资源的访问 spring-mvc.xml, 开放静态资源的访问--&gt;&lt;mvc:default-servlet-handler/&gt; 12345678910var userList = new Array();userList.push(&#123;username:"zhangsan", age:12&#125;);userList.push(&#123;username: "lisi", age: 15&#125;);$.ajax(&#123; type:"POST", url:"$&#123;pageContext.request.contextPath&#125;/quick9", data:JSON.stringify(userList),//将数组转为json数据 contentType: "application/json; charset=utf-8"&#125;); 12345@RequestMapping("/quick9")@ResponseBodypublic void save9(@RequestBody List&lt;User&gt; userList)&#123; System.out.println(userList);&#125; 2. 获取数据细节 中文乱码问题 @RequestParam （value， required， defaultValue）和 @PathVariable 123456789101112//localhost/quick11?name=zhangsan@RequestMapping("/quick11")@ResponseBodypublic void save11(@RequestParam("name") String username)&#123; System.out.println(username);&#125;//localhost/quick11?username=zhangsan@RequestMapping("/quick12/&#123;username&#125;")@ResponseBodypublic void save12(@PathVariable("username") String username)&#123; System.out.println(username);&#125; 自定义类型转换器– 定义com.tsuki.converter.DateConverter实现Converter接口 1234567891011121314151617181920212223package com.tsuki.converter;import org.springframework.core.convert.converter.Converter;//注意不要导错包import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class DateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String dateStr) &#123; SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd"); Date date=null; try &#123; date=format.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125; 在配置文件中声明转换器，在 &lt;annotation-driven&gt; 中引用转换器。spring-mvc.xml 123456789101112&lt;!--mvc的注解驱动--&gt;&lt;mvc:annotation-driven conversion-service="conversionService"/&gt;&lt;!--开发资源的访问--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="com.tsuki.converter.DateConverter"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 获取Servlet相关API：直接形参注入 @RequestHeader和@CookieValue 1234567891011@RequestMapping("/quick14")@ResponseBodypublic void save14(@CookieValue(value = "JSESSIONID", required = false) String user_agent)&#123; System.out.println(user_agent);&#125;@RequestMapping("/quick13")@ResponseBodypublic void save13(@RequestHeader(value = "User-Agent", required = false) String user_agent)&#123; System.out.println(user_agent);&#125; 文件上传 表单编写 123456&lt;%--注意enctype的填写--%&gt;&lt;form action="$&#123;pageContext.request.contextPath&#125;/quick15" method="post" enctype="multipart/form-data"&gt; 名称&lt;input type="text" name="username"&gt;&lt;br/&gt; 文件&lt;input type="file" name="uploadFile"&gt;&lt;br/&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; pom.xml导入坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 配置文件上传解析器 spring-mvc.xml 12345&lt;!--配置文件上传解析器--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="UTF-8"/&gt; &lt;property name="maxUploadSize" value="500000"/&gt; &lt;/bean&gt; 编写文件上传代码 123456789@RequestMapping("/quick15")@ResponseBodypublic void save15(String username, MultipartFile uploadFile) throws IOException &#123; //uploadFile形参名字与表单的提交文件name名称一致 System.out.println(username); String originalFilename = uploadFile.getOriginalFilename(); //保存到某位置 uploadFile.transferTo(new File("F:\\图片\\"+originalFilename));&#125; 拦截器 快速入门 创建拦截器实现HandlerInterceptor接口 1234567891011121314151617181920212223242526public class MyInterceptor1 implements HandlerInterceptor &#123; //目标方法执行之前 执行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("preHandle running..."); String param = request.getParameter("param"); if("yes".equals(param))&#123; return true; &#125;else&#123; request.getRequestDispatcher("success.jsp").forward(request,response); return false; &#125; &#125; //目标方法执行之后，视图对象返回之前执行 @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; modelAndView.addObject("name", "Java"); System.out.println("postHandle running..."); &#125; //在流程都执行完毕后执行 @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("aftercomletion running..."); HandlerInterceptor.super.afterCompletion(request, response, handler, ex); &#125;&#125; 配置拦截器 spring-mvc.xml 12345678&lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对那些资源进行拦截--&gt; &lt;mvc:mapping path="/**"/&gt; &lt;bean class="com.tsuki.interceptor.MyInterceptor1"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 测试 1234567891011@Controllerpublic class TargetController &#123; @RequestMapping("/target") public ModelAndView show()&#123; System.out.println("target is running..."); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("name", "Tomcat"); modelAndView.setViewName("index.jsp"); return modelAndView; &#125;&#125; 登录验证案例（待实践）过滤器： 获取session对象 request.getSession().getAttribute(“user”) 判断是否有user，否（return false） 是 （return true） 登录： login(username, password){} 调用userService.login():返回User（查表并用jdbcTemplate接收） 判断user是不是空，有（存到Session，并跳转首页） 否（跳转到登录页面） 异常处理配合日志输出使用 123456789&lt;!--配置异常处理器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;defaultErrorView&quot; value=&quot;error.jsp&quot;/&gt; &lt;!--&lt;property name=&quot;exceptionMappings&quot;&gt; &lt;map&gt; &lt;entry key=&quot;异常类型&quot; value=&quot;错误视图&quot;&gt; &lt;/map&gt; &lt;/property&gt;--&gt; &lt;/bean&gt; 自定义异常处理 1. 创建异常处理器类实现HandlerExceptionResolver 2. 配置异常处理器到spring-mvc.xml 3. 编写异常页面 JdbcTemplate(待补充)补充 SimpleDateFormat中有两个方法，parse()和format() parse()把String型的字符串转换成特定格式的date类型 format()把Date型的字符串转换成特定格式的String类型 equals：参考博客 public boolean equals(Object obj) { return (this == obj); } 运行问题 报错1：Servlet不能正常访问，错误代码500，原因在于版本，我原本用的是tomcat10，改成tomcat9之后成功解决。论版本兼容的重要性。tomcat各版本的兼容 创建web项目还是不熟练。教程 本来Servlet要注入到web.xml中才会运行的，但是不知道什么原因不需注入也可以访问到。 SpringMVC错误：org.springframework.web.servlet.DispatcherServlet noHandlerFound ，我的错误原因是访问静态资源，改为访问jsp就成功了 在导入了jackson的坐标后发生了新的错误：java.lang.NoClassDefFoundError: com/fasterxml/jackson/databind/exc/InvalidDefinitionException ，找到问题了，版本不兼容，致命 在测试jsp页面发出post请求，用$.ajax响应集合类型参数是出现找不到jQuery和访问路径/quick的情况，原因是路径问题。url:&quot;${pageContext.request.contextPath}/quick9&quot;, 是jsp获取绝对路径的方式，这篇博客解析 SpringMVC中已经配置了解决中文乱码问题的过滤器后，还会出现中文乱码现象，尝试了博客所述的方法但是还未解决乱码问题，但是使用maven发布时不会乱码]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>框架笔记</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring笔记]]></title>
    <url>%2FSpring.html</url>
    <content type="text"><![CDATA[写此系列的目的是做一个学习笔记管理，方便以后复习用。 Spring是轻代码，重配置的框架。 Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层 SpringMVC 和持久层 Spring JDBCTemplate 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。 Spring框架的核心功能： 创建管理所有的Java对象，这些对象被称为Bean。 参考文档 参考视频 Spring快速入门 导入Spring开发的基本包坐标 pom.xml 123456789101112&lt;properties&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写Dao接口和实现类 12345678910public interface UserDao &#123; public void save();&#125;public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println("UserDao save method running...."); &#125;&#125; 创建Spring核心配置文件 在类路径下（resources）创建applicationContext.xml配置文件 1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt; 在Spring配置文件中配置UserDaoImpl 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置--&gt; &lt;bean id="userDao" class="com.itheima.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 使用Spring的API获得Bean实例 1234567@Testpublic void test1()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao userDao = (UserDao) applicationContext.getBean("userDao"); userDao.save();&#125; Spring配置文件重要配置标签12345678910111213&lt;bean&gt;标签 id属性:在容器中Bean实例的唯一标识，不允许重复 class属性:要实例化的Bean的全限定名 scope属性:Bean的作用范围，常用是Singleton(默认)和prototype &lt;property&gt;标签：属性注入 name属性：属性名称 value属性：注入的普通属性值 ref属性：注入的对象引用值 &lt;list&gt;标签 &lt;map&gt;标签 &lt;properties&gt;标签 &lt;constructor-arg&gt;标签&lt;import&gt;标签:导入其他的Spring的分文件 Bean实例化的三种方式无参构造方法实例化 1&lt;bean id = "userDao" class = "com.itheima.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt; 工厂静态方法实例化 工厂实例方法实例化 Bean的依赖注入依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC（反转控制） 的具体实现。 在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。 用依赖注入的方式管理Bean之间的依赖关系。依赖注入可以让Bean以配置文件组织在一起，是一种优秀的解耦方式。 依赖注入有两种方式，set注入和构造注入。（设计模式解耦合） set注入和构造注入 123456789101112&lt;!--set方式注入--&gt;&lt;bean id="userDao" class="com.tsuki.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;&lt;bean id="userService" class="com.tsuki.service.impl.UserServiceImpl"&gt; &lt;!--set方法后的名字是name，ref是指向注入的UserDao的id--&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--构造器方式注入--&gt;&lt;bean id="userDao" class="com.tsuki.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;&lt;bean id="userService" class="com.tsuki.service.impl.UserServiceImpl"&gt; &lt;constructor-arg name="userDao" ref="userDao"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 相关APIapplicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象 ApplicationContext的实现类 1）ClassPathXmlApplicationContext 它是从类的根路径下加载配置文件 推荐使用这种2）FileSystemXmlApplicationContext 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。3）AnnotationConfigApplicationContext 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 123ApplicationContext app = new ClasspathXmlApplicationContext("xml文件");app.getBean("id");app.getBean(Class); Spring配置数据源（连接池）druid步骤： 导入依赖 pom.xml 1234567891011121314151617181920212223242526272829&lt;!--mysql驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.26&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;!--druid连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt;&lt;!--导入Junit--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--版本要求高于4.11--&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 创建DataSource 在Spring中采用注入容器的方法 applicationContext.xml 123456&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/db1"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt; 将参数提取到properties文件中后如何注入容器 1.需要引入context的命名空间和约束路径 命名空间 xmlns:context=&quot;http://www.springframework.org/schema/context&quot; 约束路径 http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd applicationContext.xml 1234567891011&lt;!--加载外部配置文件，classpath是从类加载文件resources中加载--&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;&lt;!--注入datasource--&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;!--spl表达式，类似el表达式的用法 value="$&#123;key&#125;"--&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 使用 123456789@Testpublic void test2() throws SQLException &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");//加载Spring的配置文件 //从容器中获取对象 DataSource ds = (DataSource) applicationContext.getBean("dataSource"); Connection conn = ds.getConnection(); System.out.println(conn); conn.close();&#125; 注解开发简化和舍弃Spring的配置文件，方便快捷 原始注解 @Component &lt;bean id=&quot;userDao&quot; class=&quot;com.tsuki.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt; @Controller @Service @Repository @Autowired @Qualifier---@Resource按名称注入 123&lt;bean id="userService" class="com.tsuki.service.impl.UserServiceImpl"&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;&lt;/bean&gt; @Value(普通属性) @Scope 配置组件扫描 12&lt;!--配置组件扫描--&gt; &lt;context:component-scan base-package="com.tsuki" /&gt; 新注解开发—全注解开发 旧注解有几方面不能满足 @Configuration Spring的核心配置类，用类的方式替代xml文件， 注解的方式替代标签 非自定义的bean @Bean(&quot;dataSource&quot;) 配置文件properties @PropertySource(&quot;classpath:jdbc.properties&quot;) 组件扫描 @ComponentScan(&quot;com.tsuki&quot;) 引入import @Import Junit的集成 导入spring集成Junit坐标 pom.xml 1234567891011121314151617181920&lt;!--导入Junit--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;!--版本要求高于4.11--&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;!--导入spring的test坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; @Runwith代替原来运行周期 @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration指定配置文件或配置类 @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) @Autowired注入需要测试的对象 创建测试方法进行测试 AOP事务控制未完待续。。。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>框架笔记</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[摩尔投票法]]></title>
    <url>%2F%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[有时候，刷算法题的关键是读懂题目。时常卡在读不懂题目=_= 摩尔投票法今日的力扣每日一题是229.Majority Element II。看懂题目后最开始的想法就是普通的，遍历一遍数组统计出每个数字出现的次数存在数组中，然后再遍历一次数组找出是否存在次数大于⌊ n/3 ⌋的元素。 看了评论区题解学到了新的解题方法。刷题在于学习总结嘛。本题可以用到摩尔投票法的变体。 摩尔投票法出自论文，算法解决的问题是如何在任意多的候选人中，选出获得的票数最多的那个。算法演示，文章做了很详细的解读。摩尔投票法主要分为两个阶段，第一阶段筛选可能的元素，第二阶段验证。应用在众数的解答上。 Majority Element II 解答 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; int x = 0, y = 0; int cx = 0, cy = 0; for(auto num : nums)&#123; if((cx == 0||num == x)&amp;&amp; num != y)&#123; cx++; x = num; &#125;else if(cy == 0|| num == y)&#123; cy++; y = num; &#125;else&#123; cx--; cy--; &#125; &#125; int countx = 0, county = 0; for(auto num:nums)&#123; if(num == x) countx++; if(num == y) county++; &#125; int target = nums.size()/3; if(countx &gt; target) res.push_back(x); if(county &gt; target &amp;&amp; y != x) res.push_back(y); return res; &#125;&#125;; 参考博客 169 Majority Element 解答 前提条件中假设数组非空，且一定存在多数元素，所以可以省掉第二阶段验证。 12345678910111213141516class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int res = 0; int count = 0; for(auto num: nums)&#123; if(count == 0 || num == res)&#123; res = num; count++; &#125;else&#123; count--; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>摩尔投票法</tag>
        <tag>求众数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAD]]></title>
    <url>%2FMad.html</url>
    <content type="text"><![CDATA[常调侃说做MAD死路一条，实际上也真是如此？ 最近重拾做视频，发完以后没人看难免失落就去搜了这个问题，不禁思考起剪mad的初衷。 什么是一个好的MAD？ 一个好的MAD是讲述一个好的故事或者给观者带来好的视觉享受，用MAD讲好故事才是一开始想做的。 现在的状况是有点陷入了技术突破的死区里，一直很想做一个欧美风的MAD，大概就是视觉体验吧。说实话现在剪的视频没什么内容。最近剪的两篇个人向都在追求技术，只是镜头的简单拼接，勉强算是考虑了镜头的衔接。放在众多优秀作品里只能说普通又普通，没有画面，没有故事，没有播放量才是常态。而且我做mad是为了播放量吗，虽然不在意播放是假的，但是初心是为了突破自己，做自己喜欢的事，所以不忘初心真的很难的。 (人总是在找合适的理由安慰自己哈) 虽然这些年也没有把重心放在做视频上，好几年不学新技术，但也确实是毫无进步。剪了这么多年仍旧没什么质量提升，其实这种状况下不如不发，好好沉淀一下。 重要的从来不是在AE和Vegas里花多少时间，它只是工具，重要的是表达自己的思想，享受尝试新东西的快乐。所以，喜欢就坚持下去！]]></content>
      <categories>
        <category>生活</category>
        <category>MAD</category>
      </categories>
      <tags>
        <tag>MAD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vegas 导入 AE]]></title>
    <url>%2FVegas%E8%BD%ACAE.html</url>
    <content type="text"><![CDATA[电脑带不动Pr，所以一开始就用的vegas，虽然vegas有很多插件 例如newBlue都很好用，但是做特效和拉曲线当然还是AE方便，于是就想着有没有什么方法能在vegas粗剪的视频导入ae。以前就找过相关的教程，但是时隔太久不用，我存在哪里已经忘了，又折腾半天，这回一定要存好。于是有了这篇博客。 操作步骤： 在vegas中粗剪完成放在一个视频轨道上，删掉音频 文件==&gt;导出 ==&gt; Media Composer AAF File 打开AE， 文件==&gt;导入==&gt;Pro Import After Effects… 修改合成大小 附：使用的软件版本是AE CC 2015和Vegas13 参考视频，感谢up主，视频还提供了AE转Vegas的操作，暂时没有用到就先m一下，不展开记录了 完]]></content>
      <categories>
        <category>技术</category>
        <category>剪辑</category>
        <category>vegas</category>
      </categories>
      <tags>
        <tag>vegas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Latex]]></title>
    <url>%2Flatex.html</url>
    <content type="text"><![CDATA[第一次用latex排版，记录一下使用过程中遇到的问题。 哈哈哈论文能不能投不知道，调格式倒是挺折腾。记录下来以后说不定会用到，省得再折腾一次。总的来说上手还是挺快的，博主的经历和latex编辑注意事项也给小白的我很多的帮助。 texlive的编辑器显示效果不是很好看，但是图个省事就没有安装vscode。 下载模板首先下载完成IEEEtrans模板之后的使用。 IEEEtran.cls文件复制到texlive\2021\texmf-local\tex\latex 以管理员方式运行cmd，&gt;texhash 将.tex文件复制到texlive文件夹里面即可 参见博客。 然后就可以开始快乐编辑内容。 公式篇关于插入公式真的是很方便，只要多用几次就能掌握常用的命令，希腊字母根据发音的写法也很好记，打开了新世界大门。 如何插入公式。 123456\begin&#123;equation&#125; \begin&#123;split&#125; P(t)=P(t-t_0)+D(t), x = a + b. \end&#123;split&#125;\end&#123;equation&#125; 要记得加入宏包 \usepackage{amsmath} 公式的常用符号的写法看这里。符号大全补充看这里。 导数相关的符号看这里。都是基础问题就不赘述。 如何排版公式，善用&amp;符号。 图片篇加入宏包 \usepackage{graphicx} 如何插入图片，看这里。 12345678\begin&#123;figure&#125;[htbp] \centering \includegraphics[width=2.5in]&#123;fig1.eps&#125; \caption&#123;name&#125; \label&#123;fig1&#125;\end&#123;figure&#125; %如何解决路径问题graphicspath&#123;&#123;img/&#125;&#125;%当前路径下存放图片的文件夹 如何插入eps图片，简单粗暴，我是直接PS另存为解决了。其他解决方法看这里。 文献篇如何插入文献？ 创建bibtex文件，建立参考文件库。 便捷使用google的引用功能，轻松搞定！ 文章主体添加引用 \cite{ref} 四次编译，就可以引用位置和参考文献位置链接互通啦！这里被卡了一会，参考文章总算解决掉了。 高亮内容的制作，参考文章 如何插入链接型的文献呢？看这里 我是手动修改的.bib文件，不知道有没有更便捷准确的方法，如果有人看的话，欢迎邮件交流。 123456@Misc&#123;timmurphy.org,howpublished = &#123;[EB/OL]&#125;,note = &#123;\url&#123;http://timmurphy.org/2009/07/22/line-spacing-in-latex-documents/&#125; Accessed April 4, 2010&#125;,title = &#123;Line Spacing in LaTeX documents&#125;,author = &#123;Murphy, Timothy I&#125;&#125; 在插入链接型参考文献的时候，引申一下EB/OL的含义。 交叉引用通过图片和公式的交叉引用，无论公式挪动到哪里都能正确的编号，省了自己费劲数的功夫，还不会产生失误。 \ref命令配合\label的使用基本就解决了图片公式以及文献的引用，一个ref走天下。 引用图片 \ref{fig1} 引用文献 \ref{ref1} 引用方程 \ref{equation1} 此外还可以导入amsmath包用 \eqref{equation1} 参考文章： 文章1 文章2 碎碎念在学习latex的过程中，刷到了一篇关于如何写好论文的博客，给迷茫的我上了一课。 写paper的两种方式: Idea-&gt;Do Research-&gt;Write Paper Idea-&gt;Write Paper-&gt;Do Research 以前一直认为论文是以结果为导向的，这可能与我过往做物理实验的经历有关。还是道行尚浅啊。每次在组会上说到论文没有成果展示的时候，老师都会反问一句一定要有成果吗？当时不理解，现在读到这篇文章，哦原来，paper真正的目的是交流思想的。其实写文章的过程中也查阅了很多的文献，仔细回想一下这些优秀的文献也确实如此。]]></content>
      <categories>
        <category>技术</category>
        <category>论文</category>
        <category>latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>IEEEtrans</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <url>%2FJAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.html</url>
    <content type="text"><![CDATA[c#, Python都是动态语言，可以在运行时改变自身结构。而反射是Java非常重要的动态特性 思考：方法变量化是不是也是一种动态性的体现？ 理解Class类并获取Class类的实例Class的实例就对应一个运行时类 1234567//方式一：调用运行时类的属性：.classsClass clazz1 = Person.class;//方式二：通过运行时类的对象调用getClass()Person p1 = new Person();Class clazz2 = p1.getClass();//方式三：调用Class的静态方法：forName(String classPath)，实际中应用多，体现了反射的动态性Class clazz3 = Class.forname("java.lang.String"); 补充一点，后续学到编译内容是再更新。 类的加载过程 Load=&gt;Link=&gt;Initialize Load:将class文件读入内存，并在堆里为之创建一个java.lang.Class对象。此过程由类加载器完成。 Link:将类的二进制数据合并到JRE中 Initialize: JVM负责对类进行初始化 创建运行时类的对象反射机制应用最多的地方来了！ 创建类的对象：调用Class对象的newInstance()方法 要求类必须有一个无参构造器，类的构造器访问权限要足够。 12Class clazz = Person.class;Person obj = clazz.newInstance(); 没有无参的构造器也可以创建对象，调用类中的指定构造器 123456Class clazz = Class.forName("aa.Java.Person");//获取指定构造器Constructor con = clazz.getDeclaredConstructor(String.class,Integer.class);con.setAccessible(true);//调用此构造器创建运行时类的对象Person p2 = (Person)con.newInstance("Peter",20); 调用运行时类的指定结构调用指定属性123456789Class clazz = Person.class;//创建运行时类的对象Person p = (Person)clazz.newInstance();//获取运行时类中指定变量名的属性Field name = clazz.getDeclaredField("name");//保证当前属性是可访问的name.setAccessible(ture);//设置指定对象的此属性值name.set(p,"name"); 调用指定方法同理实例化class==&gt;找到方法==&gt;调用方法invoke() 使用频率更高。 1234Class clazz = Person.class;Method show = clazz.getDeclaredMethod("show", String.class);show.setAccessible(true);Object returnValue = show.invoke(p, "CHN"); 调用指定构造器已经在创建运行时类的对象部分介绍过。 反射的应用–动态代理补充：静态代理，以设计模式中的工厂模式做例，实际上是多态性的体现。 碎碎念，到处都存在的多态性和解耦合操作。 分别有三个对象，提供一个接口，代理类和被代理类。代理类通过聚合的方式调用接口，被代理类实现接口中的目标方法。从而利用多态特点，代理类调用被代理类实现的目标方法。听起来比较绕口，就举个例子。 12345678910class ProxyClothFactory implements ClothFactory&#123; private ClothFactory factory; public ProxyClothFactory(ClothFactory factory)&#123; this.factory = factory; &#125; @override public void produceCloth()&#123; factory.produceCloth(); &#125;&#125; 动态代理内容有待补充。后续更新。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Endnotes]]></title>
    <url>%2FEndnotes.html</url>
    <content type="text"><![CDATA[最近在整理文献，写一个查找和下载文献的小心得。 ref download首先是下载文献，作为一个科研人，都逃不过读英文文献，除了学校图书馆的资源怎么下载其他文献呢？ 参考知乎回答，感谢答主！ 首先查找文献，翻墙和谷歌学术镜像网站。免费的外皮恩真的香，但是秉持好学的态度改天研究一下自己搭梯子哈哈。 然后是最近发现的宝藏网站，下载神器，文献小镇！强推！ Endnotes接下来下载一时爽，阅读火葬场。面对下载的几十文献真是抓狂，一边是看完就忘，一边是难以分类标记，上学这么多年到现在才学会如何整理文献真是惭愧。 用了Endnotes真是相见恨晚。下载安装和导入文献基本教程都可以参考博客，博主写的很详细。使用了文献管理软件的感觉就是获得了解放，再也不用为文献格式发愁，可以尽情的快乐插入文献了。 我不生产教程，我只是教程的拼接工。 但是目前使用了Endnotes，也有一些问题，中文文献难以识别，没有标签功能。 在整理插入文献的过程中可以一边查看文献一边完善论文内容，提高工作效率。 后续使用其他文献管理软件体验不定期更新。 完。]]></content>
      <categories>
        <category>技术</category>
        <category>论文</category>
        <category>Endnotes</category>
      </categories>
      <tags>
        <tag>endnotes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VISA]]></title>
    <url>%2Fvisa.html</url>
    <content type="text"><![CDATA[最近开始跑老师给的现成软件，记录一下遇到的问题。 首先如何把一个项目跑起来？小白的我快要吐血了。计划之后试试开源项目。 先叨叨两句题外话，太久不用git，上传好像出了点问题。远程仓库和本地仓库地址不一致，上次搞了半天也没弄好，倒是能上传文章了，但还是会报错。过几天有空再搞一下。 倒腾好了，出错提示： fatal:Could not read from remote repository 原因是站点配置文件的网站写错了，参考文章。大费周章困扰好久。 错误二： fatal: unable to access &#39;https://github.com…\&#39;: Empty reply from server 解决方法： git config --global --unset http.proxy 参考文章 技术点本项目主要用了对设备的程控。NI-VISA是美国国家仪器NI公司开发的一种用来与各种仪器总线进行通信的高级应用编程接口。参考博客如何使用VS2010调用visa进行程控，开始！ 下载所以开始在电脑上安装NI提供的库，如果安装失败的话，重新下载安装包下载。安装失败的原因现在也没搞清楚，难道是以前安装labview的注册表没清干净？其中曲折把系统盘误删文件搞坏还修了好久，泪目。可以写个合集了”这些年我遇到过的麻烦“。 回到正题， 文件安装目录：C:\Program Files (x86)\IVI Foundation\VISA\WinNT lib文件位置：C:\Program Files (x86)\IVI Foundation\VISA\WinNT\lib\msc .h文件位置：C:\Program Files (x86)\IVI Foundation\VISA\WinNT\Include 如何添加库到工程中？这里涉及到静态库的使用。之前在课上一知半解，现在终于用到了。参考文章c++静态库与动态库 这里卡了好久，最后采取了文章中提到的方法二： 属性==&gt;配置属性==&gt;链接器==&gt;命令行 输入静态库的完整路径。 之前采用方法三，一直没能导入成功，不知道哪里出了问题，摊手。 属性==&gt;配置属性==&gt;链接器==&gt;常规，附加依赖库目录输入静态库所在的目录 属性==&gt;配置属性==&gt;链接器==&gt;输入，附加依赖库中输入静态库名visa32.lib 此时生成解决方案出现了报错 “LINK:fatal error LNK1104: 无法打开文件‘C：/Program.obj” 解决方案是静态库路径加引号。参见博客 继续报错，无法解析外部符号 参考博客 继续上回分解，发现我整个搞错了。 首先分清楚这几个附加目录分别表示什么。检查发现是添加在C\C++ ==&gt;附加库目录起作用了。 然后解决无法解析外部符号，引用另一个库项目中的实现。完美解决。 完。]]></content>
      <categories>
        <category>技术</category>
        <category>VISA</category>
      </categories>
      <tags>
        <tag>VISA</tag>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯剪枝]]></title>
    <url>%2F9%E6%9C%88leetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[刚开始刷题大部分都不会，有的题有思路但是代码写不明白，参考了很多官方和评论区大佬的答案，学到了很多。解答用的语言是c++，在边学边用，官方的STL库还不熟悉，菜鸟如我经常搞错vector的用法。 本来打算九月底发的博客拖到了现在(十一月初），十月也没有继续刷题。开始准备做项目不由感叹门外汉入门真是不容易，什么都不会，扶额。 这一个月做过的题类型有，回溯算法加剪枝， 二叉树的遍历和递归， 并查集等等。 回溯算法加剪枝一直碰到用回溯算法就歇菜。现在还没有完全掌握。 回溯算符与递归的区别在于，回溯过程中达到结束条件要恢复状态回溯到上一层，再次搜索，而递归是一个劲往某个方向。回溯与DFS的区别就是有无状态的重置。在题解区看到答主的回答颇有所获，非常感谢。但是实际应用中画出递归树不好理解。 子集和组合leetcode78 子集，leetcode 90子集2使用了剪枝。使用了start变量。 参考了官方的答案，递归枚举类题的包括以下几个步骤： 画出递归树（关键 递归边界，记录的条件 设置了vector: temp当前的记录，vector&lt;vector&lt;&gt;&gt;: ret返回所有的记录 判断是否需要剪枝处理 1234sort(nums.begin(), nums.end());if(i &gt; start &amp;&amp; nums[i] == nums[i - 1])&#123; continue;&#125; 组合中可以选择或者不选择当前位置，之后递归考虑下一个位置。 1234temp.push_back(cur);dfs(cur + 1);temp.pop();dfs(cur + 1); （事实告诉我们不要写一半跑路，时隔一个月我已经看不懂之前写的了，趁着快要考试继续做算法总结 组合中配合使用了剪枝来减少时间。 组合总和中传入了target变量。 组合总和2使用了剪枝。 全排列全排列，全排列2设置了visited数组。 核心代码如下： 12345678for(int i = 0; i &lt; nums.size(); i++)&#123; if(visited[i] == true) continue; visited[i] = true; temp.push_back(); dfs(); visited[i] = false;//回退 temp.pop_back();&#125; 考虑剪枝处理 12345sort(nums.begin(), nums.end());// i &gt; 0 是为了i - 1 有效if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !visited[i - 1])&#123; continue;&#125; 搜索二叉树遍历递归层次遍历 二叉树层次遍历和层次相关时，可以用queue.size()获取一层的个数，一层一层的处理。如leetcode 637，二叉树层平均值，leetcode 117，层链接 深度优先遍历 先序中序和后序遍历 相关于二叉树的题十有八九是递归算法，属于有思路但是写出来的代码总有逻辑错误的题，栈溢出，多半是递归边界问题，还有递归的参数没弄对。 并查集]]></content>
      <categories>
        <category>技术</category>
        <category>算法</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
        <tag>二叉树</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[十月间断的学了一些设计模式。这是个长久的课程，还没有学会怎么实际运用到项目中。 跟随着视频来学。 为什么学习设计模式？ 为了让程序具有更好的代码重用性，可读性，可扩展性，可靠性，使程序呈现高内聚，低耦合的特性。 什么时候用到设计模式？ 面向对象（oo）=&gt; 功能模块[设计模式 + 算法（数据结构）] =&gt; 框架[ 多种设计模式 ] =&gt; 架构[ 服务器集群 ] 学习步骤 应用场景 –&gt; 设计模式 –&gt; 剖析原理 –&gt; 分析实现步骤（图解，类图） –&gt; 代码实现 –&gt; 框架或项目源码分析的步骤讲解 设计模式的七大原则设计模式为什么这样设计的原则。 字符流会查码表，字节流不查码表 编码：字符—&gt;码表—&gt;数字 解码：数字—&gt;码表—&gt;字符 Reader默认查询的码表是与操作系统一致的码表，操作系统是中文的，所以reader使用GBK码表 java查的是unicode的码表 1. 单一职责原则 一个类只负责一个职责。 2. 接口隔离原则 使用多个单独的接口。 3. 依赖倒转原则 其核心是面向接口编程（即抽象类）。 4. 迪米特法则（最少知道原则） 体现了封装的思想。可以适当违反。 5. 开闭原则OCP 对扩展开放，对修改关闭。 6. 里氏替换原则 oo中继承的思考。 所有引用基类的地方必须能透明的使用其子类的对象。 使用继承时尽量不要重写父类的方法。 创建一个更加基础的类。使用依赖，聚合，组合的关系。 7. 合成复用原则 尽量使用合成聚合的方式，而不是使用继承。 UML语言介绍统一建模语言。 类图-依赖关系（Dependence）只要在类中用到了对方，他们就存在依赖关系。 类图-泛化关系（generalization），就是继承关系，是依赖关系的特例。 类图-实现关系（Implement），是依赖关系的特例 123456public interface PersonService&#123; public void delete(Interger id);&#125;public class PersonServiceBean implements PersonService&#123; public void delete(Interger id)&#123;&#125;&#125; 类图-关联关系（Association） 类与类之间的联系，是依赖关系的特例。有单向和双向关系。 类图-聚合关系（Aggregation） 整体与部分的关系，整体与部分可以分开。比如Person和IDCard。聚合式关联关系的特例。 类图-组合关系（Composition）也是整体与部分的关系，但是整体与部分不可以分开。例如Person和head。同生共死的关系。 123456public class Person&#123; private IDCard card; private Head head = new head();&#125;public class IDCard&#123;&#125;public class Head&#123;&#125; 创建型模式1. 单例模式主要步骤： 1) 构造器私有化 (防止 new ) 2) 类的内部创建对象 3) 向外暴露一个静态的公共方法 饿汉式 123456789101112class Singleton&#123; //构造器私有化 new private Singleton()&#123; &#125; //本类内部创建对象实例。 private final static Singleton instance = new Singleton(); //提供一公有的静态方法，返回实例对象 public static Singleton getInstance()&#123; return instantce; &#125;&#125; 优缺点：写法简单，在类装载的时候完成实例化，避免了线程同步问题，没有达到懒加载的效果。 可用，但会造成内存的浪费。 双重检查 12345678910111213141516class Singleton&#123; private static volatile Singleton instance;//volatile可以实现立刻写到内存中 //构造器私有化 private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; Double-Check是多线程开发中常使用的。线程安全，延迟加载，效率较高。 静态内部类 123456789101112class Singleton&#123; private static volatile Singleton instance; private Singleton()&#123;&#125; //写一静态内部类 private static class SingletonInstance&#123; private static final Singleton INSTANCE = new Singleton(); &#125; //提供一静态的公有方法，直接返回 SingletonInstance.INSTANCE。 public static Singleton getInstance()&#123; return SingletonInstance.INSTANCE; &#125;&#125; 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。避免了线程不安全，利用静态内部类特点实现延迟加载，效率高。推荐使用。 枚举法 123456enum Singleton&#123; INSTANCE; public void sayOK()&#123; System.out.println("ok"); &#125;&#125; 借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。这种方式是 \Effective** \Java** 作者 \Josh** \Bloch** 提倡的方式.推荐使用 2. 简单工厂模式12345678910111213141516...class FoodFactory&#123; public static Food getFood(int n)&#123; Food food = null; switch(n)&#123; case 1: food = new Hamburger(); break; case 2: food = new RiceNoodle(); break; &#125; return food; &#125;&#125;... 服务器修改了具体产品的类名后，客户端不知道。 工厂的实现不易于扩展，违反了ocp原则，故引入了工厂方法模式。 3. 工厂方法模式1234567891011121314151617181920212223242526272829303132333435interface food&#123; void eat();&#125;class Hamburger implements Food&#123; public void eat()&#123; System.out.println("吃汉堡！"); &#125;&#125;class RiceNoodle implements Food&#123; public void eat()&#123; System.out.println("吃米线！"); &#125;&#125;//食物工厂interface FoodFactory&#123; public Food getFood()&#123;&#125;&#125;class HamburgerFactory implements FoodFactory&#123; public Food getFood()&#123; return new Hamburger(); &#125;&#125;class RiceNoodleFactory implements FoodFactory&#123; public Food getFood()&#123; return new RiceNoodle(); &#125;&#125;public static void main()&#123; FoodFactory ff = new HamburgerFactory(); Food food = ff.getFood(); food.eat(); &#125; 工厂的名字是视为接口的，是趋向稳定的。 但是当种类很多时，会造成类爆炸式增长，于是引入抽象工厂。 4. 抽象工厂12345678910111213141516interface Factory&#123; public Food getFood()&#123;&#125; public Drink getDrink()&#123;&#125; &#125;class KFCFactory implements Factory&#123; public Food getFood()&#123; return new Hamburger(); &#125; public Drink getDrink()&#123; return new Cola(); &#125;&#125;class SanQinFactory implements Factory&#123; ...&#125; 无论有多少产品等级，工厂就一类。 冰箱电视洗衣机视为产品等级，工厂厂家海尔海信华为系列产品视为产品簇。虽然新增一个工厂很便捷，但抽象工厂扩展产品等级需要所有的工厂都修改，用Spring框架解决。 抽象工厂中可以生产多个产品，这多个产品之间必有内在联系。同一个工厂中的产品都属于一个产品簇。 5. 原型模式1234567891011121314151617181920212223242526272829public class Sheep implements Cloneable&#123; private String name; private int age; private String color; //构造器 public Sheep(String name,int age, String color)&#123; this.name = name; this.age = age; this.color = color; &#125; //提供对外的接口 public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; ... //克隆该实例 protected Object clone()&#123; Sheep sheep = null; try&#123; sheep = (Sheep)super.clone();//sheep是object，但是object不一定是sheep &#125;catch(Exception e)&#123; System.out.println(e.getMessage()); &#125; return sheep; &#125;&#125; Java中的Object类是所有类的根类，Object类提供了一个clone()的方法。需要实现clone的java类必须实现一个接口Cloneable，该接口表示该类能复制且有复制的能力。 上例的clone实现使用了默认的clone()，是浅拷贝，要实现深拷贝可以采用重写clone函数或者序列化。 c++可以用拷贝构造函数 123456789101112class ISplitter&#123;public: virtual void split() = 0; virtual ISplitter* clone() = 0;//纯虚函数 virtual ~ISplitter()&#123;&#125;&#125;class BinarySplitter: public ISplitter&#123;public: virtual ISplitter* clone()&#123; return new BinarySplitter(*this); &#125;&#125; 6. 建造者模式建造产品的过程的产品解耦合？ 与工厂模式的区别： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//Productpublic class House&#123; private String baise; private String wall; private String roofed; public String getBaise()&#123; return baise; &#125; public void setBaise()&#123; this.baise = baise; &#125; ...&#125;//抽象建造者public abstract class HouseBuilder&#123; protected House house = new House(); public abstract void buildBasic(); public abstract void buildWall(); public abstract void roofed(); public House buildHouse()&#123; return house; &#125; &#125;public class CommonHouse extends HouseBuilder&#123; public void buildBasic()&#123; System.out.println("普通房子打地基5m"); &#125; public void buildWall()&#123; System.out.println("普通房子打砌墙10cm"); &#125; public void roofed()&#123; System.out.println("普通房子打顶"); &#125;&#125;public class HighHouse extends HouseBuilder&#123; public void buildBasic()&#123; System.out.println("高楼打地基100m"); &#125; public void buildWall()&#123; System.out.println("高楼打砌墙20cm"); &#125; public void roofed()&#123; System.out.println("高楼打顶"); &#125;&#125;...//可扩展房子类型 //建造指挥public class HouseDirector&#123; HouseBuilder houseBuilder = null; //构造器传入houseBuilder public HouseDirector(HouseBuilder houseBuilder)&#123; this.houseBuilder = houseBuilder; &#125; //setter传入houseBuilder public void setHouseBuilder(HouseBuilder houseBuilder)&#123; this.houseBuilder = houseBuilder; &#125; public House constructHouse()&#123; houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); &#125;&#125;//用户public class Client&#123; public static void main()&#123; CommonHouse commonHouse = new CommonHouse(); HouseDirector houseDirector = new HouseDirector(commonHouse); House house = houseDirector.constructHouse(); &#125;&#125; 未完待续…]]></content>
      <categories>
        <category>技术</category>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>设计模式，创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数码人像摄影读书笔记与实战]]></title>
    <url>%2F%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1%E4%B8%8E%E5%90%8E%E6%9C%9F.html</url>
    <content type="text"><![CDATA[人像摄影是摄影门类中难较高的。最近读了《品像–数码人像摄影与后期专业教程》这本书，作者徐阳。介绍了各种摄影技巧，本文就其中的几个点做一个笔记。 上一篇博客记录了风光摄影中的一些专业知识和技巧，关于器材和相机的相关概念类似，不作过多描述。那么直接进入主题。 拍摄技法 摇拍是一种拍摄移动中的被摄体的技法，以摇动镜头的方式跟随被摄体来表现其速度感。 俯拍有利于表现地平面上景物层次、数量、位置等，给人一种辽阔深远的感受。 仰拍有利于突出被摄体高大的气势，能将树这样向上生长的景物在画面上充分展开。仰拍人物时要注意，脸部较胖的尽量不要这样拍。 平摄人物活动的场面，能让人感到平等、亲切。 多次曝光是在一幅胶片或感光器上拍摄几个影像。 人像基本构图同风光摄影的构图有很多相似之处，人物摄影的主体是人，将人放在画面中的什么位置，如何突出人物主体的地位是应该考虑的问题。 构图 井字构图是一个万能的选择。 中央构图可以配合其他的因素增加图片的分量。 对角线构图可以使画面活力大增，可以包含人身体的各个部位。 开放式构图强调画面内外的联系。 留白式构图可以使观者的思维有所联想和延伸，能产生遐想。 双重架构式构图可以使画面产生远近，明暗，虚实等装饰效果。 大景别构图常用在风景优美广阔或大气巍峨的地点来拍摄人像，为避免环境喧宾夺主，可以从环境与人物的虚实、明暗、色彩、质感、动静等的对比达到拍摄意图。 透视构图可以由空间线条聚焦到被摄体。 人像公式化构图人像公式化构图可分为特写、半身、七分身、九分身和全身等构图类型。 特写与半特写对见于影视和妆面的拍摄，以头顶到胸为构图框线，对被摄者要求面容姣好，表现力强。 半身构图以头部至腰胯部为构图框，加入了部分肢体。 七分身构图到膝盖部位上下。九分身构图到脚踝，要求被摄者的小腿部分漂亮。 全身一般为带背景内容的人像照片。 摆姿技巧这部分内容不仅可以在拍摄模特的时候使用，在平常的摆拍中也可以用到，可以说拯救姿势废。 各种姿势站姿、坐姿、躺卧姿、蹲姿、跪姿、趴姿、跳姿、手姿。 一般常见的站姿有S形，三角形和斜线型。在表现坐姿时注意坐下时应尽量虚坐在椅子边缘。 躺卧姿可以非常好的突出女性的柔美曲线，采用躺姿时可以利用手臂的支撑来营造肢体的变化，可采用水平线对角线等构图方法。 跪姿非常适合表现女性妖娆性感的一面。 趴姿中手臂的动作很重要。 跳姿在于拍摄者的抓拍。 疼痛法摆姿虽然疼痛法在美姿中已提出好多年，但是拍摄过程中它还是一个屡试不爽的技巧。可以牙疼、轻度头疼、重度头痛、脖子疼、胸疼、腰疼、肚子疼、腿疼、脚疼，身体尽量避免出现平行或垂直的线条。 背景与人物背景对一幅人像作品的成败起了举足轻重的作用，利用好人物与环境背景的明暗对比，色彩对比，疏密对比，虚实对比，体积对比，曝光对比，动静对比关系等，会有意想不到的效果。 实战有人说摄影是熟练工种，也对，但是再想想，哪种艺术不是熟练工种？ 我常会被摄影技巧打动，但我不太喜欢这个词，我之所以为它所动，是因为真正好的技巧之听命于神秘的内心世界。–戴安·阿勃斯(Diane Arbus) —- 5.27更新 —-在接触了真实的相机之后发现第一次看书时忽略的内容都很重要，在此补上一些重要概念。本次实践使用的相机是佳能700D。半按快门对焦后完全按下快门拍摄。 光线的应用光比，亮部与暗部，光比扩大会增加层次感，轮廓硬朗。可以在亮部测出光圈大小，暗部测出光圈大小。相差1级光圈光比为2：1，相差2级光圈光比为4：1，相差3级光圈光比为8：1.大于8属于大光比。更容易控制高调和低调的照片。硬调和柔调，分别表示亮暗的过度程度。大部分照片硬调更好看。曝光宽容度。利用宽容度有限可以创造出于人眼效果不同的效果。 闪光灯及应用在光线昏暗的环境下拍照，如果使用闪光灯加较快的快门拍摄，容易造成前景主体太亮，而背景依旧昏暗，无法辨别细节。而慢速闪光同步会延迟数码相机的快门释放速度，以闪光灯照明前景，配合慢速快门（如1/15s）为弱光背景曝光。这样就能摄出前后景均得到和谐曝光的照片。 前帘同步闪光是指先闪光，主要用于在光线较暗的时候拍清楚主体。后帘同步闪光主要用于运动的物体拍摄。拍摄时后帘同步开启，快门开启，拉出一串运动的影像，最后闪光灯开启，将主体定格。特殊效果用于表现运动。前后帘在快门速度比较满时比较明显。闪光灯的光会快速的衰减。闪光灯摄影快门不是控制因素。 闪光灯曝光控制闪光灯曝光控制，可以减少或增加闪光补偿来控制。暗光情况使用闪光灯应该适当增加ISO，慢速快门。 使用方法弱光增强；强光补光；增加眼神光；创意闪光。 测光测光分为评价测光，中央重点平均测光和点测光。 中央重点平均测光可以说是人像拍摄独享的测光模式，非常适合画面中央被摄主体亮度均匀而主体周围光线变化较大的场合。 点测光可以精准控制曝光，是针对画面中央极小范围进行测光的模式。 相机的设置 拍摄模式的选择一般情况下对于人像拍摄使用更多的是光圈优先曝光和手动曝光。白平衡放在自动档（配合jpg格式照片），对焦用的更多的是中心点对焦和单次对焦。 测光模式测光方式用中央重点和点测光。因为作为人像拍摄，首先要保证所拍人物的正确曝光。特写的拍摄用局部测光，更精细的拍摄，逆光等使用点测光，光比比较大的场景中用中央重点平均测光。 ISO调整光线允许的情况下设为100或200. ISO一般情况下越低越好。光线较暗，阴天的傍晚可以选择400，室内光线较暗可以选择800，偷拍可以选择1600。感光度越高，照片质量越粗糙。 自动化亮度启动自动亮度优化虽然会拖慢机内处理速度但是拍人像无所谓。 光圈一般镜头会用到的光圈号数为f/2.8~f/22.光圈优先AE是一种在人像和风光摄影中都最常用的自动曝光方式。 曝光如何准确曝光，测光表标尺到零就可以准确曝光。标尺在负的一端时，可以先将光圈缩小，接下来再考虑转动快门。如果标尺在正的一端，光圈增大，接下来转动快门，增快快门速度。快门速度过快时，手很难端稳，可以选择三脚架或者开闪关灯。手动模式M下可以拨动轮盘调节快门，Av+轮盘调节光圈。 拍摄人像时的两种常用镜头 原厂镜头和副厂镜头副厂镜头有些品质不输原厂，而且价格比原厂便宜。 变焦镜头和定焦镜头24~70mm或24~120mm属于标准变焦镜，70~200mm或70~300mm属于望远变焦镜。50mm、85mm和135mm属于定焦镜头，这些镜头都可以用来拍摄人像。长焦端的镜头景深浅。初学者可以优先使用中望远镜头入手。 夜间拍摄 夜景采用广角镜头摄影，风光摄影。拍摄地点多为俯拍，增加画面中的信息量。夜景广角镜头是一个较好的镜头，感光度ISO应尽量低，快门速度慢（无法手端），产生了长时间曝光。利用三脚架取景，辅助使用快门线实现闭门。降噪功能设为自动时在镜头速度较慢的时候打开。白平衡设置5500以上色温，低色温显示冷调，也可以直接设置为钨丝灯模式。对焦选择单次对焦。面对白纸时会对焦失败，采用手动对焦，拨动对焦环即可。建议使用平均测光。建议使用小光圈，让光源表现出星芒。小光圈8 11 16等成像质量会更好。如果拍摄的不是大场景可以使用大光圈。夜景摄影没有苛刻的曝光要求。拍摄夜景避免大光源入镜。 拍摄夜景人像使用快门优先，慢速快门可以拍背景，前景由闪光灯照亮。焦距短一点，光圈收小一些。ISO可以使用400~800， 稍大的F4、F2.8的光圈。找到合适的快门，在此快门基础上减少一道两级的曝光。白平衡模式使用闪光灯，设置后帘同步。要搞清楚闪光灯的范围，不超过5m。快门最好用脚架。拍摄人像可以采用中长焦。85mm以上。]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
        <category>人像摄影</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>人像摄影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[风光摄影读书笔记]]></title>
    <url>%2F%E9%A3%8E%E5%85%89%E6%91%84%E5%BD%B1.html</url>
    <content type="text"><![CDATA[Everything you need to know about landscape photography techniques and subjects.一直都很想学习摄影，虽然没有专业器材，但用手机镜头记录下生活的点点滴滴也是一件美好的事情。正值毕业季，为了在校园拍出美美的回忆，去图书馆补充了一下专业知识《风光摄影圣经》。本篇博客作为一个风光摄影的读书笔记。 风光摄影的前期准备在进行摄影之前需要先对摄影的器材和名词了解一下。 相机相关概念风光摄影要求照片的暗部细节有很好的表现，意味着相机要有较高的色彩宽容度和分辨率。 镜头的分类 广角镜头分两种，普通广角镜头焦距一般在24~38mm，超广角镜头的焦距为13~24mm。广角镜头景深比较大，可以有效的夸张前景和表现景物的远近层次。 标准镜头是与人眼的视角相近的镜头，国际标准为50mm。一般用于空中拍摄，或者近距离风光拍摄和中景特写。 长焦镜头通常焦距在70~400mm之间。长焦镜头可以将远处的景物拉近拍摄，产生空间压缩的效果，还可以作为特写镜头。 变焦镜头的画质要略逊色于定焦镜头。镜头的分类在使用AE搭建场景的时候已经初步接触，在这里再次遇到做个整理。贴上AE中运用摄像机做的镜头模仿练习。 光圈和景深 光圈是相机上用来控制镜头孔径大小的部件。光圈f值=镜头的焦距/镜头口径的直径。光圈f值越小，在同一单位时间内的进光量便越多，而且上一级的进光量刚好比下一级的多一倍。利用小光圈可以获得大景深。在风光摄影中，中景，全景，远景等景别适合用小光圈拍摄增加纵深感。 景深是焦点前后的一段能清晰显示的景物的清晰度范围。拍摄花和昆虫的照片中将背景拍的很模糊为小景深，将背景与被摄主体拍的一样清晰为大景深。影响景深的因为有光圈，焦距和物距三大方面。景深的使用，在3d建模的过程中接触过，保留模型的景深导入AE进行后期处理，可以营造很好的空间效果。 不同的快门低速快门可以虚化动体，制造出虚实相衬的效果，将画面拍出动感，比如烟雾缭绕的感觉。而高速快门可以凝固动体，可以清晰的记录快速运动中的物体，高速快门的应用在于时机的捕捉。下图为低速快门图，图源网络。第一次见到低速快门拍照的照片，真实的仙境感。 取景拍摄可以根据景物的特点选择横画幅和竖画幅，拍照时将手机持平，使照片内的地平线水平，给人以平稳安定的感觉，一般忌讳将地平线居中。照片要吸引观众的视线，给人留下深刻印象，这就要画面的趣味点，我们可以用前景的物体使得普通的风光照片更有趣味性。不同的景别： 近景所展现的主体细节更丰富。中景经常记录我们眼前发生的事物，常常以动作或情节取胜。全景可以完整的表现主体的形体及周遭环境。远景画面开阔，景深悠远。 用光与构图光影变换塑造了不同风格的画面，是拍照中不可忽略的因素，虽然影子影响画面的美观，但是用好影子也会有意想不到的效果。 光线 顺光拍摄给人明亮晴朗的感觉。 侧光拍摄可以产生具有明显方向性的投影，具有非常好的造型效果。前侧光使画面更加丰富；正侧光是的画面有一个非常明显的过渡，除了拍摄要求显示凹凸明显的碑刻等物体外，很少使用；后侧光多用于艺术创作，纵深感强。 逆光塑造独特的效果。拍摄透明，半透明的物体逆光为最佳光线。 眩光在光线和拍摄主题合适时，只要曝光合适，再结合良好的构图和被摄主体，往往会得到神奇的戏剧化效果。 构图巧妙的构图是一种艺术，是一种美学概念。 总感觉自己拍出来的照片很难看，原来是从来没有注意过构图，一直都是凭感觉瞎拍，学了构图以后也可以实践一番了。构图不仅在拍照中会用到，画画和搭建场景中都会用到。 经典的三分法即黄金分割法。 S形构图动感效果强，既动又稳。远景俯拍效果最佳，适合山川河流的自然起伏和人体动物物体的曲线排列变化。 A形构图具有向上的冲击力和强劲的视觉引导力。适合拍摄眼神的长路，长桥和高耸的建筑物。 O形构图稳定感强。 斜线构图能形成深度空间，使画面具有活力，还能形成指向性，同时给人以三位空间感。溪流、铁轨、小路、围栏、墙壁、篱笆、电线以及远景中的道路桥梁都可以做斜线。 对角线构图，具有方向感，动感和活泼。线条汇聚，吸引人们的视线。 曲线构图。 稳定的三角形构图。 漂亮的放射形构图，常用于要突出主体，而场面又复杂的场合。 突出主体的框架式构图，一般用于有前景的拍摄， 比如利用门窗，山洞口，其他框架作为前景。本文没能加入很多的图片说明，这里有前人的构图总结。希望在今后的拍照运用中逐渐实践学到的方法，创建属于自己的作品图库。 色彩探索不同的色彩能使人产生不同的官能感觉。暖色调使人感到热烈兴奋，冷色调使人感到优雅，宁静。在摄影中如何搭配色彩构成画面，什么样的色彩搭配在一起更加漂亮，这是每个摄影人必须学会的理论知识。色彩之间的搭配主要有富有烘托效果的同类色(45deg)，具有表现效果的互补色(150~180deg)，效果和谐的相邻色(90deg以内)，突出主体的对比色(对比形式多样，有冷暖，补色，明暗的对比。红与绿，蓝与黄石互补色。)等几个分类。 有时会觉得拍照就是一个高级的绘画过程，逼真的展现事物的原貌，同样考虑到了构图，光影，色彩，可以说艺术是相通的吧。读书笔记中有很多没有记录到的内容，比如测光与曝光，焦点的选择，滤镜的选择。这本书后几章的拍摄实践包括山水美景，冰雪云雾和日月星辰，提供了很多实用的拍摄tips，但是技巧都是在实践中磨练的，就不在这里记录了。等上手实践之后再来更新。 参考书籍：风光摄影圣经 –创造影像]]></content>
      <categories>
        <category>生活</category>
        <category>摄影</category>
        <category>风光摄影</category>
      </categories>
      <tags>
        <tag>风光摄影</tag>
        <tag>镜头</tag>
        <tag>构图</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建博客初体验]]></title>
    <url>%2F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%88%9D%E4%BD%93%E9%AA%8C.html</url>
    <content type="text"><![CDATA[Welcome to my blog.This is my very first post.折腾了好几天hexo配合github搭建博客成功，需要优化的还有很多，需要学习的技能也好多。建博客的过程中，遇到了好多问题，看教程的时候仿佛大家都水到渠成，只有我和成功之间隔着千山万水。ORZ记录一下遇到的问题和解决方法。 hexo+github搭建博客雏形首先感谢打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化手把手教程。 题外话之修改hosts访问google首先翻墙是一项必备技能，根据老D博客里的步骤替换hosts，出现了一些问题，目前仍然没能找到翻墙的正确姿势。 hostipconfig/flushdns 无法使用：查找后可以通过设置path解决。 出现了谷歌学术搜索页面，但是搜索会显示“请进行人机身份验证”。 前奏之安装node.js和git教程里很清楚了，不再赘述。安装之后用下述代码查看是否安装成功：12$ git --version$ node -v 安装hexo做好前期准备开始安装hexo，血泪史，因为版本问题导致的惨剧，是谁说的warn信息都不用管的。 报错：local hexo not found in xxx:在网上各种搜索，删除项目中的package.json,执行npm init生成新的package.json替换，虽然不再报错，但是出现了新问题。 返回usage信息，hexo命令干脆不能用了，倒腾一晚上，git和nodejs确实装好了，也不是运行命令的目录不正确，最后考虑是环境变量问题。直到第二天重装node.js，确认问题是node.js版本过低所致。 部署到github报错：could not read from remote repository经过检查发现是github项目名称写错。真是时常被自己蠢哭。 发文至此，终于在建好了博客雏形，看到网页的时候感动哭。先发文看看。 编辑博文并发表markdown是一种标记性语言，第一次接触也可以上手很快。新手速成看这里 中文乱码：多半是编码问题，换个编码方式编辑。使用UTF-8编码方式，成功解决。 如何更新博客： 12345$ hexo new "Hello world"$ hexo clean$ hexo g -d$ hexo s 网易云音乐产生外部链接http://link.hhtjim.com/163/xxx.mp3 将歌曲链接的对应id替换xxx位置即可安装插件aplayer之后插入博客中见下图： var ap = new APlayer({ element: document.getElementById("aplayer-OcGifSKl"), narrow: false, autoplay: false, showlrc: false, music: { title: "Hit and Run", author: "Lolo", url: "https://link.hhtjim.com/163/28987151.mp3", pic: "https://i.loli.net/2019/05/09/5cd41d6fa31f5.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 插入图片七牛云倒腾半天，发现提供的免费域名只能用30天， 为了图片不失效，只能买自己的域名。目前由于懒就用了在线图床SM.MS。这里有关于图床的一些介绍。 副本之博客优化光秃秃的博客是没有灵魂的，接下来可以开始装装点点，开始幸福生活啦。 一个好的博客既要有好的内容，也要有漂亮的外在，门面嘛，既然要经营就要从内到外到经营好，于是开启了副本之漫长的优化之路。先写到这里，优化虽然跟着教程做了一些有了一些理解，等补一些之后再来更新。 未完待续~ 2021/06/01 时间一晃，博客优化还是没做哈哈哈，瞎折腾太累了。补充一下以前存的教程贴。 hexo搭建博客篇基于Hexo+Github+Coding搭建个人博客-基础篇 基于Hexo+Github+Coding搭建个人博客-进阶篇 博主整理的还是挺清楚的。很久之前参照进阶篇进行了搜索引擎优化，好像也没有用到，依旧是没人看的小博客orz。 Google Analytics教程,谷歌分析使用方法教程 突然发现适配手机端的教程挂掉了，啊.. 界面美化篇Hexo 博客优化之实用功能添加系列 Hexo 博客优化之博客美化系列 Hexo 博客添加各种有趣又有用的小功能 评论篇评论之前是用着valine，但是由于leancloud要求实名认证，不能用了，好吧，就很久没评论区了。 为你的Hexo加上评论系统-Valine gitment也试过，不知道什么问题不能用，人懒，先算了吧，反正也不会有人评论的。 Hexo-Next 添加 Gitment 评论系统 先这样吧]]></content>
      <categories>
        <category>技术</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hosts</tag>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
