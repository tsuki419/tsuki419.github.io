<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tsuki&#39;s CodeLife</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tsuki419.github.io/"/>
  <updated>2020-11-08T05:50:59.837Z</updated>
  <id>https://tsuki419.github.io/</id>
  
  <author>
    <name>tsuki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>9月leetcode刷题总结</title>
    <link href="https://tsuki419.github.io/9%E6%9C%88leetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>https://tsuki419.github.io/9月leetcode刷题总结.html</id>
    <published>2020-11-08T03:42:31.030Z</published>
    <updated>2020-11-08T05:50:59.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>刚开始刷题大部分都不会，有的题有思路但是代码写不明白，参考了很多官方和评论区大佬的答案，学到了很多。解答用的语言是c++，在边学边用，官方的STL库还不熟悉，菜鸟如我经常搞错vector的用法。</p><a id="more"></a> <p>本来打算九月底发的博客拖到了现在(十一月初），十月也没有继续刷题。开始准备做项目不由感叹门外汉入门真是不容易，什么都不会，扶额。</p><p>这一个月做过的题类型有，回溯算法加剪枝， 二叉树的遍历和递归， 并查集等等。</p><h2 id="回溯算法加剪枝"><a href="#回溯算法加剪枝" class="headerlink" title="回溯算法加剪枝"></a>回溯算法加剪枝</h2><p>一直碰到用回溯算法就歇菜。现在还没有完全掌握。</p><p>回溯算符与递归的区别在于，回溯过程中达到结束条件要恢复状态回溯到上一层，再次搜索，而递归是一个劲往某个方向。回溯与DFS的区别就是有无状态的重置。在题解区看到<a href="https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/" target="_blank" rel="noopener">答主</a>的回答颇有所获，非常感谢。但是实际应用中画出递归树不好理解。</p><h3 id="子集和组合"><a href="#子集和组合" class="headerlink" title="子集和组合"></a><strong>子集和组合</strong></h3><p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">leetcode78 子集，</a><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">leetcode 90子集2</a>使用了剪枝。使用了start变量。</p><p>参考了官方的答案，递归枚举类题的包括以下几个步骤：</p><ol><li><p>画出递归树（关键</p></li><li><p>递归边界，记录的条件</p></li><li><p>设置了vector: temp当前的记录，vector&lt;vector&lt;&gt;&gt;: ret返回所有的记录</p></li><li><p>判断是否需要剪枝处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(nums.begin(), nums.end());</span><br><span class="line"><span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组合中可以选择或者不选择当前位置，之后递归考虑下一个位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temp.push_back(cur);</span><br><span class="line">dfs(cur + <span class="number">1</span>);</span><br><span class="line">temp.pop();</span><br><span class="line">dfs(cur + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><p>（事实告诉我们不要写一半跑路，时隔一个月我已经看不懂之前写的了，趁着快要考试继续做算法总结</p><p><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">组合</a>中配合使用了剪枝来减少时间。</p><p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a>中传入了target变量。</p><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">组合总和2</a>使用了剪枝。</p><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">全排列</a>，<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">全排列2</a>设置了visited数组。</p><p>核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[i] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">    visited[i] = <span class="literal">true</span>;</span><br><span class="line">    temp.push_back();</span><br><span class="line">    dfs();</span><br><span class="line">    visited[i] = <span class="literal">false</span>;<span class="comment">//回退</span></span><br><span class="line">    temp.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑剪枝处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort(nums.begin(), nums.end());</span><br><span class="line"><span class="comment">// i &gt; 0 是为了i - 1 有效</span></span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>])&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h2 id="二叉树遍历递归"><a href="#二叉树遍历递归" class="headerlink" title="二叉树遍历递归"></a>二叉树遍历递归</h2><p><strong>层次遍历</strong></p><p>二叉树层次遍历和层次相关时，可以用queue.size()获取一层的个数，一层一层的处理。如<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">leetcode 637，二叉树层平均值</a>，<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">leetcode 117，层链接</a></p><p><strong>深度优先遍历</strong></p><p><strong>先序中序和后序遍历</strong></p><p>相关于二叉树的题十有八九是递归算法，属于有思路但是写出来的代码总有逻辑错误的题，栈溢出，多半是递归边界问题，还有递归的参数没弄对。</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚开始刷题大部分都不会，有的题有思路但是代码写不明白，参考了很多官方和评论区大佬的答案，学到了很多。解答用的语言是c++，在边学边用，官方的STL库还不熟悉，菜鸟如我经常搞错vector的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="算法" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="回溯算法" scheme="https://tsuki419.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://tsuki419.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="并查集" scheme="https://tsuki419.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://tsuki419.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://tsuki419.github.io/设计模式.html</id>
    <published>2020-11-08T03:42:31.020Z</published>
    <updated>2020-11-08T04:07:56.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>十月间断的学了一些设计模式。这是个长久的课程，还没有学会怎么实际运用到项目中。</p><p>跟随着视频<a href="https://www.bilibili.com/video/BV1G4411c7N4?p=4" target="_blank" rel="noopener">来学</a>。</p><a id="more"></a> <p><strong>为什么</strong>学习设计模式？</p><p>为了让程序具有更好的代码重用性，可读性，可扩展性，可靠性，使程序呈现<strong>高内聚，低耦合</strong>的特性。</p><p><strong>什么时候用到</strong>设计模式？</p><p>面向对象（oo）=&gt; 功能模块[设计模式 + 算法（数据结构）] =&gt; 框架[ 多种设计模式 ] =&gt; 架构[ 服务器集群 ]</p><p><strong>学习步骤</strong></p><p>应用场景 –&gt; 设计模式 –&gt; 剖析原理 –&gt; 分析实现步骤（图解，类图） –&gt; 代码实现 –&gt; 框架或项目源码分析的步骤讲解</p><h2 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h2><p>设计模式为什么这样设计的原则。    </p><blockquote><p>字符流会查码表，字节流不查码表</p><p>编码：字符—&gt;码表—&gt;数字</p><p>解码：数字—&gt;码表—&gt;字符</p><p>Reader默认查询的码表是与操作系统一致的码表，操作系统是中文的，所以reader使用GBK码表</p><p>java查的是unicode的码表</p></blockquote><p><strong>1. 单一职责原则</strong></p><p>一个类只负责一个职责。</p><p><strong>2. 接口隔离原则</strong></p><p>使用多个单独的接口。</p><p><strong>3. 依赖倒转原则</strong></p><p>其核心是面向接口编程（即抽象类）。</p><p><strong>4. 迪米特法则（最少知道原则）</strong></p><p>体现了封装的思想。可以适当违反。</p><p><strong>5. 开闭原则OCP</strong></p><p>对扩展开放，对修改关闭。</p><p><strong>6. 里氏替换原则</strong></p><p>oo中继承的思考。</p><p>所有引用基类的地方必须能透明的使用其子类的对象。</p><p>使用继承时尽量不要重写父类的方法。</p><p>创建一个更加基础的类。使用依赖，聚合，组合的关系。</p><p><strong>7. 合成复用原则</strong></p><p>尽量使用合成聚合的方式，而不是使用继承。</p><h2 id="UML语言介绍"><a href="#UML语言介绍" class="headerlink" title="UML语言介绍"></a>UML语言介绍</h2><p>统一建模语言。</p><p><strong>类图-依赖关系（Dependence）</strong>只要在类中用到了对方，他们就存在依赖关系。</p><p><strong>类图-泛化关系（generalization）</strong>，就是继承关系，是依赖关系的特例。</p><p><strong>类图-实现关系（Implement）</strong>，是依赖关系的特例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Interger id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceBean</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Interger id)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类图-关联关系（Association）</strong></p><p>类与类之间的联系，是依赖关系的特例。有单向和双向关系。</p><p><strong>类图-聚合关系（Aggregation）</strong> 整体与部分的关系，整体与部分可以分开。比如Person和IDCard。聚合式关联关系的特例。</p><p><strong>类图-组合关系（Composition）</strong>也是整体与部分的关系，但是整体与部分不可以分开。例如Person和head。同生共死的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">    <span class="keyword">private</span> Head head = <span class="keyword">new</span> head();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDCard</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><p><strong>主要步骤：</strong></p><p>1) 构造器私有化 (防止 new )</p><p>2) 类的内部创建对象</p><p>3) 向外暴露一个静态的公共方法</p><p><strong>饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本类内部创建对象实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//提供一公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instantce;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点：写法简单，在类装载的时候完成实例化，避免了线程同步问题，没有达到懒加载的效果。</p><p>可用，但会造成内存的浪费。</p><p><strong>双重检查</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;<span class="comment">//volatile可以实现立刻写到内存中</span></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Double-Check是多线程开发中常使用的。线程安全，延迟加载，效率较高。</p><p><strong>静态内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//写一静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一静态的公有方法，直接返回 SingletonInstance.INSTANCE。   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。避免了线程不安全，利用静态内部类特点实现延迟加载，效率高。推荐使用。</p><p><strong>枚举法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。这种方式是 <strong><em>\</em>Effective**</strong> <strong><em>\</em>Java**</strong> 作者 <strong><em>\</em>Josh**</strong> <strong><em>\</em>Bloch**</strong>  提倡的方式.推荐使用</p><h3 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2. 简单工厂模式"></a>2. 简单工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoodFactory</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title">getFood</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Food food = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(n)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                food = <span class="keyword">new</span> Hamburger();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                food = <span class="keyword">new</span> RiceNoodle();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>服务器修改了具体产品的类名后，客户端不知道。</p><p>工厂的实现不易于扩展，违反了ocp原则，故引入了工厂方法模式。</p><h3 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="3. 工厂方法模式"></a>3. 工厂方法模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">food</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hamburger</span> <span class="keyword">implements</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃汉堡！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RiceNoodle</span> <span class="keyword">implements</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃米线！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//食物工厂</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FoodFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HamburgerFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RiceNoodleFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RiceNoodle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FoodFactory ff = <span class="keyword">new</span> HamburgerFactory();</span><br><span class="line">    Food food = ff.getFood();</span><br><span class="line">    food.eat();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂的名字是视为接口的，是趋向稳定的。</p><p>但是当种类很多时，会造成类爆炸式增长，于是引入抽象工厂。</p><h3 id="4-抽象工厂"><a href="#4-抽象工厂" class="headerlink" title="4. 抽象工厂"></a>4. 抽象工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drink <span class="title">getDrink</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hamburger();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drink <span class="title">getDrink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cola();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SanQinFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论有多少产品等级，工厂就一类。</p><p>冰箱电视洗衣机视为<strong>产品等级</strong>，工厂厂家海尔海信华为系列产品视为<strong>产品簇</strong>。虽然新增一个工厂很便捷，但抽象工厂扩展产品等级需要所有的工厂都修改，用Spring框架解决。</p><p>抽象工厂中可以生产多个产品，这多个产品之间<strong>必有内在联系</strong>。同一个工厂中的产品都属于一个<strong>产品簇</strong>。</p><h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5. 原型模式"></a>5. 原型模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name,<span class="keyword">int</span> age, String color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供对外的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//克隆该实例</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sheep = (Sheep)<span class="keyword">super</span>.clone();<span class="comment">//sheep是object，但是object不一定是sheep</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java中的Object类是所有类的根类，Object类提供了一个clone()的方法。需要实现clone的java类必须实现一个接口Cloneable，该接口表示该类能复制且有复制的能力。</p><p>上例的clone实现使用了默认的clone()，是浅拷贝，要实现深拷贝可以采用重写clone函数或者<strong>序列化</strong>。</p><p>c++可以用<strong>拷贝构造函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~ISplitter()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BinarySplitter(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-建造者模式"><a href="#6-建造者模式" class="headerlink" title="6. 建造者模式"></a>6. 建造者模式</h3><p>建造产品的过程的产品解耦合？</p><p>与工厂模式的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Product</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String baise;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String roofed;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBaise</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBaise</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baise = baise;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> House house = <span class="keyword">new</span> House();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">buildHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子打地基5m"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子打砌墙10cm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子打顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"高楼打地基100m"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"高楼打砌墙20cm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"高楼打顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">//可扩展房子类型</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//建造指挥</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span></span>&#123;</span><br><span class="line">    HouseBuilder houseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造器传入houseBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//setter传入houseBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">constructHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">        HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector(commonHouse);</span><br><span class="line">        House house = houseDirector.constructHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;十月间断的学了一些设计模式。这是个长久的课程，还没有学会怎么实际运用到项目中。&lt;/p&gt;
&lt;p&gt;跟随着视频&lt;a href=&quot;https://www.bilibili.com/video/BV1G4411c7N4?p=4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来学&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="设计模式" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，创建型模式" scheme="https://tsuki419.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数码人像摄影读书笔记与实战</title>
    <link href="https://tsuki419.github.io/%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1%E4%B8%8E%E5%90%8E%E6%9C%9F.html"/>
    <id>https://tsuki419.github.io/人像摄影与后期.html</id>
    <published>2019-05-24T06:28:22.000Z</published>
    <updated>2019-06-01T05:04:14.931Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>人像摄影是摄影门类中难较高的。最近读了《品像–数码人像摄影与后期专业教程》这本书，作者徐阳。介绍了各种摄影技巧，本文就其中的几个点做一个笔记。<br><a id="more"></a> </p><p>上一篇博客记录了<a href="https://tsuki419.github.io/风光摄影.html">风光摄影中的一些专业知识和技巧</a>，关于器材和相机的相关概念类似，不作过多描述。那么直接进入主题。</p><h2 id="拍摄技法"><a href="#拍摄技法" class="headerlink" title="拍摄技法"></a>拍摄技法</h2><ul><li><strong>摇拍</strong>是一种拍摄移动中的被摄体的技法，以摇动镜头的方式跟随被摄体来表现其速度感。</li><li><strong>俯拍</strong>有利于表现地平面上景物层次、数量、位置等，给人一种辽阔深远的感受。</li><li><strong>仰拍</strong>有利于突出被摄体高大的气势，能将树这样向上生长的景物在画面上充分展开。仰拍人物时要注意，脸部较胖的尽量不要这样拍。</li><li><strong>平摄</strong>人物活动的场面，能让人感到平等、亲切。</li><li><strong>多次曝光</strong>是在一幅胶片或感光器上拍摄几个影像。</li></ul><h2 id="人像基本构图"><a href="#人像基本构图" class="headerlink" title="人像基本构图"></a>人像基本构图</h2><p>同风光摄影的构图有很多相似之处，人物摄影的主体是人，将人放在画面中的什么位置，如何突出人物主体的地位是应该考虑的问题。</p><h3 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h3><ul><li>井字构图是一个万能的选择。</li><li>中央构图可以配合其他的因素增加图片的分量。</li><li>对角线构图可以使画面活力大增，可以包含人身体的各个部位。</li><li>开放式构图强调画面内外的联系。</li><li>留白式构图可以使观者的思维有所联想和延伸，能产生遐想。</li><li>双重架构式构图可以使画面产生远近，明暗，虚实等装饰效果。</li><li>大景别构图常用在风景优美广阔或大气巍峨的地点来拍摄人像，为避免环境喧宾夺主，可以从环境与人物的虚实、明暗、色彩、质感、动静等的对比达到拍摄意图。</li><li>透视构图可以由空间线条聚焦到被摄体。</li></ul><h3 id="人像公式化构图"><a href="#人像公式化构图" class="headerlink" title="人像公式化构图"></a>人像公式化构图</h3><p>人像公式化构图可分为<strong>特写、半身、七分身、九分身和全身</strong>等构图类型。</p><ul><li>特写与半特写对见于影视和妆面的拍摄，以头顶到胸为构图框线，对被摄者要求面容姣好，表现力强。</li><li>半身构图以头部至腰胯部为构图框，加入了部分肢体。</li><li>七分身构图到膝盖部位上下。九分身构图到脚踝，要求被摄者的小腿部分漂亮。</li><li>全身一般为带背景内容的人像照片。</li></ul><h2 id="摆姿技巧"><a href="#摆姿技巧" class="headerlink" title="摆姿技巧"></a>摆姿技巧</h2><p>这部分内容不仅可以在拍摄模特的时候使用，在平常的摆拍中也可以用到，可以说拯救姿势废。</p><h3 id="各种姿势"><a href="#各种姿势" class="headerlink" title="各种姿势"></a>各种姿势</h3><p>站姿、坐姿、躺卧姿、蹲姿、跪姿、趴姿、跳姿、手姿。</p><ul><li>一般常见的站姿有S形，三角形和斜线型。在表现坐姿时注意坐下时应尽量虚坐在椅子边缘。</li><li>躺卧姿可以非常好的突出女性的柔美曲线，采用躺姿时可以利用手臂的支撑来营造肢体的变化，可采用水平线对角线等构图方法。</li><li>跪姿非常适合表现女性妖娆性感的一面。</li><li>趴姿中手臂的动作很重要。</li><li>跳姿在于拍摄者的抓拍。</li></ul><h3 id="疼痛法摆姿"><a href="#疼痛法摆姿" class="headerlink" title="疼痛法摆姿"></a>疼痛法摆姿</h3><p>虽然疼痛法在美姿中已提出好多年，但是拍摄过程中它还是一个屡试不爽的技巧。可以牙疼、轻度头疼、重度头痛、脖子疼、胸疼、腰疼、肚子疼、腿疼、脚疼，身体尽量避免出现平行或垂直的线条。</p><h2 id="背景与人物"><a href="#背景与人物" class="headerlink" title="背景与人物"></a>背景与人物</h2><p>背景对一幅人像作品的成败起了举足轻重的作用，利用好人物与环境背景的明暗对比，色彩对比，疏密对比，虚实对比，体积对比，曝光对比，动静对比关系等，会有意想不到的效果。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>有人说摄影是熟练工种，也对，但是再想想，哪种艺术不是熟练工种？</p><blockquote><font color="#2da5da"><em>我常会被摄影技巧打动，但我不太喜欢这个词，我之所以为它所动，是因为真正好的技巧之听命于神秘的内心世界。<br>–戴安·阿勃斯(Diane Arbus)</em></font></blockquote><p>—- 5.27更新 —-<br>在接触了真实的相机之后发现第一次看书时忽略的内容都很重要，在此补上一些重要概念。本次实践使用的相机是佳能700D。半按快门对焦后完全按下快门拍摄。</p><h3 id="光线的应用"><a href="#光线的应用" class="headerlink" title="光线的应用"></a>光线的应用</h3><p>光比，亮部与暗部，光比扩大会增加层次感，轮廓硬朗。可以在亮部测出光圈大小，暗部测出光圈大小。相差1级光圈光比为2：1，相差2级光圈光比为4：1，相差3级光圈光比为8：1.大于8属于大光比。更容易控制高调和低调的照片。<br>硬调和柔调，分别表示亮暗的过度程度。大部分照片硬调更好看。<br>曝光宽容度。利用宽容度有限可以创造出于人眼效果不同的效果。</p><h3 id="闪光灯及应用"><a href="#闪光灯及应用" class="headerlink" title="闪光灯及应用"></a>闪光灯及应用</h3><p>在光线昏暗的环境下拍照，如果使用闪光灯加较快的快门拍摄，容易造成前景主体太亮，而背景依旧昏暗，无法辨别细节。而慢速闪光同步会延迟数码相机的快门释放速度，以闪光灯照明前景，配合慢速快门（如1/15s）为弱光背景曝光。这样就能摄出前后景均得到和谐曝光的照片。</p><ul><li>前帘同步闪光是指先闪光，主要用于在光线较暗的时候拍清楚主体。<br>后帘同步闪光主要用于运动的物体拍摄。拍摄时后帘同步开启，快门开启，拉出一串运动的影像，最后闪光灯开启，将主体定格。特殊效果用于表现运动。<br>前后帘在快门速度比较满时比较明显。<br>闪光灯的光会快速的衰减。闪光灯摄影快门不是控制因素。</li><li>闪光灯曝光控制<br>闪光灯曝光控制，可以减少或增加闪光补偿来控制。<br>暗光情况使用闪光灯应该适当增加ISO，慢速快门。</li><li>使用方法<br>弱光增强；强光补光；增加眼神光；创意闪光。</li></ul><h3 id="测光"><a href="#测光" class="headerlink" title="测光"></a>测光</h3><p>测光分为评价测光，中央重点平均测光和点测光。</p><ul><li>中央重点平均测光可以说是人像拍摄独享的测光模式，非常适合画面中央被摄主体亮度均匀而主体周围光线变化较大的场合。</li><li>点测光可以精准控制曝光，是针对画面中央极小范围进行测光的模式。</li></ul><h3 id="相机的设置"><a href="#相机的设置" class="headerlink" title="相机的设置"></a>相机的设置</h3><ol><li>拍摄模式的选择<br>一般情况下对于人像拍摄使用更多的是光圈优先曝光和手动曝光。白平衡放在自动档（配合jpg格式照片），对焦用的更多的是中心点对焦和单次对焦。</li><li>测光模式<br>测光方式用中央重点和点测光。因为作为人像拍摄，首先要保证所拍人物的正确曝光。特写的拍摄用局部测光，更精细的拍摄，逆光等使用点测光，光比比较大的场景中用中央重点平均测光。</li><li>ISO调整<br>光线允许的情况下设为100或200. ISO一般情况下越低越好。光线较暗，阴天的傍晚可以选择400，室内光线较暗可以选择800，偷拍可以选择1600。感光度越高，照片质量越粗糙。</li><li>自动化亮度<br>启动自动亮度优化虽然会拖慢机内处理速度但是拍人像无所谓。</li><li>光圈<br>一般镜头会用到的光圈号数为f/2.8~f/22.光圈优先AE是一种在人像和风光摄影中都最常用的自动曝光方式。</li><li>曝光<br>如何准确曝光，测光表标尺到零就可以准确曝光。标尺在负的一端时，可以先将光圈缩小，接下来再考虑转动快门。如果标尺在正的一端，光圈增大，接下来转动快门，增快快门速度。快门速度过快时，手很难端稳，可以选择三脚架或者开闪关灯。<br>手动模式M下可以拨动轮盘调节快门，Av+轮盘调节光圈。</li></ol><h3 id="拍摄人像时的两种常用镜头"><a href="#拍摄人像时的两种常用镜头" class="headerlink" title="拍摄人像时的两种常用镜头"></a>拍摄人像时的两种常用镜头</h3><ol><li>原厂镜头和副厂镜头<br>副厂镜头有些品质不输原厂，而且价格比原厂便宜。</li><li>变焦镜头和定焦镜头<br>24~70mm或24~120mm属于标准变焦镜，70~200mm或70~300mm属于望远变焦镜。50mm、85mm和135mm属于定焦镜头，这些镜头都可以用来拍摄人像。长焦端的镜头景深浅。初学者可以优先使用中望远镜头入手。</li></ol><h3 id="夜间拍摄"><a href="#夜间拍摄" class="headerlink" title="夜间拍摄"></a>夜间拍摄</h3><ul><li>夜景采用广角镜头摄影，风光摄影。拍摄地点多为俯拍，增加画面中的信息量。<br>夜景广角镜头是一个较好的镜头，感光度ISO应尽量低，快门速度慢（无法手端），产生了长时间曝光。利用三脚架取景，辅助使用快门线实现闭门。降噪功能设为自动时在镜头速度较慢的时候打开。白平衡设置5500以上色温，低色温显示冷调，也可以直接设置为钨丝灯模式。对焦选择单次对焦。面对白纸时会对焦失败，采用手动对焦，拨动对焦环即可。建议使用平均测光。建议使用小光圈，让光源表现出星芒。小光圈8 11 16等成像质量会更好。<br>如果拍摄的不是大场景可以使用大光圈。夜景摄影没有苛刻的曝光要求。<br>拍摄夜景避免大光源入镜。</li><li>拍摄夜景人像使用快门优先，慢速快门可以拍背景，前景由闪光灯照亮。焦距短一点，光圈收小一些。<br>ISO可以使用400~800， 稍大的F4、F2.8的光圈。找到合适的快门，在此快门基础上减少一道两级的曝光。白平衡模式使用闪光灯，设置后帘同步。<br>要搞清楚闪光灯的范围，不超过5m。快门最好用脚架。<br>拍摄人像可以采用中长焦。85mm以上。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人像摄影是摄影门类中难较高的。最近读了《品像–数码人像摄影与后期专业教程》这本书，作者徐阳。介绍了各种摄影技巧，本文就其中的几个点做一个笔记。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://tsuki419.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="摄影" scheme="https://tsuki419.github.io/categories/%E7%94%9F%E6%B4%BB/%E6%91%84%E5%BD%B1/"/>
    
      <category term="人像摄影" scheme="https://tsuki419.github.io/categories/%E7%94%9F%E6%B4%BB/%E6%91%84%E5%BD%B1/%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="读书笔记" scheme="https://tsuki419.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="人像摄影" scheme="https://tsuki419.github.io/tags/%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>风光摄影读书笔记</title>
    <link href="https://tsuki419.github.io/%E9%A3%8E%E5%85%89%E6%91%84%E5%BD%B1.html"/>
    <id>https://tsuki419.github.io/风光摄影.html</id>
    <published>2019-05-22T11:30:25.000Z</published>
    <updated>2019-05-28T09:16:47.893Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Everything you need to know about landscape photography techniques and subjects.<br>一直都很想学习摄影，虽然没有专业器材，但用手机镜头记录下生活的点点滴滴也是一件美好的事情。正值毕业季，为了在校园拍出美美的回忆，去图书馆补充了一下专业知识《风光摄影圣经》。本篇博客作为一个风光摄影的读书笔记。<br><a id="more"></a> </p><h2 id="风光摄影的前期准备"><a href="#风光摄影的前期准备" class="headerlink" title="风光摄影的前期准备"></a>风光摄影的前期准备</h2><p>在进行摄影之前需要先对摄影的器材和名词了解一下。</p><h3 id="相机相关概念"><a href="#相机相关概念" class="headerlink" title="相机相关概念"></a>相机相关概念</h3><p>风光摄影要求照片的暗部细节有很好的表现，意味着相机要有较高的色彩宽容度和分辨率。</p><ol><li>镜头的分类</li></ol><ul><li>广角镜头分两种，普通广角镜头焦距一般在24~38mm，超广角镜头的焦距为13~24mm。广角镜头景深比较大，可以有效的夸张前景和表现景物的远近层次。</li><li>标准镜头是与人眼的视角相近的镜头，国际标准为50mm。一般用于空中拍摄，或者近距离风光拍摄和中景特写。</li><li>长焦镜头通常焦距在70~400mm之间。长焦镜头可以将远处的景物拉近拍摄，产生空间压缩的效果，还可以作为特写镜头。</li><li>变焦镜头的画质要略逊色于定焦镜头。<div class="note info"><font color="darkslategrey"><p>镜头的分类在使用AE搭建场景的时候已经初步接触，在这里再次遇到做个整理。贴上AE中运用摄像机做的<a href="https://www.bilibili.com/video/av13904884" target="_blank" rel="noopener">镜头模仿练习</a>。</p></font></div></li></ul><ol start="2"><li>光圈和景深</li></ol><ul><li>光圈是相机上用来控制镜头孔径大小的部件。<br>光圈f值=镜头的焦距/镜头口径的直径。光圈f值越小，在同一单位时间内的进光量便越多，而且上一级的进光量刚好比下一级的多一倍。<br>利用小光圈可以获得大景深。在风光摄影中，中景，全景，远景等景别适合用小光圈拍摄增加纵深感。</li><li>景深是焦点前后的一段能清晰显示的景物的清晰度范围。拍摄花和昆虫的照片中将背景拍的很模糊为小景深，将背景与被摄主体拍的一样清晰为大景深。影响景深的因为有光圈，焦距和物距三大方面。<div class="note info"><font color="darkslategrey"><p>景深的使用，在3d建模的过程中接触过，保留模型的景深导入AE进行后期处理，可以营造很好的空间效果。</p></font></div></li></ul><ol start="3"><li>不同的快门<br>低速快门可以虚化动体，制造出虚实相衬的效果，将画面拍出动感，比如烟雾缭绕的感觉。而高速快门可以凝固动体，可以清晰的记录快速运动中的物体，高速快门的应用在于时机的捕捉。下图为低速快门图，图源网络。<br><img src="https://i.loli.net/2019/05/23/5ce61827b15a976558.jpg" alt><div class="note info"><font color="darkslategrey"><p>第一次见到低速快门拍照的照片，真实的仙境感。</p></font></div></li></ol><h3 id="取景"><a href="#取景" class="headerlink" title="取景"></a>取景</h3><p>拍摄可以根据景物的特点选择横画幅和竖画幅，拍照时将手机持平，使照片内的地平线水平，给人以平稳安定的感觉，一般忌讳将地平线居中。照片要吸引观众的视线，给人留下深刻印象，这就要画面的趣味点，我们可以用前景的物体使得普通的风光照片更有趣味性。<br>不同的景别：</p><ul><li>近景所展现的主体细节更丰富。中景经常记录我们眼前发生的事物，常常以动作或情节取胜。全景可以完整的表现主体的形体及周遭环境。远景画面开阔，景深悠远。</li></ul><h2 id="用光与构图"><a href="#用光与构图" class="headerlink" title="用光与构图"></a>用光与构图</h2><p>光影变换塑造了不同风格的画面，是拍照中不可忽略的因素，虽然影子影响画面的美观，但是用好影子也会有意想不到的效果。</p><h3 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h3><ul><li>顺光拍摄给人明亮晴朗的感觉。</li><li>侧光拍摄可以产生具有明显方向性的投影，具有非常好的造型效果。<br>前侧光使画面更加丰富；<br>正侧光是的画面有一个非常明显的过渡，除了拍摄要求显示凹凸明显的碑刻等物体外，很少使用；<br>后侧光多用于艺术创作，纵深感强。</li><li>逆光塑造独特的效果。拍摄透明，半透明的物体逆光为最佳光线。</li><li>眩光在光线和拍摄主题合适时，只要曝光合适，再结合良好的构图和被摄主体，往往会得到神奇的戏剧化效果。</li></ul><h3 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h3><p>巧妙的构图是一种艺术，是一种美学概念。</p><p><div class="note info"><font color="darkslategrey"><p>总感觉自己拍出来的照片很难看，原来是从来没有注意过构图，一直都是凭感觉瞎拍，学了构图以后也可以实践一番了。构图不仅在拍照中会用到，画画和搭建场景中都会用到。</p></font></div></p><ol><li>经典的三分法即黄金分割法。</li><li>S形构图动感效果强，既动又稳。远景俯拍效果最佳，适合山川河流的自然起伏和人体动物物体的曲线排列变化。</li><li>A形构图具有向上的冲击力和强劲的视觉引导力。适合拍摄眼神的长路，长桥和高耸的建筑物。</li><li>O形构图稳定感强。</li><li>斜线构图能形成深度空间，使画面具有活力，还能形成指向性，同时给人以三位空间感。溪流、铁轨、小路、围栏、墙壁、篱笆、电线以及远景中的道路桥梁都可以做斜线。</li><li>对角线构图，具有方向感，动感和活泼。线条汇聚，吸引人们的视线。</li><li>曲线构图。</li><li>稳定的三角形构图。</li><li>漂亮的放射形构图，常用于要突出主体，而场面又复杂的场合。</li><li>突出主体的框架式构图，一般用于有前景的拍摄， 比如利用门窗，山洞口，其他框架作为前景。<br>本文没能加入很多的图片说明，这里有前人的<a href="https://blog.csdn.net/qq_34129814/article/details/80271516" target="_blank" rel="noopener">构图总结</a>。希望在今后的拍照运用中逐渐实践学到的方法，创建属于自己的作品图库。</li></ol><h2 id="色彩探索"><a href="#色彩探索" class="headerlink" title="色彩探索"></a>色彩探索</h2><p><blockquote class="question">不同的色彩能使人产生不同的官能感觉。暖色调使人感到热烈兴奋，冷色调使人感到优雅，宁静。在摄影中如何搭配色彩构成画面，什么样的色彩搭配在一起更加漂亮，这是每个摄影人必须学会的理论知识。<br>色彩之间的搭配主要有富有烘托效果的同类色(45deg)，具有表现效果的互补色(150~180deg)，效果和谐的相邻色(90deg以内)，突出主体的对比色(对比形式多样，有冷暖，补色，明暗的对比。红与绿，蓝与黄石互补色。)等几个分类。</blockquote></p><p><div style="width:200px;margin:0 auto;"><img src="https://i.loli.net/2019/05/23/5ce631ff6466814579.jpg" alt></div></p><p><div class="note primary"><font color="darkslategrey"><p>有时会觉得拍照就是一个高级的绘画过程，逼真的展现事物的原貌，同样考虑到了构图，光影，色彩，可以说艺术是相通的吧。读书笔记中有很多没有记录到的内容，比如测光与曝光，焦点的选择，滤镜的选择。这本书后几章的拍摄实践包括山水美景，冰雪云雾和日月星辰，提供了很多实用的拍摄tips，但是技巧都是在实践中磨练的，就不在这里记录了。等上手实践之后再来更新。</p></font></div><br>    参考书籍：风光摄影圣经 –创造影像</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Everything you need to know about landscape photography techniques and subjects.&lt;br&gt;一直都很想学习摄影，虽然没有专业器材，但用手机镜头记录下生活的点点滴滴也是一件美好的事情。正值毕业季，为了在校园拍出美美的回忆，去图书馆补充了一下专业知识《风光摄影圣经》。本篇博客作为一个风光摄影的读书笔记。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://tsuki419.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="摄影" scheme="https://tsuki419.github.io/categories/%E7%94%9F%E6%B4%BB/%E6%91%84%E5%BD%B1/"/>
    
      <category term="风光摄影" scheme="https://tsuki419.github.io/categories/%E7%94%9F%E6%B4%BB/%E6%91%84%E5%BD%B1/%E9%A3%8E%E5%85%89%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="风光摄影" scheme="https://tsuki419.github.io/tags/%E9%A3%8E%E5%85%89%E6%91%84%E5%BD%B1/"/>
    
      <category term="镜头" scheme="https://tsuki419.github.io/tags/%E9%95%9C%E5%A4%B4/"/>
    
      <category term="构图" scheme="https://tsuki419.github.io/tags/%E6%9E%84%E5%9B%BE/"/>
    
      <category term="读书笔记" scheme="https://tsuki419.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>搭建博客初体验</title>
    <link href="https://tsuki419.github.io/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%88%9D%E4%BD%93%E9%AA%8C.html"/>
    <id>https://tsuki419.github.io/搭建博客初体验.html</id>
    <published>2019-05-07T02:42:25.758Z</published>
    <updated>2019-05-23T04:30:25.791Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to my blog.This is my very first post.<br>折腾了好几天hexo配合github搭建博客成功，需要优化的还有很多，需要学习的技能也好多。建博客的过程中，遇到了好多问题，看教程的时候仿佛大家都水到渠成，只有我和成功之间隔着千山万水。ORZ记录一下遇到的问题和解决方法。<br><a id="more"></a> </p><h2 id="hexo-github搭建博客雏形"><a href="#hexo-github搭建博客雏形" class="headerlink" title="hexo+github搭建博客雏形"></a>hexo+github搭建博客雏形</h2><p>首先感谢<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a>手把手教程。</p><h3 id="题外话之修改hosts访问google"><a href="#题外话之修改hosts访问google" class="headerlink" title="题外话之修改hosts访问google"></a>题外话之修改hosts访问google</h3><p>首先翻墙是一项必备技能，根据<a href="https://laod.cn/hosts/2019-hosts.html" target="_blank" rel="noopener">老D博客</a>里的步骤替换hosts，出现了一些问题，目前仍然没能找到翻墙的正确姿势。</p><ol><li>hostipconfig/flushdns 无法使用：查找后可以通过<a href="https://blog.csdn.net/hi_boy_/article/details/78059189" target="_blank" rel="noopener">设置path</a>解决。</li><li>出现了谷歌学术搜索页面，但是搜索会显示“请进行人机身份验证”。</li></ol><h3 id="前奏之安装node-js和git"><a href="#前奏之安装node-js和git" class="headerlink" title="前奏之安装node.js和git"></a>前奏之安装node.js和git</h3><p><div class="note default"><p>教程里很清楚了，不再赘述。</p></div><br>安装之后用下述代码查看是否安装成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">$ node -v</span><br></pre></td></tr></table></figure></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>做好前期准备开始安装hexo，血泪史，因为版本问题导致的惨剧，是谁说的warn信息都不用管的。</p><ol><li>报错：local hexo not found in xxx:<br>在网上各种搜索，删除项目中的package.json,执行npm init生成新的package.json替换，虽然不再报错，但是出现了新问题。</li><li>返回usage信息，hexo命令干脆不能用了，倒腾一晚上，git和nodejs确实装好了，也不是运行命令的目录不正确，最后考虑是环境变量问题。直到第二天重装node.js，确认问题是node.js版本过低所致。</li></ol><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>报错：could not read from remote repository<br>经过检查发现是github项目名称写错。真是时常被自己蠢哭。</p><h2 id="发文"><a href="#发文" class="headerlink" title="发文"></a>发文</h2><p>至此，终于在建好了博客雏形，看到网页的时候感动哭。先发文看看。</p><h3 id="编辑博文并发表"><a href="#编辑博文并发表" class="headerlink" title="编辑博文并发表"></a>编辑博文并发表</h3><p>markdown是一种标记性语言，第一次接触也可以上手很快。<a href="https://www.jianshu.com/p/a5387c159bd9" target="_blank" rel="noopener">新手速成看这里</a></p><ol><li>中文乱码：<br>多半是编码问题，换个编码方式编辑。使用UTF-8编码方式，成功解决。 </li><li><p>如何更新博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"Hello world"</span></span><br><span class="line"></span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li><li><p>网易云音乐产生外部链接<br><a href="http://link.hhtjim.com/163/xxx.mp3" target="_blank" rel="noopener">http://link.hhtjim.com/163/xxx.mp3</a> 将歌曲链接的对应id替换xxx位置即可<br>安装插件aplayer之后插入博客中见下图：</p>        <div id="aplayer-cfbmfjOF" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-cfbmfjOF"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "Hit and Run",              author: "Lolo",              url: "https://link.hhtjim.com/163/28987151.mp3",              pic: "https://i.loli.net/2019/05/09/5cd41d6fa31f5.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script></li><li>插入图片<br>七牛云倒腾半天，发现提供的免费域名只能用30天， 为了图片不失效，只能买自己的域名。目前由于懒就用了在线图床<a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a>。这里有关于<a href="https://blog.csdn.net/u012195214/article/details/79204607" target="_blank" rel="noopener">图床</a>的一些介绍。<br><img src="https://i.loli.net/2019/05/11/5cd6b1d16a2f0.jpg" alt></li></ol><h2 id="副本之博客优化"><a href="#副本之博客优化" class="headerlink" title="副本之博客优化"></a>副本之博客优化</h2><p>光秃秃的博客是没有灵魂的，<font color="pink"><del>接下来可以开始装装点点，开始幸福生活啦。</del> </font> 一个好的博客既要有好的内容，也要有漂亮的外在，门面嘛，既然要经营就要从内到外到经营好，于是开启了副本之漫长的优化之路。<br>先写到这里，优化虽然跟着教程做了一些有了一些理解，等补一些之后再来更新。</p><font color="red">未完。。。待续。。</font><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog.This is my very first post.&lt;br&gt;折腾了好几天hexo配合github搭建博客成功，需要优化的还有很多，需要学习的技能也好多。建博客的过程中，遇到了好多问题，看教程的时候仿佛大家都水到渠成，只有我和成功之间隔着千山万水。ORZ记录一下遇到的问题和解决方法。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="hexo" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/hexo/"/>
    
    
      <category term="hosts" scheme="https://tsuki419.github.io/tags/hosts/"/>
    
      <category term="blog" scheme="https://tsuki419.github.io/tags/blog/"/>
    
      <category term="hexo" scheme="https://tsuki419.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
