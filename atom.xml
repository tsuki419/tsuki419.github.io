<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tsuki&#39;s CodeLife</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://tsuki419.github.io/"/>
  <updated>2021-07-28T02:58:21.651Z</updated>
  <id>https://tsuki419.github.io/</id>
  
  <author>
    <name>tsuki</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vegas 导入 AE</title>
    <link href="https://tsuki419.github.io/Vegas%E8%BD%ACAE.html"/>
    <id>https://tsuki419.github.io/Vegas转AE.html</id>
    <published>2021-07-28T02:48:27.120Z</published>
    <updated>2021-07-28T02:58:21.651Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>电脑带不动Pr，所以一开始就用的vegas，虽然vegas有很多插件</p><a id="more"></a> <p>例如newBlue都很好用，但是做特效和拉曲线当然还是AE方便，于是就想着有没有什么方法能在vegas粗剪的视频导入ae。以前就找过相关的教程，但是时隔太久不用，我存在哪里已经忘了，又折腾半天，这回一定要存好。于是有了这篇博客。</p><p><strong>操作步骤：</strong></p><ol><li>在vegas中粗剪完成放在一个视频轨道上，删掉音频</li><li>文件==&gt;导出 ==&gt; Media Composer AAF File</li><li>打开AE， 文件==&gt;导入==&gt;Pro Import After Effects…</li><li>修改合成大小</li></ol><p>附：使用的软件版本是AE CC 2015和Vegas13</p><p><em>参考<a href="https://www.bilibili.com/video/BV1rb411T7gJ" target="_blank" rel="noopener">视频</a></em>，感谢up主，视频还提供了AE转Vegas的操作，暂时没有用到就先m一下，不展开记录了</p><p><strong>完</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电脑带不动Pr，所以一开始就用的vegas，虽然vegas有很多插件&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="剪辑" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%AA%E8%BE%91/"/>
    
      <category term="vegas" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%89%AA%E8%BE%91/vegas/"/>
    
    
      <category term="vegas" scheme="https://tsuki419.github.io/tags/vegas/"/>
    
  </entry>
  
  <entry>
    <title>Latex</title>
    <link href="https://tsuki419.github.io/latex.html"/>
    <id>https://tsuki419.github.io/latex.html</id>
    <published>2021-06-29T08:45:38.400Z</published>
    <updated>2021-07-15T08:42:31.950Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次用latex排版，记录一下使用过程中遇到的问题。</p><a id="more"></a> <p>哈哈哈论文能不能投不知道，调格式倒是挺折腾。记录下来以后说不定会用到，省得再折腾一次。总的来说上手还是挺快的，博主的<a href="https://blog.csdn.net/LXX516/article/details/90288544" target="_blank" rel="noopener">经历</a>和<a href="https://blog.csdn.net/u011436427/article/details/82934856" target="_blank" rel="noopener">latex编辑注意事项</a>也给小白的我很多的帮助。</p><p>texlive的编辑器显示效果不是很好看，但是图个省事就没有安装vscode。</p><h2 id="下载模板"><a href="#下载模板" class="headerlink" title="下载模板"></a>下载模板</h2><p>首先下载完成IEEEtrans模板之后的使用。</p><ul><li><p>IEEEtran.cls文件复制到texlive\2021\texmf-local\tex\latex </p></li><li><p>以管理员方式运行cmd，<code>&gt;texhash</code></p></li><li>将.tex文件复制到texlive文件夹里面即可</li></ul><p><em>参见<a href="https://blog.csdn.net/weixin_42634342/article/details/100107667" target="_blank" rel="noopener">博客</a>。</em></p><p>然后就可以开始快乐编辑内容。</p><h2 id="公式篇"><a href="#公式篇" class="headerlink" title="公式篇"></a>公式篇</h2><p>关于插入公式真的是很方便，只要多用几次就能掌握常用的命令，希腊字母根据发音的写法也很好记，打开了新世界大门。</p><p>如何插入公式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;split&#125;</span><br><span class="line"> P(t)=P(t-t_0)+D(t),</span><br><span class="line"> x = a + b.</span><br><span class="line">\end&#123;split&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure><p>要记得加入宏包 <code>\usepackage{amsmath}</code></p><p>公式的常用符号的写法<a href="https://zhuanlan.zhihu.com/p/110756681" target="_blank" rel="noopener">看这里</a>。符号大全补充<a href="https://blog.csdn.net/yen_csdn/article/details/79966985" target="_blank" rel="noopener">看这里</a>。</p><p>导数相关的符号<a href="https://www.jianshu.com/p/8aa646fad1c5" target="_blank" rel="noopener">看这里</a>。都是基础问题就不赘述。</p><p>如何<a href="https://blog.csdn.net/sinat_38816924/article/details/84347665" target="_blank" rel="noopener">排版公式</a>，善用&amp;符号。</p><h2 id="图片篇"><a href="#图片篇" class="headerlink" title="图片篇"></a>图片篇</h2><p>加入宏包 <code>\usepackage{graphicx}</code></p><p>如何插入图片，<a href="https://blog.csdn.net/qq_38526623/article/details/103737589" target="_blank" rel="noopener">看这里</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;figure&#125;[htbp]</span><br><span class="line">    \centering</span><br><span class="line">    \includegraphics[width=2.5in]&#123;fig1.eps&#125;</span><br><span class="line">    \caption&#123;name&#125;</span><br><span class="line">    \label&#123;fig1&#125;</span><br><span class="line">\end&#123;figure&#125; </span><br><span class="line">%如何解决路径问题</span><br><span class="line">graphicspath&#123;&#123;img/&#125;&#125;%当前路径下存放图片的文件夹</span><br></pre></td></tr></table></figure><p>如何插入eps图片，简单粗暴，我是直接PS另存为解决了。其他解决方法<a href="https://blog.csdn.net/lqhbupt/article/details/20545297" target="_blank" rel="noopener">看这里</a>。</p><h2 id="文献篇"><a href="#文献篇" class="headerlink" title="文献篇"></a>文献篇</h2><p>如何插入文献？</p><ol><li><p>创建bibtex文件，建立参考文件库。</p><p>便捷使用google的引用功能，轻松搞定！</p></li><li><p>文章主体添加引用 <code>\cite{ref}</code></p></li><li><p>四次编译，就可以引用位置和参考文献位置链接互通啦！这里被卡了一会，参考<a href="https://www.cnblogs.com/parrynee/archive/2010/03/02/1676369.html" target="_blank" rel="noopener">文章</a>总算解决掉了。</p></li><li><p>高亮内容的制作，<a href="https://zhuanlan.zhihu.com/p/114733612" target="_blank" rel="noopener">参考文章</a></p></li></ol><p>如何插入链接型的文献呢？<a href="https://blog.csdn.net/techfield/article/details/19933589" target="_blank" rel="noopener">看这里</a></p><p>我是手动修改的.bib文件，不知道有没有更便捷准确的方法，如果有人看的话，欢迎邮件交流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Misc&#123;timmurphy.org,</span><br><span class="line">howpublished = &#123;[EB/OL]&#125;,</span><br><span class="line">note = &#123;\url&#123;http://timmurphy.org/2009/07/22/line-spacing-in-latex-documents/&#125; Accessed April 4, 2010&#125;,</span><br><span class="line">title = &#123;Line Spacing in LaTeX documents&#125;,</span><br><span class="line">author = &#123;Murphy, Timothy I&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在插入链接型参考文献的时候，引申一下<a href="https://blog.csdn.net/shanshu12/article/details/7561274" target="_blank" rel="noopener">EB/OL</a>的含义。</p><h2 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h2><p>通过图片和公式的交叉引用，无论公式挪动到哪里都能正确的编号，省了自己费劲数的功夫，还不会产生失误。</p><p><code>\ref</code>命令配合<code>\label</code>的使用基本就解决了图片公式以及文献的引用，一个ref走天下。</p><ul><li><p>引用图片 <code>\ref{fig1}</code></p></li><li><p>引用文献 <code>\ref{ref1}</code></p></li><li><p>引用方程 <code>\ref{equation1}</code> 此外还可以导入amsmath包用 <code>\eqref{equation1}</code></p></li></ul><p><em>参考文章： <a href="https://blog.csdn.net/robert_chen1988/article/details/53315012" target="_blank" rel="noopener">文章1</a> <a href="https://blog.csdn.net/sinat_36301420/article/details/79334728" target="_blank" rel="noopener">文章2</a></em></p><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>在学习latex的过程中，刷到了一篇关于如何写好论文的<a href="http://panpei.site/2014/02/02/how-to-write-a-paper/" target="_blank" rel="noopener">博客</a>，给迷茫的我上了一课。</p><blockquote><p>写paper的两种方式:</p><ol><li>Idea-&gt;Do Research-&gt;Write Paper</li><li>Idea-&gt;Write Paper-&gt;Do Research</li></ol></blockquote><p>以前一直认为论文是以结果为导向的，这可能与我过往做物理实验的经历有关。还是道行尚浅啊。每次在组会上说到论文没有成果展示的时候，老师都会反问一句一定要有成果吗？当时不理解，现在读到这篇文章，哦原来，paper真正的目的是交流思想的。其实写文章的过程中也查阅了很多的文献，仔细回想一下这些优秀的文献也确实如此。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次用latex排版，记录一下使用过程中遇到的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="论文" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BA%E6%96%87/"/>
    
      <category term="latex" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BA%E6%96%87/latex/"/>
    
    
      <category term="Latex" scheme="https://tsuki419.github.io/tags/Latex/"/>
    
      <category term="IEEEtrans" scheme="https://tsuki419.github.io/tags/IEEEtrans/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="https://tsuki419.github.io/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.html"/>
    <id>https://tsuki419.github.io/JAVA反射机制.html</id>
    <published>2021-06-01T13:35:55.190Z</published>
    <updated>2021-06-01T13:35:00.195Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>c#, Python都是动态语言，可以在运行时改变自身结构。而<strong>反射是Java非常重要的动态特性</strong></p><a id="more"></a> <blockquote><p><strong>思考：方法变量化是不是也是一种动态性的体现？</strong></p></blockquote><h3 id="理解Class类并获取Class类的实例"><a href="#理解Class类并获取Class类的实例" class="headerlink" title="理解Class类并获取Class类的实例"></a>理解Class类并获取Class类的实例</h3><p>Class的实例就对应一个运行时类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：调用运行时类的属性：.classs</span></span><br><span class="line">Class clazz1 = Person.class;</span><br><span class="line"><span class="comment">//方式二：通过运行时类的对象调用getClass()</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Class clazz2 = p1.getClass();</span><br><span class="line"><span class="comment">//方式三：调用Class的静态方法：forName(String classPath)，实际中应用多，体现了反射的动态性</span></span><br><span class="line">Class clazz3 = Class.forname(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure><p>补充一点，后续学到编译内容是再更新。</p><p><strong>类的加载过程</strong></p><p>Load=&gt;Link=&gt;Initialize</p><p>Load:将class文件读入内存，并在堆里为之创建<strong>一个</strong>java.lang.Class对象。此过程由类加载器完成。</p><p>Link:将类的二进制数据合并到JRE中</p><p>Initialize: JVM负责对类进行初始化</p><h3 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h3><p>反射机制应用最多的地方来了！</p><p>创建类的对象：调用Class对象的newInstance()方法</p><p>要求类必须有一个无参构造器，类的构造器访问权限要足够。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br><span class="line">Person obj = clazz.newInstance();</span><br></pre></td></tr></table></figure><p>没有无参的构造器也可以创建对象，调用类中的指定构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"aa.Java.Person"</span>);</span><br><span class="line"><span class="comment">//获取指定构造器</span></span><br><span class="line">Constructor con = clazz.getDeclaredConstructor(String.class,Integer.class);</span><br><span class="line">con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//调用此构造器创建运行时类的对象</span></span><br><span class="line">Person p2 = (Person)con.newInstance(<span class="string">"Peter"</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h3 id="调用运行时类的指定结构"><a href="#调用运行时类的指定结构" class="headerlink" title="调用运行时类的指定结构"></a>调用运行时类的指定结构</h3><h4 id="调用指定属性"><a href="#调用指定属性" class="headerlink" title="调用指定属性"></a>调用指定属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br><span class="line"><span class="comment">//创建运行时类的对象</span></span><br><span class="line">Person p = (Person)clazz.newInstance();</span><br><span class="line"><span class="comment">//获取运行时类中指定变量名的属性</span></span><br><span class="line">Field name = clazz.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//保证当前属性是可访问的</span></span><br><span class="line">name.setAccessible(ture);</span><br><span class="line"><span class="comment">//设置指定对象的此属性值</span></span><br><span class="line">name.set(p,<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure><h4 id="调用指定方法同理"><a href="#调用指定方法同理" class="headerlink" title="调用指定方法同理"></a>调用指定方法同理</h4><p>实例化class==&gt;找到方法==&gt;调用方法invoke()</p><p>使用频率更高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Person.class;</span><br><span class="line">Method show = clazz.getDeclaredMethod(<span class="string">"show"</span>, String.class);</span><br><span class="line">show.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object returnValue = show.invoke(p, <span class="string">"CHN"</span>);</span><br></pre></td></tr></table></figure><h4 id="调用指定构造器"><a href="#调用指定构造器" class="headerlink" title="调用指定构造器"></a>调用指定构造器</h4><p>已经在创建运行时类的对象部分介绍过。</p><h3 id="反射的应用–动态代理"><a href="#反射的应用–动态代理" class="headerlink" title="反射的应用–动态代理"></a>反射的应用–动态代理</h3><p>补充：静态代理，以设计模式中的工厂模式做例，实际上是多态性的体现。</p><blockquote><p>碎碎念，到处都存在的多态性和解耦合操作。</p></blockquote><p>分别有三个对象，提供一个接口，代理类和被代理类。代理类通过聚合的方式调用接口，被代理类实现接口中的目标方法。从而利用多态特点，代理类调用被代理类实现的目标方法。听起来比较绕口，就举个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title">ClothFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClothFactory factory;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyClothFactory</span><span class="params">(ClothFactory factory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceCloth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        factory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理内容有待补充。后续更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c#, Python都是动态语言，可以在运行时改变自身结构。而&lt;strong&gt;反射是Java非常重要的动态特性&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Java" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/Java/"/>
    
      <category term="反射" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/Java/%E5%8F%8D%E5%B0%84/"/>
    
    
      <category term="Java" scheme="https://tsuki419.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Endnotes</title>
    <link href="https://tsuki419.github.io/Endnotes.html"/>
    <id>https://tsuki419.github.io/Endnotes.html</id>
    <published>2021-05-22T12:45:49.928Z</published>
    <updated>2021-06-29T09:01:21.592Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在整理文献，写一个查找和下载文献的小心得。</p><a id="more"></a> <h2 id="ref-download"><a href="#ref-download" class="headerlink" title="ref download"></a>ref download</h2><p>首先是下载文献，作为一个科研人，都逃不过读英文文献，除了学校图书馆的资源怎么下载其他文献呢？</p><p>参考<a href="https://zhuanlan.zhihu.com/p/344239869" target="_blank" rel="noopener">知乎回答</a>，感谢答主！</p><p>首先查找文献，翻墙和<a href="https://ac.scmor.com/" target="_blank" rel="noopener">谷歌学术镜像网站</a>。免费的外皮恩真的香，但是秉持好学的态度改天研究一下自己搭梯子哈哈。</p><p>然后是最近发现的宝藏网站，下载神器，<a href="http://www.sci-hub.ac.cn/" target="_blank" rel="noopener">文献小镇</a>！强推！</p><h2 id="Endnotes"><a href="#Endnotes" class="headerlink" title="Endnotes"></a>Endnotes</h2><p>接下来下载一时爽，阅读火葬场。面对下载的几十文献真是抓狂，一边是看完就忘，一边是难以分类标记，上学这么多年到现在才学会如何整理文献真是惭愧。</p><p>用了Endnotes真是相见恨晚。下载安装和导入文献基本教程都可以参考<a href="https://blog.manyacan.com/archives/1794/" target="_blank" rel="noopener">博客</a>，博主写的很详细。使用了文献管理软件的感觉就是获得了解放，再也不用为文献格式发愁，可以尽情的快乐插入文献了。</p><p>我不生产教程，我只是教程的拼接工。</p><p>但是目前使用了Endnotes，也有一些问题，中文文献难以识别，没有标签功能。</p><p>在整理插入文献的过程中可以一边查看文献一边完善论文内容，提高工作效率。</p><p>后续使用其他文献管理软件体验不定期更新。</p><p>完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在整理文献，写一个查找和下载文献的小心得。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="论文" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BA%E6%96%87/"/>
    
      <category term="Endnotes" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BA%E6%96%87/Endnotes/"/>
    
    
      <category term="endnotes" scheme="https://tsuki419.github.io/tags/endnotes/"/>
    
  </entry>
  
  <entry>
    <title>VISA</title>
    <link href="https://tsuki419.github.io/visa.html"/>
    <id>https://tsuki419.github.io/visa.html</id>
    <published>2021-03-26T13:07:08.240Z</published>
    <updated>2021-03-29T04:57:10.687Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近开始跑老师给的现成软件，记录一下遇到的问题。</p><a id="more"></a> <p>首先如何把一个项目跑起来？小白的我快要吐血了。计划之后试试开源项目。</p><p>先叨叨两句题外话，太久不用git，上传好像出了点问题。远程仓库和本地仓库地址不一致，上次搞了半天也没弄好，倒是能上传文章了，但还是会报错。过几天有空再搞一下。</p><blockquote><p>倒腾好了，出错提示：</p><p><code>fatal:Could not read from remote repository</code></p><p>原因是站点配置文件的网站写错了，参考<a href="https://blog.csdn.net/meng_lemon/article/details/88963157" target="_blank" rel="noopener">文章</a>。大费周章困扰好久。</p><p>错误二：</p><p><code>fatal: unable to access &#39;https://github.com…\&#39;: Empty reply from server</code></p><p>解决方法：</p><p><code>git config --global --unset http.proxy</code></p><p>参考<a href="https://stackoverflow.com/questions/27087483/how-to-resolve-git-pull-fatal-unable-to-access-https-github-com-empty" target="_blank" rel="noopener">文章</a></p></blockquote><h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a><strong>技术点</strong></h2><p>本项目主要用了对设备的程控。NI-VISA是美国国家仪器NI公司开发的一种用来与各种仪器总线进行通信的高级应用编程接口。参考博客<a href="https://blog.csdn.net/u014124220/article/details/46986825" target="_blank" rel="noopener">如何使用VS2010调用visa进行程控</a>，开始！</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a><strong>下载</strong></h3><p>所以开始在电脑上安装NI提供的库，如果安装失败的话，重新下载安装包下载。安装失败的原因现在也没搞清楚，难道是以前安装labview的注册表没清干净？其中曲折把系统盘误删文件搞坏还修了好久，泪目。可以写个合集了”这些年我遇到过的麻烦“。</p><p>回到正题，</p><blockquote><p>文件安装目录：C:\Program Files (x86)\IVI Foundation\VISA\WinNT</p><p>lib文件位置：C:\Program Files (x86)\IVI Foundation\VISA\WinNT\lib\msc</p><p>.h文件位置：C:\Program Files (x86)\IVI Foundation\VISA\WinNT\Include</p></blockquote><h3 id="如何添加库到工程中？"><a href="#如何添加库到工程中？" class="headerlink" title="如何添加库到工程中？"></a><strong>如何添加库到工程中？</strong></h3><p>这里涉及到静态库的使用。之前在课上一知半解，现在终于用到了。参考文章<a href="https://www.cnblogs.com/skynet/p/3372855.html" target="_blank" rel="noopener">c++静态库与动态库</a></p><p>这里卡了好久，最后采取了文章中提到的方法二：</p><blockquote><p>属性==&gt;配置属性==&gt;链接器==&gt;命令行</p><p>输入静态库的完整路径。</p></blockquote><p>之前采用方法三，一直没能导入成功，不知道哪里出了问题，摊手。</p><blockquote><ol><li><p>属性==&gt;配置属性==&gt;链接器==&gt;常规，附加依赖库目录输入静态库所在的目录</p></li><li><p>属性==&gt;配置属性==&gt;链接器==&gt;输入，附加依赖库中输入静态库名visa32.lib</p></li></ol></blockquote><p>此时生成解决方案出现了报错 “LINK:fatal error LNK1104: 无法打开文件‘C：/Program.obj”</p><p>解决方案是静态库路径加引号。参见<a href="https://blog.csdn.net/wsh6759/article/details/7537069" target="_blank" rel="noopener">博客</a></p><p>继续报错，无法解析外部符号</p><p>参考<a href="https://blog.csdn.net/enotswn/article/details/5934938" target="_blank" rel="noopener">博客</a></p><hr><p>继续上回分解，发现我整个搞错了。</p><p>首先分清楚这几个<a href="https://blog.csdn.net/u012043391/article/details/54972127" target="_blank" rel="noopener">附加目录</a>分别表示什么。检查发现是添加在C\C++ ==&gt;附加库目录起作用了。</p><p>然后解决无法解析外部符号，引用另一个库项目中的实现。完美解决。</p><p>完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始跑老师给的现成软件，记录一下遇到的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="VISA" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/VISA/"/>
    
    
      <category term="VISA" scheme="https://tsuki419.github.io/tags/VISA/"/>
    
      <category term="静态库" scheme="https://tsuki419.github.io/tags/%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>9月leetcode刷题总结</title>
    <link href="https://tsuki419.github.io/9%E6%9C%88leetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>https://tsuki419.github.io/9月leetcode刷题总结.html</id>
    <published>2020-11-08T03:42:31.030Z</published>
    <updated>2020-11-08T05:50:59.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>刚开始刷题大部分都不会，有的题有思路但是代码写不明白，参考了很多官方和评论区大佬的答案，学到了很多。解答用的语言是c++，在边学边用，官方的STL库还不熟悉，菜鸟如我经常搞错vector的用法。</p><a id="more"></a> <p>本来打算九月底发的博客拖到了现在(十一月初），十月也没有继续刷题。开始准备做项目不由感叹门外汉入门真是不容易，什么都不会，扶额。</p><p>这一个月做过的题类型有，回溯算法加剪枝， 二叉树的遍历和递归， 并查集等等。</p><h2 id="回溯算法加剪枝"><a href="#回溯算法加剪枝" class="headerlink" title="回溯算法加剪枝"></a>回溯算法加剪枝</h2><p>一直碰到用回溯算法就歇菜。现在还没有完全掌握。</p><p>回溯算符与递归的区别在于，回溯过程中达到结束条件要恢复状态回溯到上一层，再次搜索，而递归是一个劲往某个方向。回溯与DFS的区别就是有无状态的重置。在题解区看到<a href="https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/" target="_blank" rel="noopener">答主</a>的回答颇有所获，非常感谢。但是实际应用中画出递归树不好理解。</p><h3 id="子集和组合"><a href="#子集和组合" class="headerlink" title="子集和组合"></a><strong>子集和组合</strong></h3><p><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">leetcode78 子集，</a><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">leetcode 90子集2</a>使用了剪枝。使用了start变量。</p><p>参考了官方的答案，递归枚举类题的包括以下几个步骤：</p><ol><li><p>画出递归树（关键</p></li><li><p>递归边界，记录的条件</p></li><li><p>设置了vector: temp当前的记录，vector&lt;vector&lt;&gt;&gt;: ret返回所有的记录</p></li><li><p>判断是否需要剪枝处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(nums.begin(), nums.end());</span><br><span class="line"><span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组合中可以选择或者不选择当前位置，之后递归考虑下一个位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temp.push_back(cur);</span><br><span class="line">dfs(cur + <span class="number">1</span>);</span><br><span class="line">temp.pop();</span><br><span class="line">dfs(cur + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><p>（事实告诉我们不要写一半跑路，时隔一个月我已经看不懂之前写的了，趁着快要考试继续做算法总结</p><p><a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">组合</a>中配合使用了剪枝来减少时间。</p><p><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a>中传入了target变量。</p><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/" target="_blank" rel="noopener">组合总和2</a>使用了剪枝。</p><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" target="_blank" rel="noopener">全排列</a>，<a href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/" target="_blank" rel="noopener">全排列2</a>设置了visited数组。</p><p>核心代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(visited[i] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">    visited[i] = <span class="literal">true</span>;</span><br><span class="line">    temp.push_back();</span><br><span class="line">    dfs();</span><br><span class="line">    visited[i] = <span class="literal">false</span>;<span class="comment">//回退</span></span><br><span class="line">    temp.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑剪枝处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sort(nums.begin(), nums.end());</span><br><span class="line"><span class="comment">// i &gt; 0 是为了i - 1 有效</span></span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>])&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h2 id="二叉树遍历递归"><a href="#二叉树遍历递归" class="headerlink" title="二叉树遍历递归"></a>二叉树遍历递归</h2><p><strong>层次遍历</strong></p><p>二叉树层次遍历和层次相关时，可以用queue.size()获取一层的个数，一层一层的处理。如<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">leetcode 637，二叉树层平均值</a>，<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">leetcode 117，层链接</a></p><p><strong>深度优先遍历</strong></p><p><strong>先序中序和后序遍历</strong></p><p>相关于二叉树的题十有八九是递归算法，属于有思路但是写出来的代码总有逻辑错误的题，栈溢出，多半是递归边界问题，还有递归的参数没弄对。</p><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚开始刷题大部分都不会，有的题有思路但是代码写不明白，参考了很多官方和评论区大佬的答案，学到了很多。解答用的语言是c++，在边学边用，官方的STL库还不熟悉，菜鸟如我经常搞错vector的用法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="算法" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E7%AE%97%E6%B3%95/leetcode/"/>
    
    
      <category term="回溯算法" scheme="https://tsuki419.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="https://tsuki419.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="并查集" scheme="https://tsuki419.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="https://tsuki419.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://tsuki419.github.io/设计模式.html</id>
    <published>2020-11-08T03:42:31.020Z</published>
    <updated>2020-11-08T04:07:56.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>十月间断的学了一些设计模式。这是个长久的课程，还没有学会怎么实际运用到项目中。</p><p>跟随着视频<a href="https://www.bilibili.com/video/BV1G4411c7N4?p=4" target="_blank" rel="noopener">来学</a>。</p><a id="more"></a> <p><strong>为什么</strong>学习设计模式？</p><p>为了让程序具有更好的代码重用性，可读性，可扩展性，可靠性，使程序呈现<strong>高内聚，低耦合</strong>的特性。</p><p><strong>什么时候用到</strong>设计模式？</p><p>面向对象（oo）=&gt; 功能模块[设计模式 + 算法（数据结构）] =&gt; 框架[ 多种设计模式 ] =&gt; 架构[ 服务器集群 ]</p><p><strong>学习步骤</strong></p><p>应用场景 –&gt; 设计模式 –&gt; 剖析原理 –&gt; 分析实现步骤（图解，类图） –&gt; 代码实现 –&gt; 框架或项目源码分析的步骤讲解</p><h2 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h2><p>设计模式为什么这样设计的原则。    </p><blockquote><p>字符流会查码表，字节流不查码表</p><p>编码：字符—&gt;码表—&gt;数字</p><p>解码：数字—&gt;码表—&gt;字符</p><p>Reader默认查询的码表是与操作系统一致的码表，操作系统是中文的，所以reader使用GBK码表</p><p>java查的是unicode的码表</p></blockquote><p><strong>1. 单一职责原则</strong></p><p>一个类只负责一个职责。</p><p><strong>2. 接口隔离原则</strong></p><p>使用多个单独的接口。</p><p><strong>3. 依赖倒转原则</strong></p><p>其核心是面向接口编程（即抽象类）。</p><p><strong>4. 迪米特法则（最少知道原则）</strong></p><p>体现了封装的思想。可以适当违反。</p><p><strong>5. 开闭原则OCP</strong></p><p>对扩展开放，对修改关闭。</p><p><strong>6. 里氏替换原则</strong></p><p>oo中继承的思考。</p><p>所有引用基类的地方必须能透明的使用其子类的对象。</p><p>使用继承时尽量不要重写父类的方法。</p><p>创建一个更加基础的类。使用依赖，聚合，组合的关系。</p><p><strong>7. 合成复用原则</strong></p><p>尽量使用合成聚合的方式，而不是使用继承。</p><h2 id="UML语言介绍"><a href="#UML语言介绍" class="headerlink" title="UML语言介绍"></a>UML语言介绍</h2><p>统一建模语言。</p><p><strong>类图-依赖关系（Dependence）</strong>只要在类中用到了对方，他们就存在依赖关系。</p><p><strong>类图-泛化关系（generalization）</strong>，就是继承关系，是依赖关系的特例。</p><p><strong>类图-实现关系（Implement）</strong>，是依赖关系的特例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Interger id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceBean</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Interger id)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类图-关联关系（Association）</strong></p><p>类与类之间的联系，是依赖关系的特例。有单向和双向关系。</p><p><strong>类图-聚合关系（Aggregation）</strong> 整体与部分的关系，整体与部分可以分开。比如Person和IDCard。聚合式关联关系的特例。</p><p><strong>类图-组合关系（Composition）</strong>也是整体与部分的关系，但是整体与部分不可以分开。例如Person和head。同生共死的关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IDCard card;</span><br><span class="line">    <span class="keyword">private</span> Head head = <span class="keyword">new</span> head();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDCard</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><p><strong>主要步骤：</strong></p><p>1) 构造器私有化 (防止 new )</p><p>2) 类的内部创建对象</p><p>3) 向外暴露一个静态的公共方法</p><p><strong>饿汉式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">new</span> <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本类内部创建对象实例。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//提供一公有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instantce;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点：写法简单，在类装载的时候完成实例化，避免了线程同步问题，没有达到懒加载的效果。</p><p>可用，但会造成内存的浪费。</p><p><strong>双重检查</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;<span class="comment">//volatile可以实现立刻写到内存中</span></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Double-Check是多线程开发中常使用的。线程安全，延迟加载，效率较高。</p><p><strong>静态内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//写一静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一静态的公有方法，直接返回 SingletonInstance.INSTANCE。   </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。避免了线程不安全，利用静态内部类特点实现延迟加载，效率高。推荐使用。</p><p><strong>枚举法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。这种方式是 <strong><em>\</em>Effective**</strong> <strong><em>\</em>Java**</strong> 作者 <strong><em>\</em>Josh**</strong> <strong><em>\</em>Bloch**</strong>  提倡的方式.推荐使用</p><h3 id="2-简单工厂模式"><a href="#2-简单工厂模式" class="headerlink" title="2. 简单工厂模式"></a>2. 简单工厂模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoodFactory</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title">getFood</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        Food food = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(n)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                food = <span class="keyword">new</span> Hamburger();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                food = <span class="keyword">new</span> RiceNoodle();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>服务器修改了具体产品的类名后，客户端不知道。</p><p>工厂的实现不易于扩展，违反了ocp原则，故引入了工厂方法模式。</p><h3 id="3-工厂方法模式"><a href="#3-工厂方法模式" class="headerlink" title="3. 工厂方法模式"></a>3. 工厂方法模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">food</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hamburger</span> <span class="keyword">implements</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃汉堡！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RiceNoodle</span> <span class="keyword">implements</span> <span class="title">Food</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃米线！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//食物工厂</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FoodFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HamburgerFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hamburger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RiceNoodleFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RiceNoodle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FoodFactory ff = <span class="keyword">new</span> HamburgerFactory();</span><br><span class="line">    Food food = ff.getFood();</span><br><span class="line">    food.eat();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂的名字是视为接口的，是趋向稳定的。</p><p>但是当种类很多时，会造成类爆炸式增长，于是引入抽象工厂。</p><h3 id="4-抽象工厂"><a href="#4-抽象工厂" class="headerlink" title="4. 抽象工厂"></a>4. 抽象工厂</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drink <span class="title">getDrink</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KFCFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">getFood</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Hamburger();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Drink <span class="title">getDrink</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cola();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SanQinFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论有多少产品等级，工厂就一类。</p><p>冰箱电视洗衣机视为<strong>产品等级</strong>，工厂厂家海尔海信华为系列产品视为<strong>产品簇</strong>。虽然新增一个工厂很便捷，但抽象工厂扩展产品等级需要所有的工厂都修改，用Spring框架解决。</p><p>抽象工厂中可以生产多个产品，这多个产品之间<strong>必有内在联系</strong>。同一个工厂中的产品都属于一个<strong>产品簇</strong>。</p><h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5. 原型模式"></a>5. 原型模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name,<span class="keyword">int</span> age, String color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供对外的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//克隆该实例</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sheep = (Sheep)<span class="keyword">super</span>.clone();<span class="comment">//sheep是object，但是object不一定是sheep</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java中的Object类是所有类的根类，Object类提供了一个clone()的方法。需要实现clone的java类必须实现一个接口Cloneable，该接口表示该类能复制且有复制的能力。</p><p>上例的clone实现使用了默认的clone()，是浅拷贝，要实现深拷贝可以采用重写clone函数或者<strong>序列化</strong>。</p><p>c++可以用<strong>拷贝构造函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISplitter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~ISplitter()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySplitter</span>:</span> <span class="keyword">public</span> ISplitter&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ISplitter* <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BinarySplitter(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-建造者模式"><a href="#6-建造者模式" class="headerlink" title="6. 建造者模式"></a>6. 建造者模式</h3><p>建造产品的过程的产品解耦合？</p><p>与工厂模式的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Product</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String baise;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String roofed;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBaise</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBaise</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baise = baise;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> House house = <span class="keyword">new</span> House();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">buildHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子打地基5m"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子打砌墙10cm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通房子打顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"高楼打地基100m"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"高楼打砌墙20cm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"高楼打顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">//可扩展房子类型</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//建造指挥</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span></span>&#123;</span><br><span class="line">    HouseBuilder houseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造器传入houseBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//setter传入houseBuilder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">constructHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line">        <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">        HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector(commonHouse);</span><br><span class="line">        House house = houseDirector.constructHouse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;十月间断的学了一些设计模式。这是个长久的课程，还没有学会怎么实际运用到项目中。&lt;/p&gt;
&lt;p&gt;跟随着视频&lt;a href=&quot;https://www.bilibili.com/video/BV1G4411c7N4?p=4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来学&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="设计模式" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建型模式" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，创建型模式" scheme="https://tsuki419.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数码人像摄影读书笔记与实战</title>
    <link href="https://tsuki419.github.io/%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1%E4%B8%8E%E5%90%8E%E6%9C%9F.html"/>
    <id>https://tsuki419.github.io/人像摄影与后期.html</id>
    <published>2019-05-24T06:28:22.000Z</published>
    <updated>2019-06-01T05:04:14.931Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>人像摄影是摄影门类中难较高的。最近读了《品像–数码人像摄影与后期专业教程》这本书，作者徐阳。介绍了各种摄影技巧，本文就其中的几个点做一个笔记。<br><a id="more"></a> </p><p>上一篇博客记录了<a href="https://tsuki419.github.io/风光摄影.html">风光摄影中的一些专业知识和技巧</a>，关于器材和相机的相关概念类似，不作过多描述。那么直接进入主题。</p><h2 id="拍摄技法"><a href="#拍摄技法" class="headerlink" title="拍摄技法"></a>拍摄技法</h2><ul><li><strong>摇拍</strong>是一种拍摄移动中的被摄体的技法，以摇动镜头的方式跟随被摄体来表现其速度感。</li><li><strong>俯拍</strong>有利于表现地平面上景物层次、数量、位置等，给人一种辽阔深远的感受。</li><li><strong>仰拍</strong>有利于突出被摄体高大的气势，能将树这样向上生长的景物在画面上充分展开。仰拍人物时要注意，脸部较胖的尽量不要这样拍。</li><li><strong>平摄</strong>人物活动的场面，能让人感到平等、亲切。</li><li><strong>多次曝光</strong>是在一幅胶片或感光器上拍摄几个影像。</li></ul><h2 id="人像基本构图"><a href="#人像基本构图" class="headerlink" title="人像基本构图"></a>人像基本构图</h2><p>同风光摄影的构图有很多相似之处，人物摄影的主体是人，将人放在画面中的什么位置，如何突出人物主体的地位是应该考虑的问题。</p><h3 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h3><ul><li>井字构图是一个万能的选择。</li><li>中央构图可以配合其他的因素增加图片的分量。</li><li>对角线构图可以使画面活力大增，可以包含人身体的各个部位。</li><li>开放式构图强调画面内外的联系。</li><li>留白式构图可以使观者的思维有所联想和延伸，能产生遐想。</li><li>双重架构式构图可以使画面产生远近，明暗，虚实等装饰效果。</li><li>大景别构图常用在风景优美广阔或大气巍峨的地点来拍摄人像，为避免环境喧宾夺主，可以从环境与人物的虚实、明暗、色彩、质感、动静等的对比达到拍摄意图。</li><li>透视构图可以由空间线条聚焦到被摄体。</li></ul><h3 id="人像公式化构图"><a href="#人像公式化构图" class="headerlink" title="人像公式化构图"></a>人像公式化构图</h3><p>人像公式化构图可分为<strong>特写、半身、七分身、九分身和全身</strong>等构图类型。</p><ul><li>特写与半特写对见于影视和妆面的拍摄，以头顶到胸为构图框线，对被摄者要求面容姣好，表现力强。</li><li>半身构图以头部至腰胯部为构图框，加入了部分肢体。</li><li>七分身构图到膝盖部位上下。九分身构图到脚踝，要求被摄者的小腿部分漂亮。</li><li>全身一般为带背景内容的人像照片。</li></ul><h2 id="摆姿技巧"><a href="#摆姿技巧" class="headerlink" title="摆姿技巧"></a>摆姿技巧</h2><p>这部分内容不仅可以在拍摄模特的时候使用，在平常的摆拍中也可以用到，可以说拯救姿势废。</p><h3 id="各种姿势"><a href="#各种姿势" class="headerlink" title="各种姿势"></a>各种姿势</h3><p>站姿、坐姿、躺卧姿、蹲姿、跪姿、趴姿、跳姿、手姿。</p><ul><li>一般常见的站姿有S形，三角形和斜线型。在表现坐姿时注意坐下时应尽量虚坐在椅子边缘。</li><li>躺卧姿可以非常好的突出女性的柔美曲线，采用躺姿时可以利用手臂的支撑来营造肢体的变化，可采用水平线对角线等构图方法。</li><li>跪姿非常适合表现女性妖娆性感的一面。</li><li>趴姿中手臂的动作很重要。</li><li>跳姿在于拍摄者的抓拍。</li></ul><h3 id="疼痛法摆姿"><a href="#疼痛法摆姿" class="headerlink" title="疼痛法摆姿"></a>疼痛法摆姿</h3><p>虽然疼痛法在美姿中已提出好多年，但是拍摄过程中它还是一个屡试不爽的技巧。可以牙疼、轻度头疼、重度头痛、脖子疼、胸疼、腰疼、肚子疼、腿疼、脚疼，身体尽量避免出现平行或垂直的线条。</p><h2 id="背景与人物"><a href="#背景与人物" class="headerlink" title="背景与人物"></a>背景与人物</h2><p>背景对一幅人像作品的成败起了举足轻重的作用，利用好人物与环境背景的明暗对比，色彩对比，疏密对比，虚实对比，体积对比，曝光对比，动静对比关系等，会有意想不到的效果。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>有人说摄影是熟练工种，也对，但是再想想，哪种艺术不是熟练工种？</p><blockquote><font color="#2da5da"><em>我常会被摄影技巧打动，但我不太喜欢这个词，我之所以为它所动，是因为真正好的技巧之听命于神秘的内心世界。<br>–戴安·阿勃斯(Diane Arbus)</em></font></blockquote><p>—- 5.27更新 —-<br>在接触了真实的相机之后发现第一次看书时忽略的内容都很重要，在此补上一些重要概念。本次实践使用的相机是佳能700D。半按快门对焦后完全按下快门拍摄。</p><h3 id="光线的应用"><a href="#光线的应用" class="headerlink" title="光线的应用"></a>光线的应用</h3><p>光比，亮部与暗部，光比扩大会增加层次感，轮廓硬朗。可以在亮部测出光圈大小，暗部测出光圈大小。相差1级光圈光比为2：1，相差2级光圈光比为4：1，相差3级光圈光比为8：1.大于8属于大光比。更容易控制高调和低调的照片。<br>硬调和柔调，分别表示亮暗的过度程度。大部分照片硬调更好看。<br>曝光宽容度。利用宽容度有限可以创造出于人眼效果不同的效果。</p><h3 id="闪光灯及应用"><a href="#闪光灯及应用" class="headerlink" title="闪光灯及应用"></a>闪光灯及应用</h3><p>在光线昏暗的环境下拍照，如果使用闪光灯加较快的快门拍摄，容易造成前景主体太亮，而背景依旧昏暗，无法辨别细节。而慢速闪光同步会延迟数码相机的快门释放速度，以闪光灯照明前景，配合慢速快门（如1/15s）为弱光背景曝光。这样就能摄出前后景均得到和谐曝光的照片。</p><ul><li>前帘同步闪光是指先闪光，主要用于在光线较暗的时候拍清楚主体。<br>后帘同步闪光主要用于运动的物体拍摄。拍摄时后帘同步开启，快门开启，拉出一串运动的影像，最后闪光灯开启，将主体定格。特殊效果用于表现运动。<br>前后帘在快门速度比较满时比较明显。<br>闪光灯的光会快速的衰减。闪光灯摄影快门不是控制因素。</li><li>闪光灯曝光控制<br>闪光灯曝光控制，可以减少或增加闪光补偿来控制。<br>暗光情况使用闪光灯应该适当增加ISO，慢速快门。</li><li>使用方法<br>弱光增强；强光补光；增加眼神光；创意闪光。</li></ul><h3 id="测光"><a href="#测光" class="headerlink" title="测光"></a>测光</h3><p>测光分为评价测光，中央重点平均测光和点测光。</p><ul><li>中央重点平均测光可以说是人像拍摄独享的测光模式，非常适合画面中央被摄主体亮度均匀而主体周围光线变化较大的场合。</li><li>点测光可以精准控制曝光，是针对画面中央极小范围进行测光的模式。</li></ul><h3 id="相机的设置"><a href="#相机的设置" class="headerlink" title="相机的设置"></a>相机的设置</h3><ol><li>拍摄模式的选择<br>一般情况下对于人像拍摄使用更多的是光圈优先曝光和手动曝光。白平衡放在自动档（配合jpg格式照片），对焦用的更多的是中心点对焦和单次对焦。</li><li>测光模式<br>测光方式用中央重点和点测光。因为作为人像拍摄，首先要保证所拍人物的正确曝光。特写的拍摄用局部测光，更精细的拍摄，逆光等使用点测光，光比比较大的场景中用中央重点平均测光。</li><li>ISO调整<br>光线允许的情况下设为100或200. ISO一般情况下越低越好。光线较暗，阴天的傍晚可以选择400，室内光线较暗可以选择800，偷拍可以选择1600。感光度越高，照片质量越粗糙。</li><li>自动化亮度<br>启动自动亮度优化虽然会拖慢机内处理速度但是拍人像无所谓。</li><li>光圈<br>一般镜头会用到的光圈号数为f/2.8~f/22.光圈优先AE是一种在人像和风光摄影中都最常用的自动曝光方式。</li><li>曝光<br>如何准确曝光，测光表标尺到零就可以准确曝光。标尺在负的一端时，可以先将光圈缩小，接下来再考虑转动快门。如果标尺在正的一端，光圈增大，接下来转动快门，增快快门速度。快门速度过快时，手很难端稳，可以选择三脚架或者开闪关灯。<br>手动模式M下可以拨动轮盘调节快门，Av+轮盘调节光圈。</li></ol><h3 id="拍摄人像时的两种常用镜头"><a href="#拍摄人像时的两种常用镜头" class="headerlink" title="拍摄人像时的两种常用镜头"></a>拍摄人像时的两种常用镜头</h3><ol><li>原厂镜头和副厂镜头<br>副厂镜头有些品质不输原厂，而且价格比原厂便宜。</li><li>变焦镜头和定焦镜头<br>24~70mm或24~120mm属于标准变焦镜，70~200mm或70~300mm属于望远变焦镜。50mm、85mm和135mm属于定焦镜头，这些镜头都可以用来拍摄人像。长焦端的镜头景深浅。初学者可以优先使用中望远镜头入手。</li></ol><h3 id="夜间拍摄"><a href="#夜间拍摄" class="headerlink" title="夜间拍摄"></a>夜间拍摄</h3><ul><li>夜景采用广角镜头摄影，风光摄影。拍摄地点多为俯拍，增加画面中的信息量。<br>夜景广角镜头是一个较好的镜头，感光度ISO应尽量低，快门速度慢（无法手端），产生了长时间曝光。利用三脚架取景，辅助使用快门线实现闭门。降噪功能设为自动时在镜头速度较慢的时候打开。白平衡设置5500以上色温，低色温显示冷调，也可以直接设置为钨丝灯模式。对焦选择单次对焦。面对白纸时会对焦失败，采用手动对焦，拨动对焦环即可。建议使用平均测光。建议使用小光圈，让光源表现出星芒。小光圈8 11 16等成像质量会更好。<br>如果拍摄的不是大场景可以使用大光圈。夜景摄影没有苛刻的曝光要求。<br>拍摄夜景避免大光源入镜。</li><li>拍摄夜景人像使用快门优先，慢速快门可以拍背景，前景由闪光灯照亮。焦距短一点，光圈收小一些。<br>ISO可以使用400~800， 稍大的F4、F2.8的光圈。找到合适的快门，在此快门基础上减少一道两级的曝光。白平衡模式使用闪光灯，设置后帘同步。<br>要搞清楚闪光灯的范围，不超过5m。快门最好用脚架。<br>拍摄人像可以采用中长焦。85mm以上。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人像摄影是摄影门类中难较高的。最近读了《品像–数码人像摄影与后期专业教程》这本书，作者徐阳。介绍了各种摄影技巧，本文就其中的几个点做一个笔记。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://tsuki419.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="摄影" scheme="https://tsuki419.github.io/categories/%E7%94%9F%E6%B4%BB/%E6%91%84%E5%BD%B1/"/>
    
      <category term="人像摄影" scheme="https://tsuki419.github.io/categories/%E7%94%9F%E6%B4%BB/%E6%91%84%E5%BD%B1/%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="读书笔记" scheme="https://tsuki419.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="人像摄影" scheme="https://tsuki419.github.io/tags/%E4%BA%BA%E5%83%8F%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>风光摄影读书笔记</title>
    <link href="https://tsuki419.github.io/%E9%A3%8E%E5%85%89%E6%91%84%E5%BD%B1.html"/>
    <id>https://tsuki419.github.io/风光摄影.html</id>
    <published>2019-05-22T11:30:25.000Z</published>
    <updated>2019-05-28T09:16:47.893Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Everything you need to know about landscape photography techniques and subjects.<br>一直都很想学习摄影，虽然没有专业器材，但用手机镜头记录下生活的点点滴滴也是一件美好的事情。正值毕业季，为了在校园拍出美美的回忆，去图书馆补充了一下专业知识《风光摄影圣经》。本篇博客作为一个风光摄影的读书笔记。<br><a id="more"></a> </p><h2 id="风光摄影的前期准备"><a href="#风光摄影的前期准备" class="headerlink" title="风光摄影的前期准备"></a>风光摄影的前期准备</h2><p>在进行摄影之前需要先对摄影的器材和名词了解一下。</p><h3 id="相机相关概念"><a href="#相机相关概念" class="headerlink" title="相机相关概念"></a>相机相关概念</h3><p>风光摄影要求照片的暗部细节有很好的表现，意味着相机要有较高的色彩宽容度和分辨率。</p><ol><li>镜头的分类</li></ol><ul><li>广角镜头分两种，普通广角镜头焦距一般在24~38mm，超广角镜头的焦距为13~24mm。广角镜头景深比较大，可以有效的夸张前景和表现景物的远近层次。</li><li>标准镜头是与人眼的视角相近的镜头，国际标准为50mm。一般用于空中拍摄，或者近距离风光拍摄和中景特写。</li><li>长焦镜头通常焦距在70~400mm之间。长焦镜头可以将远处的景物拉近拍摄，产生空间压缩的效果，还可以作为特写镜头。</li><li>变焦镜头的画质要略逊色于定焦镜头。<div class="note info"><font color="darkslategrey"><p>镜头的分类在使用AE搭建场景的时候已经初步接触，在这里再次遇到做个整理。贴上AE中运用摄像机做的<a href="https://www.bilibili.com/video/av13904884" target="_blank" rel="noopener">镜头模仿练习</a>。</p></font></div></li></ul><ol start="2"><li>光圈和景深</li></ol><ul><li>光圈是相机上用来控制镜头孔径大小的部件。<br>光圈f值=镜头的焦距/镜头口径的直径。光圈f值越小，在同一单位时间内的进光量便越多，而且上一级的进光量刚好比下一级的多一倍。<br>利用小光圈可以获得大景深。在风光摄影中，中景，全景，远景等景别适合用小光圈拍摄增加纵深感。</li><li>景深是焦点前后的一段能清晰显示的景物的清晰度范围。拍摄花和昆虫的照片中将背景拍的很模糊为小景深，将背景与被摄主体拍的一样清晰为大景深。影响景深的因为有光圈，焦距和物距三大方面。<div class="note info"><font color="darkslategrey"><p>景深的使用，在3d建模的过程中接触过，保留模型的景深导入AE进行后期处理，可以营造很好的空间效果。</p></font></div></li></ul><ol start="3"><li>不同的快门<br>低速快门可以虚化动体，制造出虚实相衬的效果，将画面拍出动感，比如烟雾缭绕的感觉。而高速快门可以凝固动体，可以清晰的记录快速运动中的物体，高速快门的应用在于时机的捕捉。下图为低速快门图，图源网络。<br><img src="https://i.loli.net/2019/05/23/5ce61827b15a976558.jpg" alt><div class="note info"><font color="darkslategrey"><p>第一次见到低速快门拍照的照片，真实的仙境感。</p></font></div></li></ol><h3 id="取景"><a href="#取景" class="headerlink" title="取景"></a>取景</h3><p>拍摄可以根据景物的特点选择横画幅和竖画幅，拍照时将手机持平，使照片内的地平线水平，给人以平稳安定的感觉，一般忌讳将地平线居中。照片要吸引观众的视线，给人留下深刻印象，这就要画面的趣味点，我们可以用前景的物体使得普通的风光照片更有趣味性。<br>不同的景别：</p><ul><li>近景所展现的主体细节更丰富。中景经常记录我们眼前发生的事物，常常以动作或情节取胜。全景可以完整的表现主体的形体及周遭环境。远景画面开阔，景深悠远。</li></ul><h2 id="用光与构图"><a href="#用光与构图" class="headerlink" title="用光与构图"></a>用光与构图</h2><p>光影变换塑造了不同风格的画面，是拍照中不可忽略的因素，虽然影子影响画面的美观，但是用好影子也会有意想不到的效果。</p><h3 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h3><ul><li>顺光拍摄给人明亮晴朗的感觉。</li><li>侧光拍摄可以产生具有明显方向性的投影，具有非常好的造型效果。<br>前侧光使画面更加丰富；<br>正侧光是的画面有一个非常明显的过渡，除了拍摄要求显示凹凸明显的碑刻等物体外，很少使用；<br>后侧光多用于艺术创作，纵深感强。</li><li>逆光塑造独特的效果。拍摄透明，半透明的物体逆光为最佳光线。</li><li>眩光在光线和拍摄主题合适时，只要曝光合适，再结合良好的构图和被摄主体，往往会得到神奇的戏剧化效果。</li></ul><h3 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h3><p>巧妙的构图是一种艺术，是一种美学概念。</p><p><div class="note info"><font color="darkslategrey"><p>总感觉自己拍出来的照片很难看，原来是从来没有注意过构图，一直都是凭感觉瞎拍，学了构图以后也可以实践一番了。构图不仅在拍照中会用到，画画和搭建场景中都会用到。</p></font></div></p><ol><li>经典的三分法即黄金分割法。</li><li>S形构图动感效果强，既动又稳。远景俯拍效果最佳，适合山川河流的自然起伏和人体动物物体的曲线排列变化。</li><li>A形构图具有向上的冲击力和强劲的视觉引导力。适合拍摄眼神的长路，长桥和高耸的建筑物。</li><li>O形构图稳定感强。</li><li>斜线构图能形成深度空间，使画面具有活力，还能形成指向性，同时给人以三位空间感。溪流、铁轨、小路、围栏、墙壁、篱笆、电线以及远景中的道路桥梁都可以做斜线。</li><li>对角线构图，具有方向感，动感和活泼。线条汇聚，吸引人们的视线。</li><li>曲线构图。</li><li>稳定的三角形构图。</li><li>漂亮的放射形构图，常用于要突出主体，而场面又复杂的场合。</li><li>突出主体的框架式构图，一般用于有前景的拍摄， 比如利用门窗，山洞口，其他框架作为前景。<br>本文没能加入很多的图片说明，这里有前人的<a href="https://blog.csdn.net/qq_34129814/article/details/80271516" target="_blank" rel="noopener">构图总结</a>。希望在今后的拍照运用中逐渐实践学到的方法，创建属于自己的作品图库。</li></ol><h2 id="色彩探索"><a href="#色彩探索" class="headerlink" title="色彩探索"></a>色彩探索</h2><p><blockquote class="question">不同的色彩能使人产生不同的官能感觉。暖色调使人感到热烈兴奋，冷色调使人感到优雅，宁静。在摄影中如何搭配色彩构成画面，什么样的色彩搭配在一起更加漂亮，这是每个摄影人必须学会的理论知识。<br>色彩之间的搭配主要有富有烘托效果的同类色(45deg)，具有表现效果的互补色(150~180deg)，效果和谐的相邻色(90deg以内)，突出主体的对比色(对比形式多样，有冷暖，补色，明暗的对比。红与绿，蓝与黄石互补色。)等几个分类。</blockquote></p><p><div style="width:200px;margin:0 auto;"><img src="https://i.loli.net/2019/05/23/5ce631ff6466814579.jpg" alt></div></p><p><div class="note primary"><font color="darkslategrey"><p>有时会觉得拍照就是一个高级的绘画过程，逼真的展现事物的原貌，同样考虑到了构图，光影，色彩，可以说艺术是相通的吧。读书笔记中有很多没有记录到的内容，比如测光与曝光，焦点的选择，滤镜的选择。这本书后几章的拍摄实践包括山水美景，冰雪云雾和日月星辰，提供了很多实用的拍摄tips，但是技巧都是在实践中磨练的，就不在这里记录了。等上手实践之后再来更新。</p></font></div><br>    参考书籍：风光摄影圣经 –创造影像</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Everything you need to know about landscape photography techniques and subjects.&lt;br&gt;一直都很想学习摄影，虽然没有专业器材，但用手机镜头记录下生活的点点滴滴也是一件美好的事情。正值毕业季，为了在校园拍出美美的回忆，去图书馆补充了一下专业知识《风光摄影圣经》。本篇博客作为一个风光摄影的读书笔记。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="https://tsuki419.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="摄影" scheme="https://tsuki419.github.io/categories/%E7%94%9F%E6%B4%BB/%E6%91%84%E5%BD%B1/"/>
    
      <category term="风光摄影" scheme="https://tsuki419.github.io/categories/%E7%94%9F%E6%B4%BB/%E6%91%84%E5%BD%B1/%E9%A3%8E%E5%85%89%E6%91%84%E5%BD%B1/"/>
    
    
      <category term="风光摄影" scheme="https://tsuki419.github.io/tags/%E9%A3%8E%E5%85%89%E6%91%84%E5%BD%B1/"/>
    
      <category term="镜头" scheme="https://tsuki419.github.io/tags/%E9%95%9C%E5%A4%B4/"/>
    
      <category term="构图" scheme="https://tsuki419.github.io/tags/%E6%9E%84%E5%9B%BE/"/>
    
      <category term="读书笔记" scheme="https://tsuki419.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>搭建博客初体验</title>
    <link href="https://tsuki419.github.io/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%88%9D%E4%BD%93%E9%AA%8C.html"/>
    <id>https://tsuki419.github.io/搭建博客初体验.html</id>
    <published>2019-05-07T02:42:25.758Z</published>
    <updated>2021-06-01T13:28:49.459Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to my blog.This is my very first post.<br>折腾了好几天hexo配合github搭建博客成功，需要优化的还有很多，需要学习的技能也好多。建博客的过程中，遇到了好多问题，看教程的时候仿佛大家都水到渠成，只有我和成功之间隔着千山万水。ORZ记录一下遇到的问题和解决方法。<br><a id="more"></a> </p><h2 id="hexo-github搭建博客雏形"><a href="#hexo-github搭建博客雏形" class="headerlink" title="hexo+github搭建博客雏形"></a>hexo+github搭建博客雏形</h2><p>首先感谢<a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化</a>手把手教程。</p><h3 id="题外话之修改hosts访问google"><a href="#题外话之修改hosts访问google" class="headerlink" title="题外话之修改hosts访问google"></a>题外话之修改hosts访问google</h3><p>首先翻墙是一项必备技能，根据<a href="https://laod.cn/hosts/2019-hosts.html" target="_blank" rel="noopener">老D博客</a>里的步骤替换hosts，出现了一些问题，目前仍然没能找到翻墙的正确姿势。</p><ol><li>hostipconfig/flushdns 无法使用：查找后可以通过<a href="https://blog.csdn.net/hi_boy_/article/details/78059189" target="_blank" rel="noopener">设置path</a>解决。</li><li>出现了谷歌学术搜索页面，但是搜索会显示“请进行人机身份验证”。</li></ol><h3 id="前奏之安装node-js和git"><a href="#前奏之安装node-js和git" class="headerlink" title="前奏之安装node.js和git"></a>前奏之安装node.js和git</h3><p><div class="note default"><p>教程里很清楚了，不再赘述。</p></div><br>安装之后用下述代码查看是否安装成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git --version</span><br><span class="line">$ node -v</span><br></pre></td></tr></table></figure></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>做好前期准备开始安装hexo，血泪史，因为版本问题导致的惨剧，是谁说的warn信息都不用管的。</p><ol><li>报错：local hexo not found in xxx:<br>在网上各种搜索，删除项目中的package.json,执行npm init生成新的package.json替换，虽然不再报错，但是出现了新问题。</li><li>返回usage信息，hexo命令干脆不能用了，倒腾一晚上，git和nodejs确实装好了，也不是运行命令的目录不正确，最后考虑是环境变量问题。直到第二天重装node.js，确认问题是node.js版本过低所致。</li></ol><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>报错：could not read from remote repository<br>经过检查发现是github项目名称写错。真是时常被自己蠢哭。</p><h2 id="发文"><a href="#发文" class="headerlink" title="发文"></a>发文</h2><p>至此，终于在建好了博客雏形，看到网页的时候感动哭。先发文看看。</p><h3 id="编辑博文并发表"><a href="#编辑博文并发表" class="headerlink" title="编辑博文并发表"></a>编辑博文并发表</h3><p>markdown是一种标记性语言，第一次接触也可以上手很快。<a href="https://www.jianshu.com/p/a5387c159bd9" target="_blank" rel="noopener">新手速成看这里</a></p><ol><li>中文乱码：<br>多半是编码问题，换个编码方式编辑。使用UTF-8编码方式，成功解决。 </li><li><p>如何更新博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"Hello world"</span></span><br><span class="line"></span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li><li><p>网易云音乐产生外部链接<br><a href="http://link.hhtjim.com/163/xxx.mp3" target="_blank" rel="noopener">http://link.hhtjim.com/163/xxx.mp3</a> 将歌曲链接的对应id替换xxx位置即可<br>安装插件aplayer之后插入博客中见下图：</p>        <div id="aplayer-czAxIQFE" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-czAxIQFE"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "Hit and Run",              author: "Lolo",              url: "https://link.hhtjim.com/163/28987151.mp3",              pic: "https://i.loli.net/2019/05/09/5cd41d6fa31f5.jpg",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script></li><li>插入图片<br>七牛云倒腾半天，发现提供的免费域名只能用30天， 为了图片不失效，只能买自己的域名。目前由于懒就用了在线图床<a href="https://sm.ms" target="_blank" rel="noopener">SM.MS</a>。这里有关于<a href="https://blog.csdn.net/u012195214/article/details/79204607" target="_blank" rel="noopener">图床</a>的一些介绍。<br><img src="https://i.loli.net/2019/05/11/5cd6b1d16a2f0.jpg" alt></li></ol><h2 id="副本之博客优化"><a href="#副本之博客优化" class="headerlink" title="副本之博客优化"></a>副本之博客优化</h2><p>光秃秃的博客是没有灵魂的，<font color="pink"><del>接下来可以开始装装点点，开始幸福生活啦。</del> </font> 一个好的博客既要有好的内容，也要有漂亮的外在，门面嘛，既然要经营就要从内到外到经营好，于是开启了副本之漫长的优化之路。<br>先写到这里，优化虽然跟着教程做了一些有了一些理解，等补一些之后再来更新。</p><font color="red">未完待续~</font><hr><p>2021/06/01</p><p>时间一晃，博客优化还是没做哈哈哈，瞎折腾太累了。补充一下以前存的教程贴。</p><h3 id="hexo搭建博客篇"><a href="#hexo搭建博客篇" class="headerlink" title="hexo搭建博客篇"></a>hexo搭建博客篇</h3><p><a href="https://yangbingdong.com/2017/build-blog-hexo-base/#GitHub" target="_blank" rel="noopener">基于Hexo+Github+Coding搭建个人博客-基础篇</a></p><p><a href="https://yangbingdong.com/2017/build-blog-hexo-advanced/#%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">基于Hexo+Github+Coding搭建个人博客-进阶篇</a></p><p>博主整理的还是挺清楚的。很久之前参照进阶篇进行了搜索引擎优化，好像也没有用到，依旧是没人看的小博客orz。</p><p><a href="https://www.sdwebseo.com/google-analytics-tutorial/" target="_blank" rel="noopener">Google Analytics教程,谷歌分析使用方法教程</a></p><p>突然发现适配手机端的教程挂掉了，啊..</p><h3 id="界面美化篇"><a href="#界面美化篇" class="headerlink" title="界面美化篇"></a>界面美化篇</h3><p><a href="https://blog.csdn.net/qq_36759224/article/details/85010191" target="_blank" rel="noopener">Hexo 博客优化之实用功能添加系列</a></p><p><a href="https://blog.csdn.net/qq_36759224/article/details/85420403" target="_blank" rel="noopener">Hexo 博客优化之博客美化系列</a></p><p><a href="https://blog.csdn.net/l_201607/article/details/81097278" target="_blank" rel="noopener">Hexo 博客添加各种有趣又有用的小功能</a></p><h3 id="评论篇"><a href="#评论篇" class="headerlink" title="评论篇"></a>评论篇</h3><p>评论之前是用着valine，但是由于leancloud要求实名认证，不能用了，好吧，就很久没评论区了。</p><p><a href="https://blog.csdn.net/blue_zy/article/details/79071414" target="_blank" rel="noopener">为你的Hexo加上评论系统-Valine</a></p><p>gitment也试过，不知道什么问题不能用，人懒，先算了吧，反正也不会有人评论的。</p><p><a href="https://ryanluoxu.github.io/2017/11/27/Hexo-Next-%E6%B7%BB%E5%8A%A0-Gitment-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">Hexo-Next 添加 Gitment 评论系统</a></p><p>先这样吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to my blog.This is my very first post.&lt;br&gt;折腾了好几天hexo配合github搭建博客成功，需要优化的还有很多，需要学习的技能也好多。建博客的过程中，遇到了好多问题，看教程的时候仿佛大家都水到渠成，只有我和成功之间隔着千山万水。ORZ记录一下遇到的问题和解决方法。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="hexo" scheme="https://tsuki419.github.io/categories/%E6%8A%80%E6%9C%AF/hexo/"/>
    
    
      <category term="hosts" scheme="https://tsuki419.github.io/tags/hosts/"/>
    
      <category term="blog" scheme="https://tsuki419.github.io/tags/blog/"/>
    
      <category term="hexo" scheme="https://tsuki419.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
